(self["webpackChunkbookmark2"] = self["webpackChunkbookmark2"] || []).push([["vendors.js"],{

/***/ "./node_modules/.pnpm/@iconify+icons-line-md@1.2.22/node_modules/@iconify/icons-line-md/moon-alt-to-sunny-outline-loop-transition.js":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@iconify+icons-line-md@1.2.22/node_modules/@iconify/icons-line-md/moon-alt-to-sunny-outline-loop-transition.js ***!
  \*******************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

var __webpack_unused_export__;
const data = {
	"width": 24,
	"height": 24,
	"body": "<g fill=\"none\" stroke=\"currentColor\" stroke-dasharray=\"2\" stroke-dashoffset=\"2\" stroke-linecap=\"round\" stroke-width=\"2\"><path d=\"M0 0\"><animate fill=\"freeze\" attributeName=\"d\" begin=\"0.6s\" dur=\"0.2s\" values=\"M12 19v1M19 12h1M12 5v-1M5 12h-1;M12 21v1M21 12h1M12 3v-1M3 12h-1\"/><animate fill=\"freeze\" attributeName=\"stroke-dashoffset\" begin=\"0.6s\" dur=\"0.2s\" values=\"2;0\"/></path><path d=\"M0 0\"><animate fill=\"freeze\" attributeName=\"d\" begin=\"0.9s\" dur=\"0.2s\" values=\"M17 17l0.5 0.5M17 7l0.5 -0.5M7 7l-0.5 -0.5M7 17l-0.5 0.5;M18.5 18.5l0.5 0.5M18.5 5.5l0.5 -0.5M5.5 5.5l-0.5 -0.5M5.5 18.5l-0.5 0.5\"/><animate fill=\"freeze\" attributeName=\"stroke-dashoffset\" begin=\"0.9s\" dur=\"1.2s\" values=\"2;0\"/></path><animateTransform attributeName=\"transform\" dur=\"30s\" repeatCount=\"indefinite\" type=\"rotate\" values=\"0 12 12;360 12 12\"/></g><mask id=\"lineMdMoonAltToSunnyOutlineLoopTransition0\"><circle cx=\"12\" cy=\"12\" r=\"12\" fill=\"#fff\"/><circle cx=\"12\" cy=\"12\" r=\"8\"><animate fill=\"freeze\" attributeName=\"r\" dur=\"0.4s\" values=\"8;4\"/></circle><circle cx=\"18\" cy=\"6\" r=\"12\" fill=\"#fff\"><animate fill=\"freeze\" attributeName=\"cx\" dur=\"0.4s\" values=\"18;22\"/><animate fill=\"freeze\" attributeName=\"cy\" dur=\"0.4s\" values=\"6;2\"/><animate fill=\"freeze\" attributeName=\"r\" dur=\"0.4s\" values=\"12;3\"/></circle><circle cx=\"18\" cy=\"6\" r=\"10\"><animate fill=\"freeze\" attributeName=\"cx\" dur=\"0.4s\" values=\"18;22\"/><animate fill=\"freeze\" attributeName=\"cy\" dur=\"0.4s\" values=\"6;2\"/><animate fill=\"freeze\" attributeName=\"r\" dur=\"0.4s\" values=\"10;1\"/></circle></mask><circle cx=\"12\" cy=\"12\" r=\"10\" fill=\"currentColor\" mask=\"url(#lineMdMoonAltToSunnyOutlineLoopTransition0)\"><animate fill=\"freeze\" attributeName=\"r\" dur=\"0.4s\" values=\"10;6\"/></circle>"
};
__webpack_unused_export__ = true;
exports["default"] = data;


/***/ }),

/***/ "./node_modules/.pnpm/@iconify+icons-line-md@1.2.22/node_modules/@iconify/icons-line-md/moon-filled-alt-loop.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@iconify+icons-line-md@1.2.22/node_modules/@iconify/icons-line-md/moon-filled-alt-loop.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

var __webpack_unused_export__;
const data = {
	"width": 24,
	"height": 24,
	"body": "<g fill=\"none\" stroke=\"currentColor\" stroke-dasharray=\"4\" stroke-dashoffset=\"4\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><path d=\"M13 4h1.5M13 4h-1.5M13 4v1.5M13 4v-1.5\"><animate id=\"lineMdMoonFilledAltLoop0\" fill=\"freeze\" attributeName=\"stroke-dashoffset\" begin=\"0.7s;lineMdMoonFilledAltLoop0.begin+6s\" dur=\"0.4s\" values=\"4;0\"/><animate fill=\"freeze\" attributeName=\"stroke-dashoffset\" begin=\"lineMdMoonFilledAltLoop0.begin+2s;lineMdMoonFilledAltLoop0.begin+4s\" dur=\"0.4s\" values=\"4;0\"/><animate fill=\"freeze\" attributeName=\"stroke-dashoffset\" begin=\"lineMdMoonFilledAltLoop0.begin+1.2s;lineMdMoonFilledAltLoop0.begin+3.2s;lineMdMoonFilledAltLoop0.begin+5.2s\" dur=\"0.4s\" values=\"0;4\"/><set attributeName=\"d\" begin=\"lineMdMoonFilledAltLoop0.begin+1.8s\" to=\"M12 5h1.5M12 5h-1.5M12 5v1.5M12 5v-1.5\"/><set attributeName=\"d\" begin=\"lineMdMoonFilledAltLoop0.begin+3.8s\" to=\"M12 4h1.5M12 4h-1.5M12 4v1.5M12 4v-1.5\"/><set attributeName=\"d\" begin=\"lineMdMoonFilledAltLoop0.begin+5.8s\" to=\"M13 4h1.5M13 4h-1.5M13 4v1.5M13 4v-1.5\"/></path><path d=\"M19 11h1.5M19 11h-1.5M19 11v1.5M19 11v-1.5\"><animate id=\"lineMdMoonFilledAltLoop1\" fill=\"freeze\" attributeName=\"stroke-dashoffset\" begin=\"1.1s;lineMdMoonFilledAltLoop1.begin+6s\" dur=\"0.4s\" values=\"4;0\"/><animate fill=\"freeze\" attributeName=\"stroke-dashoffset\" begin=\"lineMdMoonFilledAltLoop1.begin+2s;lineMdMoonFilledAltLoop1.begin+4s\" dur=\"0.4s\" values=\"4;0\"/><animate fill=\"freeze\" attributeName=\"stroke-dashoffset\" begin=\"lineMdMoonFilledAltLoop1.begin+1.2s;lineMdMoonFilledAltLoop1.begin+3.2s;lineMdMoonFilledAltLoop1.begin+5.2s\" dur=\"0.4s\" values=\"0;4\"/><set attributeName=\"d\" begin=\"lineMdMoonFilledAltLoop1.begin+1.8s\" to=\"M17 11h1.5M17 11h-1.5M17 11v1.5M17 11v-1.5\"/><set attributeName=\"d\" begin=\"lineMdMoonFilledAltLoop1.begin+3.8s\" to=\"M18 12h1.5M18 12h-1.5M18 12v1.5M18 12v-1.5\"/><set attributeName=\"d\" begin=\"lineMdMoonFilledAltLoop1.begin+5.8s\" to=\"M19 11h1.5M19 11h-1.5M19 11v1.5M19 11v-1.5\"/></path><path d=\"M19 4h1.5M19 4h-1.5M19 4v1.5M19 4v-1.5\"><animate id=\"lineMdMoonFilledAltLoop2\" fill=\"freeze\" attributeName=\"stroke-dashoffset\" begin=\"2.9s;lineMdMoonFilledAltLoop2.begin+6s\" dur=\"0.4s\" values=\"4;0\"/><animate fill=\"freeze\" attributeName=\"stroke-dashoffset\" begin=\"lineMdMoonFilledAltLoop2.begin+2s\" dur=\"0.4s\" values=\"4;0\"/><animate fill=\"freeze\" attributeName=\"stroke-dashoffset\" begin=\"lineMdMoonFilledAltLoop2.begin+1.2s;lineMdMoonFilledAltLoop2.begin+3.2s\" dur=\"0.4s\" values=\"0;4\"/><set attributeName=\"d\" begin=\"lineMdMoonFilledAltLoop2.begin+1.8s\" to=\"M20 5h1.5M20 5h-1.5M20 5v1.5M20 5v-1.5\"/><set attributeName=\"d\" begin=\"lineMdMoonFilledAltLoop2.begin+5.8s\" to=\"M19 4h1.5M19 4h-1.5M19 4v1.5M19 4v-1.5\"/></path></g><g fill-opacity=\"0\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\"><path fill=\"currentColor\" stroke-dasharray=\"56\" stroke-dashoffset=\"56\" d=\"M7 6 C7 12.08 11.92 17 18 17 C18.53 17 19.05 16.96 19.56 16.89 C17.95 19.36 15.17 21 12 21 C7.03 21 3 16.97 3 12 C3 8.83 4.64 6.05 7.11 4.44 C7.04 4.95 7 5.47 7 6 Z\"><animate fill=\"freeze\" attributeName=\"stroke-dashoffset\" dur=\"0.6s\" values=\"56;0\"/><animate fill=\"freeze\" attributeName=\"fill-opacity\" begin=\"1.5s\" dur=\"0.5s\" values=\"0;1\"/></path></g>"
};
__webpack_unused_export__ = true;
exports["default"] = data;


/***/ }),

/***/ "./node_modules/.pnpm/svelte-hmr@0.14.12_svelte@3.50.1/node_modules/svelte-hmr/runtime/proxy-adapter-dom.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/svelte-hmr@0.14.12_svelte@3.50.1/node_modules/svelte-hmr/runtime/proxy-adapter-dom.js + 1 modules ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

// UNUSED EXPORTS: adapter, default

// EXTERNAL MODULE: ./node_modules/.pnpm/svelte@3.50.1/node_modules/svelte/internal/index.mjs
var internal = __webpack_require__("./node_modules/.pnpm/svelte@3.50.1/node_modules/svelte/internal/index.mjs");
;// CONCATENATED MODULE: ./node_modules/.pnpm/svelte-hmr@0.14.12_svelte@3.50.1/node_modules/svelte-hmr/runtime/overlay.js
/* eslint-env browser */

const removeElement = el => el && el.parentNode && el.parentNode.removeChild(el)

const ErrorOverlay = () => {
  let errors = []
  let compileError = null

  const errorsTitle = 'Failed to init component'
  const compileErrorTitle = 'Failed to compile'

  const style = {
    section: `
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 32px;
      background: rgba(0, 0, 0, .85);
      font-family: Menlo, Consolas, monospace;
      font-size: large;
      color: rgb(232, 232, 232);
      overflow: auto;
      z-index: 2147483647;
    `,
    h1: `
      margin-top: 0;
      color: #E36049;
      font-size: large;
      font-weight: normal;
    `,
    h2: `
      margin: 32px 0 0;
      font-size: large;
      font-weight: normal;
    `,
    pre: ``,
  }

  const createOverlay = () => {
    const h1 = document.createElement('h1')
    h1.style = style.h1
    const section = document.createElement('section')
    section.appendChild(h1)
    section.style = style.section
    const body = document.createElement('div')
    section.appendChild(body)
    return { h1, el: section, body }
  }

  const setTitle = title => {
    overlay.h1.textContent = title
  }

  const show = () => {
    const { el } = overlay
    if (!el.parentNode) {
      const target = document.body
      target.appendChild(overlay.el)
    }
  }

  const hide = () => {
    const { el } = overlay
    if (el.parentNode) {
      overlay.el.remove()
    }
  }

  const update = () => {
    if (compileError) {
      overlay.body.innerHTML = ''
      setTitle(compileErrorTitle)
      const errorEl = renderError(compileError)
      overlay.body.appendChild(errorEl)
      show()
    } else if (errors.length > 0) {
      overlay.body.innerHTML = ''
      setTitle(errorsTitle)
      errors.forEach(({ title, message }) => {
        const errorEl = renderError(message, title)
        overlay.body.appendChild(errorEl)
      })
      show()
    } else {
      hide()
    }
  }

  const renderError = (message, title) => {
    const div = document.createElement('div')
    if (title) {
      const h2 = document.createElement('h2')
      h2.textContent = title
      h2.style = style.h2
      div.appendChild(h2)
    }
    const pre = document.createElement('pre')
    pre.textContent = message
    div.appendChild(pre)
    return div
  }

  const addError = (error, title) => {
    const message = (error && error.stack) || error
    errors.push({ title, message })
    update()
  }

  const clearErrors = () => {
    errors.forEach(({ element }) => {
      removeElement(element)
    })
    errors = []
    update()
  }

  const setCompileError = message => {
    compileError = message
    update()
  }

  const overlay = createOverlay()

  return {
    addError,
    clearErrors,
    setCompileError,
  }
}

/* harmony default export */ const overlay = (ErrorOverlay);

;// CONCATENATED MODULE: ./node_modules/.pnpm/svelte-hmr@0.14.12_svelte@3.50.1/node_modules/svelte-hmr/runtime/proxy-adapter-dom.js
/* global window, document */

// NOTE from 3.38.3 (or so), insert was carrying the hydration logic, that must
// be used because DOM elements are reused more (and so insertion points are not
// necessarily added in order); then in 3.40 the logic was moved to
// insert_hydration, which is the one we must use for HMR
const svelteInsert = internal.insert_hydration || internal.insert
if (!svelteInsert) {
  throw new Error(
    'failed to find insert_hydration and insert in svelte/internal'
  )
}



const proxy_adapter_dom_removeElement = el => el && el.parentNode && el.parentNode.removeChild(el)

const adapter = class ProxyAdapterDom {
  constructor(instance) {
    this.instance = instance
    this.insertionPoint = null

    this.afterMount = this.afterMount.bind(this)
    this.rerender = this.rerender.bind(this)

    this._noOverlay = !!instance.hotOptions.noOverlay
  }

  // NOTE overlay is only created before being actually shown to help test
  // runner (it won't have to account for error overlay when running assertions
  // about the contents of the rendered page)
  static getErrorOverlay(noCreate = false) {
    if (!noCreate && !this.errorOverlay) {
      this.errorOverlay = overlay()
    }
    return this.errorOverlay
  }

  // TODO this is probably unused now: remove in next breaking release
  static renderCompileError(message) {
    const noCreate = !message
    const overlay = this.getErrorOverlay(noCreate)
    if (!overlay) return
    overlay.setCompileError(message)
  }

  dispose() {
    // Component is being destroyed, detaching is not optional in Svelte3's
    // component API, so we can dispose of the insertion point in every case.
    if (this.insertionPoint) {
      proxy_adapter_dom_removeElement(this.insertionPoint)
      this.insertionPoint = null
    }
    this.clearError()
  }

  // NOTE afterMount CAN be called multiple times (e.g. keyed list)
  afterMount(target, anchor) {
    const {
      instance: { debugName },
    } = this
    if (!this.insertionPoint) {
      this.insertionPoint = document.createComment(debugName)
    }
    svelteInsert(target, this.insertionPoint, anchor)
  }

  rerender() {
    this.clearError()
    const {
      instance: { refreshComponent },
      insertionPoint,
    } = this
    if (!insertionPoint) {
      throw new Error('Cannot rerender: missing insertion point')
    }
    refreshComponent(insertionPoint.parentNode, insertionPoint)
  }

  renderError(err) {
    if (this._noOverlay) return
    const {
      instance: { debugName },
    } = this
    const title = debugName || err.moduleName || 'Error'
    this.constructor.getErrorOverlay().addError(err, title)
  }

  clearError() {
    if (this._noOverlay) return
    const overlay = this.constructor.getErrorOverlay(true)
    if (!overlay) return
    overlay.clearErrors()
  }
}

// TODO this is probably unused now: remove in next breaking release
if (typeof window !== 'undefined') {
  window.__SVELTE_HMR_ADAPTER = adapter
}

// mitigate situation with Snowpack remote source pulling latest of runtime,
// but using previous version of the Node code transform in the plugin
// see: https://github.com/rixo/svelte-hmr/issues/27
/* harmony default export */ const proxy_adapter_dom = (adapter);


/***/ }),

/***/ "./node_modules/.pnpm/@iconify+svelte@3.1.3_svelte@3.50.1/node_modules/@iconify/svelte/dist/Icon.svelte":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@iconify+svelte@3.1.3_svelte@3.50.1/node_modules/@iconify/svelte/dist/Icon.svelte + 1 modules ***!
  \**************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* binding */ Icon_svelte)
});

// UNUSED EXPORTS: _api, addAPIProvider, addCollection, addIcon, buildIcon, calculateSize, disableCache, enableCache, getIcon, iconExists, listIcons, loadIcon, loadIcons, replaceIDs

// EXTERNAL MODULE: ./node_modules/.pnpm/svelte@3.50.1/node_modules/svelte/internal/index.mjs
var internal = __webpack_require__("./node_modules/.pnpm/svelte@3.50.1/node_modules/svelte/internal/index.mjs");
;// CONCATENATED MODULE: ./node_modules/.pnpm/@iconify+svelte@3.1.3_svelte@3.50.1/node_modules/@iconify/svelte/dist/functions.mjs
const matchIconName = /^[a-z0-9]+(-[a-z0-9]+)*$/;
const stringToIcon = (value, validate, allowSimpleName, provider = "") => {
  const colonSeparated = value.split(":");
  if (value.slice(0, 1) === "@") {
    if (colonSeparated.length < 2 || colonSeparated.length > 3) {
      return null;
    }
    provider = colonSeparated.shift().slice(1);
  }
  if (colonSeparated.length > 3 || !colonSeparated.length) {
    return null;
  }
  if (colonSeparated.length > 1) {
    const name2 = colonSeparated.pop();
    const prefix = colonSeparated.pop();
    const result = {
      // Allow provider without '@': "provider:prefix:name"
      provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,
      prefix,
      name: name2
    };
    return validate && !validateIconName(result) ? null : result;
  }
  const name = colonSeparated[0];
  const dashSeparated = name.split("-");
  if (dashSeparated.length > 1) {
    const result = {
      provider,
      prefix: dashSeparated.shift(),
      name: dashSeparated.join("-")
    };
    return validate && !validateIconName(result) ? null : result;
  }
  if (allowSimpleName && provider === "") {
    const result = {
      provider,
      prefix: "",
      name
    };
    return validate && !validateIconName(result, allowSimpleName) ? null : result;
  }
  return null;
};
const validateIconName = (icon, allowSimpleName) => {
  if (!icon) {
    return false;
  }
  return !!((icon.provider === "" || icon.provider.match(matchIconName)) && (allowSimpleName && icon.prefix === "" || icon.prefix.match(matchIconName)) && icon.name.match(matchIconName));
};

const defaultIconDimensions = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
);
const defaultIconTransformations = Object.freeze({
  rotate: 0,
  vFlip: false,
  hFlip: false
});
const defaultIconProps = Object.freeze({
  ...defaultIconDimensions,
  ...defaultIconTransformations
});
const defaultExtendedIconProps = Object.freeze({
  ...defaultIconProps,
  body: "",
  hidden: false
});

function mergeIconTransformations(obj1, obj2) {
  const result = {};
  if (!obj1.hFlip !== !obj2.hFlip) {
    result.hFlip = true;
  }
  if (!obj1.vFlip !== !obj2.vFlip) {
    result.vFlip = true;
  }
  const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;
  if (rotate) {
    result.rotate = rotate;
  }
  return result;
}

function mergeIconData(parent, child) {
  const result = mergeIconTransformations(parent, child);
  for (const key in defaultExtendedIconProps) {
    if (key in defaultIconTransformations) {
      if (key in parent && !(key in result)) {
        result[key] = defaultIconTransformations[key];
      }
    } else if (key in child) {
      result[key] = child[key];
    } else if (key in parent) {
      result[key] = parent[key];
    }
  }
  return result;
}

function getIconsTree(data, names) {
  const icons = data.icons;
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  const resolved = /* @__PURE__ */ Object.create(null);
  function resolve(name) {
    if (icons[name]) {
      return resolved[name] = [];
    }
    if (!(name in resolved)) {
      resolved[name] = null;
      const parent = aliases[name] && aliases[name].parent;
      const value = parent && resolve(parent);
      if (value) {
        resolved[name] = [parent].concat(value);
      }
    }
    return resolved[name];
  }
  (names || Object.keys(icons).concat(Object.keys(aliases))).forEach(resolve);
  return resolved;
}

function internalGetIconData(data, name, tree) {
  const icons = data.icons;
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  let currentProps = {};
  function parse(name2) {
    currentProps = mergeIconData(
      icons[name2] || aliases[name2],
      currentProps
    );
  }
  parse(name);
  tree.forEach(parse);
  return mergeIconData(data, currentProps);
}

function parseIconSet(data, callback) {
  const names = [];
  if (typeof data !== "object" || typeof data.icons !== "object") {
    return names;
  }
  if (data.not_found instanceof Array) {
    data.not_found.forEach((name) => {
      callback(name, null);
      names.push(name);
    });
  }
  const tree = getIconsTree(data);
  for (const name in tree) {
    const item = tree[name];
    if (item) {
      callback(name, internalGetIconData(data, name, item));
      names.push(name);
    }
  }
  return names;
}

const optionalPropertyDefaults = {
  provider: "",
  aliases: {},
  not_found: {},
  ...defaultIconDimensions
};
function checkOptionalProps(item, defaults) {
  for (const prop in defaults) {
    if (prop in item && typeof item[prop] !== typeof defaults[prop]) {
      return false;
    }
  }
  return true;
}
function quicklyValidateIconSet(obj) {
  if (typeof obj !== "object" || obj === null) {
    return null;
  }
  const data = obj;
  if (typeof data.prefix !== "string" || !obj.icons || typeof obj.icons !== "object") {
    return null;
  }
  if (!checkOptionalProps(obj, optionalPropertyDefaults)) {
    return null;
  }
  const icons = data.icons;
  for (const name in icons) {
    const icon = icons[name];
    if (!name.match(matchIconName) || typeof icon.body !== "string" || !checkOptionalProps(
      icon,
      defaultExtendedIconProps
    )) {
      return null;
    }
  }
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  for (const name in aliases) {
    const icon = aliases[name];
    const parent = icon.parent;
    if (!name.match(matchIconName) || typeof parent !== "string" || !icons[parent] && !aliases[parent] || !checkOptionalProps(
      icon,
      defaultExtendedIconProps
    )) {
      return null;
    }
  }
  return data;
}

const dataStorage = /* @__PURE__ */ Object.create(null);
function newStorage(provider, prefix) {
  return {
    provider,
    prefix,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function getStorage(provider, prefix) {
  const providerStorage = dataStorage[provider] || (dataStorage[provider] = /* @__PURE__ */ Object.create(null));
  return providerStorage[prefix] || (providerStorage[prefix] = newStorage(provider, prefix));
}
function addIconSet(storage, data) {
  if (!quicklyValidateIconSet(data)) {
    return [];
  }
  return parseIconSet(data, (name, icon) => {
    if (icon) {
      storage.icons[name] = icon;
    } else {
      storage.missing.add(name);
    }
  });
}
function addIconToStorage(storage, name, icon) {
  try {
    if (typeof icon.body === "string") {
      storage.icons[name] = { ...icon };
      return true;
    }
  } catch (err) {
  }
  return false;
}
function listIcons(provider, prefix) {
  let allIcons = [];
  const providers = typeof provider === "string" ? [provider] : Object.keys(dataStorage);
  providers.forEach((provider2) => {
    const prefixes = typeof provider2 === "string" && typeof prefix === "string" ? [prefix] : Object.keys(dataStorage[provider2] || {});
    prefixes.forEach((prefix2) => {
      const storage = getStorage(provider2, prefix2);
      allIcons = allIcons.concat(
        Object.keys(storage.icons).map(
          (name) => (provider2 !== "" ? "@" + provider2 + ":" : "") + prefix2 + ":" + name
        )
      );
    });
  });
  return allIcons;
}

let simpleNames = false;
function allowSimpleNames(allow) {
  if (typeof allow === "boolean") {
    simpleNames = allow;
  }
  return simpleNames;
}
function getIconData(name) {
  const icon = typeof name === "string" ? stringToIcon(name, true, simpleNames) : name;
  if (icon) {
    const storage = getStorage(icon.provider, icon.prefix);
    const iconName = icon.name;
    return storage.icons[iconName] || (storage.missing.has(iconName) ? null : void 0);
  }
}
function addIcon(name, data) {
  const icon = stringToIcon(name, true, simpleNames);
  if (!icon) {
    return false;
  }
  const storage = getStorage(icon.provider, icon.prefix);
  return addIconToStorage(storage, icon.name, data);
}
function addCollection(data, provider) {
  if (typeof data !== "object") {
    return false;
  }
  if (typeof provider !== "string") {
    provider = data.provider || "";
  }
  if (simpleNames && !provider && !data.prefix) {
    let added = false;
    if (quicklyValidateIconSet(data)) {
      data.prefix = "";
      parseIconSet(data, (name, icon) => {
        if (icon && addIcon(name, icon)) {
          added = true;
        }
      });
    }
    return added;
  }
  const prefix = data.prefix;
  if (!validateIconName({
    provider,
    prefix,
    name: "a"
  })) {
    return false;
  }
  const storage = getStorage(provider, prefix);
  return !!addIconSet(storage, data);
}
function iconExists(name) {
  return !!getIconData(name);
}
function getIcon(name) {
  const result = getIconData(name);
  return result ? {
    ...defaultIconProps,
    ...result
  } : null;
}

const defaultIconSizeCustomisations = Object.freeze({
  width: null,
  height: null
});
const defaultIconCustomisations = Object.freeze({
  // Dimensions
  ...defaultIconSizeCustomisations,
  // Transformations
  ...defaultIconTransformations
});

const unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
const unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function calculateSize(size, ratio, precision) {
  if (ratio === 1) {
    return size;
  }
  precision = precision || 100;
  if (typeof size === "number") {
    return Math.ceil(size * ratio * precision) / precision;
  }
  if (typeof size !== "string") {
    return size;
  }
  const oldParts = size.split(unitsSplit);
  if (oldParts === null || !oldParts.length) {
    return size;
  }
  const newParts = [];
  let code = oldParts.shift();
  let isNumber = unitsTest.test(code);
  while (true) {
    if (isNumber) {
      const num = parseFloat(code);
      if (isNaN(num)) {
        newParts.push(code);
      } else {
        newParts.push(Math.ceil(num * ratio * precision) / precision);
      }
    } else {
      newParts.push(code);
    }
    code = oldParts.shift();
    if (code === void 0) {
      return newParts.join("");
    }
    isNumber = !isNumber;
  }
}

const isUnsetKeyword = (value) => value === "unset" || value === "undefined" || value === "none";
function iconToSVG(icon, customisations) {
  const fullIcon = {
    ...defaultIconProps,
    ...icon
  };
  const fullCustomisations = {
    ...defaultIconCustomisations,
    ...customisations
  };
  const box = {
    left: fullIcon.left,
    top: fullIcon.top,
    width: fullIcon.width,
    height: fullIcon.height
  };
  let body = fullIcon.body;
  [fullIcon, fullCustomisations].forEach((props) => {
    const transformations = [];
    const hFlip = props.hFlip;
    const vFlip = props.vFlip;
    let rotation = props.rotate;
    if (hFlip) {
      if (vFlip) {
        rotation += 2;
      } else {
        transformations.push(
          "translate(" + (box.width + box.left).toString() + " " + (0 - box.top).toString() + ")"
        );
        transformations.push("scale(-1 1)");
        box.top = box.left = 0;
      }
    } else if (vFlip) {
      transformations.push(
        "translate(" + (0 - box.left).toString() + " " + (box.height + box.top).toString() + ")"
      );
      transformations.push("scale(1 -1)");
      box.top = box.left = 0;
    }
    let tempValue;
    if (rotation < 0) {
      rotation -= Math.floor(rotation / 4) * 4;
    }
    rotation = rotation % 4;
    switch (rotation) {
      case 1:
        tempValue = box.height / 2 + box.top;
        transformations.unshift(
          "rotate(90 " + tempValue.toString() + " " + tempValue.toString() + ")"
        );
        break;
      case 2:
        transformations.unshift(
          "rotate(180 " + (box.width / 2 + box.left).toString() + " " + (box.height / 2 + box.top).toString() + ")"
        );
        break;
      case 3:
        tempValue = box.width / 2 + box.left;
        transformations.unshift(
          "rotate(-90 " + tempValue.toString() + " " + tempValue.toString() + ")"
        );
        break;
    }
    if (rotation % 2 === 1) {
      if (box.left !== box.top) {
        tempValue = box.left;
        box.left = box.top;
        box.top = tempValue;
      }
      if (box.width !== box.height) {
        tempValue = box.width;
        box.width = box.height;
        box.height = tempValue;
      }
    }
    if (transformations.length) {
      body = '<g transform="' + transformations.join(" ") + '">' + body + "</g>";
    }
  });
  const customisationsWidth = fullCustomisations.width;
  const customisationsHeight = fullCustomisations.height;
  const boxWidth = box.width;
  const boxHeight = box.height;
  let width;
  let height;
  if (customisationsWidth === null) {
    height = customisationsHeight === null ? "1em" : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
    width = calculateSize(height, boxWidth / boxHeight);
  } else {
    width = customisationsWidth === "auto" ? boxWidth : customisationsWidth;
    height = customisationsHeight === null ? calculateSize(width, boxHeight / boxWidth) : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
  }
  const attributes = {};
  const setAttr = (prop, value) => {
    if (!isUnsetKeyword(value)) {
      attributes[prop] = value.toString();
    }
  };
  setAttr("width", width);
  setAttr("height", height);
  attributes.viewBox = box.left.toString() + " " + box.top.toString() + " " + boxWidth.toString() + " " + boxHeight.toString();
  return {
    attributes,
    body
  };
}

const regex = /\sid="(\S+)"/g;
const randomPrefix = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let counter = 0;
function replaceIDs(body, prefix = randomPrefix) {
  const ids = [];
  let match;
  while (match = regex.exec(body)) {
    ids.push(match[1]);
  }
  if (!ids.length) {
    return body;
  }
  const suffix = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  ids.forEach((id) => {
    const newID = typeof prefix === "function" ? prefix(id) : prefix + (counter++).toString();
    const escapedID = id.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    body = body.replace(
      // Allowed characters before id: [#;"]
      // Allowed characters after id: [)"], .[a-z]
      new RegExp('([#;"])(' + escapedID + ')([")]|\\.[a-z])', "g"),
      "$1" + newID + suffix + "$3"
    );
  });
  body = body.replace(new RegExp(suffix, "g"), "");
  return body;
}

const storage = /* @__PURE__ */ Object.create(null);
function setAPIModule(provider, item) {
  storage[provider] = item;
}
function getAPIModule(provider) {
  return storage[provider] || storage[""];
}

function createAPIConfig(source) {
  let resources;
  if (typeof source.resources === "string") {
    resources = [source.resources];
  } else {
    resources = source.resources;
    if (!(resources instanceof Array) || !resources.length) {
      return null;
    }
  }
  const result = {
    // API hosts
    resources,
    // Root path
    path: source.path || "/",
    // URL length limit
    maxURL: source.maxURL || 500,
    // Timeout before next host is used.
    rotate: source.rotate || 750,
    // Timeout before failing query.
    timeout: source.timeout || 5e3,
    // Randomise default API end point.
    random: source.random === true,
    // Start index
    index: source.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: source.dataAfterTimeout !== false
  };
  return result;
}
const configStorage = /* @__PURE__ */ Object.create(null);
const fallBackAPISources = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
];
const fallBackAPI = [];
while (fallBackAPISources.length > 0) {
  if (fallBackAPISources.length === 1) {
    fallBackAPI.push(fallBackAPISources.shift());
  } else {
    if (Math.random() > 0.5) {
      fallBackAPI.push(fallBackAPISources.shift());
    } else {
      fallBackAPI.push(fallBackAPISources.pop());
    }
  }
}
configStorage[""] = createAPIConfig({
  resources: ["https://api.iconify.design"].concat(fallBackAPI)
});
function addAPIProvider(provider, customConfig) {
  const config = createAPIConfig(customConfig);
  if (config === null) {
    return false;
  }
  configStorage[provider] = config;
  return true;
}
function getAPIConfig(provider) {
  return configStorage[provider];
}
function listAPIProviders() {
  return Object.keys(configStorage);
}

const detectFetch = () => {
  let callback;
  try {
    callback = fetch;
    if (typeof callback === "function") {
      return callback;
    }
  } catch (err) {
  }
};
let fetchModule = detectFetch();
function setFetch(fetch2) {
  fetchModule = fetch2;
}
function getFetch() {
  return fetchModule;
}
function calculateMaxLength(provider, prefix) {
  const config = getAPIConfig(provider);
  if (!config) {
    return 0;
  }
  let result;
  if (!config.maxURL) {
    result = 0;
  } else {
    let maxHostLength = 0;
    config.resources.forEach((item) => {
      const host = item;
      maxHostLength = Math.max(maxHostLength, host.length);
    });
    const url = prefix + ".json?icons=";
    result = config.maxURL - maxHostLength - config.path.length - url.length;
  }
  return result;
}
function shouldAbort(status) {
  return status === 404;
}
const prepare = (provider, prefix, icons) => {
  const results = [];
  const maxLength = calculateMaxLength(provider, prefix);
  const type = "icons";
  let item = {
    type,
    provider,
    prefix,
    icons: []
  };
  let length = 0;
  icons.forEach((name, index) => {
    length += name.length + 1;
    if (length >= maxLength && index > 0) {
      results.push(item);
      item = {
        type,
        provider,
        prefix,
        icons: []
      };
      length = name.length;
    }
    item.icons.push(name);
  });
  results.push(item);
  return results;
};
function getPath(provider) {
  if (typeof provider === "string") {
    const config = getAPIConfig(provider);
    if (config) {
      return config.path;
    }
  }
  return "/";
}
const send = (host, params, callback) => {
  if (!fetchModule) {
    callback("abort", 424);
    return;
  }
  let path = getPath(params.provider);
  switch (params.type) {
    case "icons": {
      const prefix = params.prefix;
      const icons = params.icons;
      const iconsList = icons.join(",");
      const urlParams = new URLSearchParams({
        icons: iconsList
      });
      path += prefix + ".json?" + urlParams.toString();
      break;
    }
    case "custom": {
      const uri = params.uri;
      path += uri.slice(0, 1) === "/" ? uri.slice(1) : uri;
      break;
    }
    default:
      callback("abort", 400);
      return;
  }
  let defaultError = 503;
  fetchModule(host + path).then((response) => {
    const status = response.status;
    if (status !== 200) {
      setTimeout(() => {
        callback(shouldAbort(status) ? "abort" : "next", status);
      });
      return;
    }
    defaultError = 501;
    return response.json();
  }).then((data) => {
    if (typeof data !== "object" || data === null) {
      setTimeout(() => {
        if (data === 404) {
          callback("abort", data);
        } else {
          callback("next", defaultError);
        }
      });
      return;
    }
    setTimeout(() => {
      callback("success", data);
    });
  }).catch(() => {
    callback("next", defaultError);
  });
};
const fetchAPIModule = {
  prepare,
  send
};

function sortIcons(icons) {
  const result = {
    loaded: [],
    missing: [],
    pending: []
  };
  const storage = /* @__PURE__ */ Object.create(null);
  icons.sort((a, b) => {
    if (a.provider !== b.provider) {
      return a.provider.localeCompare(b.provider);
    }
    if (a.prefix !== b.prefix) {
      return a.prefix.localeCompare(b.prefix);
    }
    return a.name.localeCompare(b.name);
  });
  let lastIcon = {
    provider: "",
    prefix: "",
    name: ""
  };
  icons.forEach((icon) => {
    if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) {
      return;
    }
    lastIcon = icon;
    const provider = icon.provider;
    const prefix = icon.prefix;
    const name = icon.name;
    const providerStorage = storage[provider] || (storage[provider] = /* @__PURE__ */ Object.create(null));
    const localStorage = providerStorage[prefix] || (providerStorage[prefix] = getStorage(provider, prefix));
    let list;
    if (name in localStorage.icons) {
      list = result.loaded;
    } else if (prefix === "" || localStorage.missing.has(name)) {
      list = result.missing;
    } else {
      list = result.pending;
    }
    const item = {
      provider,
      prefix,
      name
    };
    list.push(item);
  });
  return result;
}

function removeCallback(storages, id) {
  storages.forEach((storage) => {
    const items = storage.loaderCallbacks;
    if (items) {
      storage.loaderCallbacks = items.filter((row) => row.id !== id);
    }
  });
}
function updateCallbacks(storage) {
  if (!storage.pendingCallbacksFlag) {
    storage.pendingCallbacksFlag = true;
    setTimeout(() => {
      storage.pendingCallbacksFlag = false;
      const items = storage.loaderCallbacks ? storage.loaderCallbacks.slice(0) : [];
      if (!items.length) {
        return;
      }
      let hasPending = false;
      const provider = storage.provider;
      const prefix = storage.prefix;
      items.forEach((item) => {
        const icons = item.icons;
        const oldLength = icons.pending.length;
        icons.pending = icons.pending.filter((icon) => {
          if (icon.prefix !== prefix) {
            return true;
          }
          const name = icon.name;
          if (storage.icons[name]) {
            icons.loaded.push({
              provider,
              prefix,
              name
            });
          } else if (storage.missing.has(name)) {
            icons.missing.push({
              provider,
              prefix,
              name
            });
          } else {
            hasPending = true;
            return true;
          }
          return false;
        });
        if (icons.pending.length !== oldLength) {
          if (!hasPending) {
            removeCallback([storage], item.id);
          }
          item.callback(
            icons.loaded.slice(0),
            icons.missing.slice(0),
            icons.pending.slice(0),
            item.abort
          );
        }
      });
    });
  }
}
let idCounter = 0;
function storeCallback(callback, icons, pendingSources) {
  const id = idCounter++;
  const abort = removeCallback.bind(null, pendingSources, id);
  if (!icons.pending.length) {
    return abort;
  }
  const item = {
    id,
    icons,
    callback,
    abort
  };
  pendingSources.forEach((storage) => {
    (storage.loaderCallbacks || (storage.loaderCallbacks = [])).push(item);
  });
  return abort;
}

function listToIcons(list, validate = true, simpleNames = false) {
  const result = [];
  list.forEach((item) => {
    const icon = typeof item === "string" ? stringToIcon(item, validate, simpleNames) : item;
    if (icon) {
      result.push(icon);
    }
  });
  return result;
}

// src/config.ts
var defaultConfig = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: false,
  dataAfterTimeout: false
};

// src/query.ts
function sendQuery(config, payload, query, done) {
  const resourcesCount = config.resources.length;
  const startIndex = config.random ? Math.floor(Math.random() * resourcesCount) : config.index;
  let resources;
  if (config.random) {
    let list = config.resources.slice(0);
    resources = [];
    while (list.length > 1) {
      const nextIndex = Math.floor(Math.random() * list.length);
      resources.push(list[nextIndex]);
      list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));
    }
    resources = resources.concat(list);
  } else {
    resources = config.resources.slice(startIndex).concat(config.resources.slice(0, startIndex));
  }
  const startTime = Date.now();
  let status = "pending";
  let queriesSent = 0;
  let lastError;
  let timer = null;
  let queue = [];
  let doneCallbacks = [];
  if (typeof done === "function") {
    doneCallbacks.push(done);
  }
  function resetTimer() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function abort() {
    if (status === "pending") {
      status = "aborted";
    }
    resetTimer();
    queue.forEach((item) => {
      if (item.status === "pending") {
        item.status = "aborted";
      }
    });
    queue = [];
  }
  function subscribe(callback, overwrite) {
    if (overwrite) {
      doneCallbacks = [];
    }
    if (typeof callback === "function") {
      doneCallbacks.push(callback);
    }
  }
  function getQueryStatus() {
    return {
      startTime,
      payload,
      status,
      queriesSent,
      queriesPending: queue.length,
      subscribe,
      abort
    };
  }
  function failQuery() {
    status = "failed";
    doneCallbacks.forEach((callback) => {
      callback(void 0, lastError);
    });
  }
  function clearQueue() {
    queue.forEach((item) => {
      if (item.status === "pending") {
        item.status = "aborted";
      }
    });
    queue = [];
  }
  function moduleResponse(item, response, data) {
    const isError = response !== "success";
    queue = queue.filter((queued) => queued !== item);
    switch (status) {
      case "pending":
        break;
      case "failed":
        if (isError || !config.dataAfterTimeout) {
          return;
        }
        break;
      default:
        return;
    }
    if (response === "abort") {
      lastError = data;
      failQuery();
      return;
    }
    if (isError) {
      lastError = data;
      if (!queue.length) {
        if (!resources.length) {
          failQuery();
        } else {
          execNext();
        }
      }
      return;
    }
    resetTimer();
    clearQueue();
    if (!config.random) {
      const index = config.resources.indexOf(item.resource);
      if (index !== -1 && index !== config.index) {
        config.index = index;
      }
    }
    status = "completed";
    doneCallbacks.forEach((callback) => {
      callback(data);
    });
  }
  function execNext() {
    if (status !== "pending") {
      return;
    }
    resetTimer();
    const resource = resources.shift();
    if (resource === void 0) {
      if (queue.length) {
        timer = setTimeout(() => {
          resetTimer();
          if (status === "pending") {
            clearQueue();
            failQuery();
          }
        }, config.timeout);
        return;
      }
      failQuery();
      return;
    }
    const item = {
      status: "pending",
      resource,
      callback: (status2, data) => {
        moduleResponse(item, status2, data);
      }
    };
    queue.push(item);
    queriesSent++;
    timer = setTimeout(execNext, config.rotate);
    query(resource, payload, item.callback);
  }
  setTimeout(execNext);
  return getQueryStatus;
}

// src/index.ts
function initRedundancy(cfg) {
  const config = {
    ...defaultConfig,
    ...cfg
  };
  let queries = [];
  function cleanup() {
    queries = queries.filter((item) => item().status === "pending");
  }
  function query(payload, queryCallback, doneCallback) {
    const query2 = sendQuery(
      config,
      payload,
      queryCallback,
      (data, error) => {
        cleanup();
        if (doneCallback) {
          doneCallback(data, error);
        }
      }
    );
    queries.push(query2);
    return query2;
  }
  function find(callback) {
    return queries.find((value) => {
      return callback(value);
    }) || null;
  }
  const instance = {
    query,
    find,
    setIndex: (index) => {
      config.index = index;
    },
    getIndex: () => config.index,
    cleanup
  };
  return instance;
}

function emptyCallback$1() {
}
const redundancyCache = /* @__PURE__ */ Object.create(null);
function getRedundancyCache(provider) {
  if (!redundancyCache[provider]) {
    const config = getAPIConfig(provider);
    if (!config) {
      return;
    }
    const redundancy = initRedundancy(config);
    const cachedReundancy = {
      config,
      redundancy
    };
    redundancyCache[provider] = cachedReundancy;
  }
  return redundancyCache[provider];
}
function sendAPIQuery(target, query, callback) {
  let redundancy;
  let send;
  if (typeof target === "string") {
    const api = getAPIModule(target);
    if (!api) {
      callback(void 0, 424);
      return emptyCallback$1;
    }
    send = api.send;
    const cached = getRedundancyCache(target);
    if (cached) {
      redundancy = cached.redundancy;
    }
  } else {
    const config = createAPIConfig(target);
    if (config) {
      redundancy = initRedundancy(config);
      const moduleKey = target.resources ? target.resources[0] : "";
      const api = getAPIModule(moduleKey);
      if (api) {
        send = api.send;
      }
    }
  }
  if (!redundancy || !send) {
    callback(void 0, 424);
    return emptyCallback$1;
  }
  return redundancy.query(query, send, callback)().abort;
}

const browserCacheVersion = "iconify2";
const browserCachePrefix = "iconify";
const browserCacheCountKey = browserCachePrefix + "-count";
const browserCacheVersionKey = browserCachePrefix + "-version";
const browserStorageHour = 36e5;
const browserStorageCacheExpiration = 168;

function getStoredItem(func, key) {
  try {
    return func.getItem(key);
  } catch (err) {
  }
}
function setStoredItem(func, key, value) {
  try {
    func.setItem(key, value);
    return true;
  } catch (err) {
  }
}
function removeStoredItem(func, key) {
  try {
    func.removeItem(key);
  } catch (err) {
  }
}

function setBrowserStorageItemsCount(storage, value) {
  return setStoredItem(storage, browserCacheCountKey, value.toString());
}
function getBrowserStorageItemsCount(storage) {
  return parseInt(getStoredItem(storage, browserCacheCountKey)) || 0;
}

const browserStorageConfig = {
  local: true,
  session: true
};
const browserStorageEmptyItems = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
let browserStorageStatus = false;
function setBrowserStorageStatus(status) {
  browserStorageStatus = status;
}

let _window = typeof window === "undefined" ? {} : window;
function getBrowserStorage(key) {
  const attr = key + "Storage";
  try {
    if (_window && _window[attr] && typeof _window[attr].length === "number") {
      return _window[attr];
    }
  } catch (err) {
  }
  browserStorageConfig[key] = false;
}

function iterateBrowserStorage(key, callback) {
  const func = getBrowserStorage(key);
  if (!func) {
    return;
  }
  const version = getStoredItem(func, browserCacheVersionKey);
  if (version !== browserCacheVersion) {
    if (version) {
      const total2 = getBrowserStorageItemsCount(func);
      for (let i = 0; i < total2; i++) {
        removeStoredItem(func, browserCachePrefix + i.toString());
      }
    }
    setStoredItem(func, browserCacheVersionKey, browserCacheVersion);
    setBrowserStorageItemsCount(func, 0);
    return;
  }
  const minTime = Math.floor(Date.now() / browserStorageHour) - browserStorageCacheExpiration;
  const parseItem = (index) => {
    const name = browserCachePrefix + index.toString();
    const item = getStoredItem(func, name);
    if (typeof item !== "string") {
      return;
    }
    try {
      const data = JSON.parse(item);
      if (typeof data === "object" && typeof data.cached === "number" && data.cached > minTime && typeof data.provider === "string" && typeof data.data === "object" && typeof data.data.prefix === "string" && // Valid item: run callback
      callback(data, index)) {
        return true;
      }
    } catch (err) {
    }
    removeStoredItem(func, name);
  };
  let total = getBrowserStorageItemsCount(func);
  for (let i = total - 1; i >= 0; i--) {
    if (!parseItem(i)) {
      if (i === total - 1) {
        total--;
        setBrowserStorageItemsCount(func, total);
      } else {
        browserStorageEmptyItems[key].add(i);
      }
    }
  }
}

function initBrowserStorage() {
  if (browserStorageStatus) {
    return;
  }
  setBrowserStorageStatus(true);
  for (const key in browserStorageConfig) {
    iterateBrowserStorage(key, (item) => {
      const iconSet = item.data;
      const provider = item.provider;
      const prefix = iconSet.prefix;
      const storage = getStorage(
        provider,
        prefix
      );
      if (!addIconSet(storage, iconSet).length) {
        return false;
      }
      const lastModified = iconSet.lastModified || -1;
      storage.lastModifiedCached = storage.lastModifiedCached ? Math.min(storage.lastModifiedCached, lastModified) : lastModified;
      return true;
    });
  }
}

function updateLastModified(storage, lastModified) {
  const lastValue = storage.lastModifiedCached;
  if (
    // Matches or newer
    lastValue && lastValue >= lastModified
  ) {
    return lastValue === lastModified;
  }
  storage.lastModifiedCached = lastModified;
  if (lastValue) {
    for (const key in browserStorageConfig) {
      iterateBrowserStorage(key, (item) => {
        const iconSet = item.data;
        return item.provider !== storage.provider || iconSet.prefix !== storage.prefix || iconSet.lastModified === lastModified;
      });
    }
  }
  return true;
}
function storeInBrowserStorage(storage, data) {
  if (!browserStorageStatus) {
    initBrowserStorage();
  }
  function store(key) {
    let func;
    if (!browserStorageConfig[key] || !(func = getBrowserStorage(key))) {
      return;
    }
    const set = browserStorageEmptyItems[key];
    let index;
    if (set.size) {
      set.delete(index = Array.from(set).shift());
    } else {
      index = getBrowserStorageItemsCount(func);
      if (!setBrowserStorageItemsCount(func, index + 1)) {
        return;
      }
    }
    const item = {
      cached: Math.floor(Date.now() / browserStorageHour),
      provider: storage.provider,
      data
    };
    return setStoredItem(
      func,
      browserCachePrefix + index.toString(),
      JSON.stringify(item)
    );
  }
  if (data.lastModified && !updateLastModified(storage, data.lastModified)) {
    return;
  }
  if (!Object.keys(data.icons).length) {
    return;
  }
  if (data.not_found) {
    data = Object.assign({}, data);
    delete data.not_found;
  }
  if (!store("local")) {
    store("session");
  }
}

function emptyCallback() {
}
function loadedNewIcons(storage) {
  if (!storage.iconsLoaderFlag) {
    storage.iconsLoaderFlag = true;
    setTimeout(() => {
      storage.iconsLoaderFlag = false;
      updateCallbacks(storage);
    });
  }
}
function loadNewIcons(storage, icons) {
  if (!storage.iconsToLoad) {
    storage.iconsToLoad = icons;
  } else {
    storage.iconsToLoad = storage.iconsToLoad.concat(icons).sort();
  }
  if (!storage.iconsQueueFlag) {
    storage.iconsQueueFlag = true;
    setTimeout(() => {
      storage.iconsQueueFlag = false;
      const { provider, prefix } = storage;
      const icons2 = storage.iconsToLoad;
      delete storage.iconsToLoad;
      let api;
      if (!icons2 || !(api = getAPIModule(provider))) {
        return;
      }
      const params = api.prepare(provider, prefix, icons2);
      params.forEach((item) => {
        sendAPIQuery(provider, item, (data) => {
          if (typeof data !== "object") {
            item.icons.forEach((name) => {
              storage.missing.add(name);
            });
          } else {
            try {
              const parsed = addIconSet(
                storage,
                data
              );
              if (!parsed.length) {
                return;
              }
              const pending = storage.pendingIcons;
              if (pending) {
                parsed.forEach((name) => {
                  pending.delete(name);
                });
              }
              storeInBrowserStorage(storage, data);
            } catch (err) {
              console.error(err);
            }
          }
          loadedNewIcons(storage);
        });
      });
    });
  }
}
const loadIcons = (icons, callback) => {
  const cleanedIcons = listToIcons(icons, true, allowSimpleNames());
  const sortedIcons = sortIcons(cleanedIcons);
  if (!sortedIcons.pending.length) {
    let callCallback = true;
    if (callback) {
      setTimeout(() => {
        if (callCallback) {
          callback(
            sortedIcons.loaded,
            sortedIcons.missing,
            sortedIcons.pending,
            emptyCallback
          );
        }
      });
    }
    return () => {
      callCallback = false;
    };
  }
  const newIcons = /* @__PURE__ */ Object.create(null);
  const sources = [];
  let lastProvider, lastPrefix;
  sortedIcons.pending.forEach((icon) => {
    const { provider, prefix } = icon;
    if (prefix === lastPrefix && provider === lastProvider) {
      return;
    }
    lastProvider = provider;
    lastPrefix = prefix;
    sources.push(getStorage(provider, prefix));
    const providerNewIcons = newIcons[provider] || (newIcons[provider] = /* @__PURE__ */ Object.create(null));
    if (!providerNewIcons[prefix]) {
      providerNewIcons[prefix] = [];
    }
  });
  sortedIcons.pending.forEach((icon) => {
    const { provider, prefix, name } = icon;
    const storage = getStorage(provider, prefix);
    const pendingQueue = storage.pendingIcons || (storage.pendingIcons = /* @__PURE__ */ new Set());
    if (!pendingQueue.has(name)) {
      pendingQueue.add(name);
      newIcons[provider][prefix].push(name);
    }
  });
  sources.forEach((storage) => {
    const { provider, prefix } = storage;
    if (newIcons[provider][prefix].length) {
      loadNewIcons(storage, newIcons[provider][prefix]);
    }
  });
  return callback ? storeCallback(callback, sortedIcons, sources) : emptyCallback;
};
const loadIcon = (icon) => {
  return new Promise((fulfill, reject) => {
    const iconObj = typeof icon === "string" ? stringToIcon(icon, true) : icon;
    if (!iconObj) {
      reject(icon);
      return;
    }
    loadIcons([iconObj || icon], (loaded) => {
      if (loaded.length && iconObj) {
        const data = getIconData(iconObj);
        if (data) {
          fulfill({
            ...defaultIconProps,
            ...data
          });
          return;
        }
      }
      reject(icon);
    });
  });
};

function toggleBrowserCache(storage, value) {
  switch (storage) {
    case "local":
    case "session":
      browserStorageConfig[storage] = value;
      break;
    case "all":
      for (const key in browserStorageConfig) {
        browserStorageConfig[key] = value;
      }
      break;
  }
}

function mergeCustomisations(defaults, item) {
  const result = {
    ...defaults
  };
  for (const key in item) {
    const value = item[key];
    const valueType = typeof value;
    if (key in defaultIconSizeCustomisations) {
      if (value === null || value && (valueType === "string" || valueType === "number")) {
        result[key] = value;
      }
    } else if (valueType === typeof result[key]) {
      result[key] = key === "rotate" ? value % 4 : value;
    }
  }
  return result;
}

const separator = /[\s,]+/;
function flipFromString(custom, flip) {
  flip.split(separator).forEach((str) => {
    const value = str.trim();
    switch (value) {
      case "horizontal":
        custom.hFlip = true;
        break;
      case "vertical":
        custom.vFlip = true;
        break;
    }
  });
}

function rotateFromString(value, defaultValue = 0) {
  const units = value.replace(/^-?[0-9.]*/, "");
  function cleanup(value2) {
    while (value2 < 0) {
      value2 += 4;
    }
    return value2 % 4;
  }
  if (units === "") {
    const num = parseInt(value);
    return isNaN(num) ? 0 : cleanup(num);
  } else if (units !== value) {
    let split = 0;
    switch (units) {
      case "%":
        split = 25;
        break;
      case "deg":
        split = 90;
    }
    if (split) {
      let num = parseFloat(value.slice(0, value.length - units.length));
      if (isNaN(num)) {
        return 0;
      }
      num = num / split;
      return num % 1 === 0 ? cleanup(num) : 0;
    }
  }
  return defaultValue;
}

function iconToHTML(body, attributes) {
  let renderAttribsHTML = body.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const attr in attributes) {
    renderAttribsHTML += " " + attr + '="' + attributes[attr] + '"';
  }
  return '<svg xmlns="http://www.w3.org/2000/svg"' + renderAttribsHTML + ">" + body + "</svg>";
}

function encodeSVGforURL(svg) {
  return svg.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function svgToData(svg) {
  return "data:image/svg+xml," + encodeSVGforURL(svg);
}
function svgToURL(svg) {
  return 'url("' + svgToData(svg) + '")';
}

const defaultExtendedIconCustomisations = {
    ...defaultIconCustomisations,
    inline: false,
};

/**
 * Default SVG attributes
 */
const svgDefaults = {
    'xmlns': 'http://www.w3.org/2000/svg',
    'xmlns:xlink': 'http://www.w3.org/1999/xlink',
    'aria-hidden': true,
    'role': 'img',
};
/**
 * Style modes
 */
const commonProps = {
    display: 'inline-block',
};
const monotoneProps = {
    'background-color': 'currentColor',
};
const coloredProps = {
    'background-color': 'transparent',
};
// Dynamically add common props to variables above
const propsToAdd = {
    image: 'var(--svg)',
    repeat: 'no-repeat',
    size: '100% 100%',
};
const propsToAddTo = {
    '-webkit-mask': monotoneProps,
    'mask': monotoneProps,
    'background': coloredProps,
};
for (const prefix in propsToAddTo) {
    const list = propsToAddTo[prefix];
    for (const prop in propsToAdd) {
        list[prefix + '-' + prop] = propsToAdd[prop];
    }
}
/**
 * Fix size: add 'px' to numbers
 */
function fixSize(value) {
    return value + (value.match(/^[-0-9.]+$/) ? 'px' : '');
}
/**
 * Generate icon from properties
 */
function render(
// Icon must be validated before calling this function
icon, 
// Properties
props) {
    const customisations = mergeCustomisations(defaultExtendedIconCustomisations, props);
    // Check mode
    const mode = props.mode || 'svg';
    const componentProps = (mode === 'svg' ? { ...svgDefaults } : {});
    if (icon.body.indexOf('xlink:') === -1) {
        delete componentProps['xmlns:xlink'];
    }
    // Create style if missing
    let style = typeof props.style === 'string' ? props.style : '';
    // Get element properties
    for (let key in props) {
        const value = props[key];
        if (value === void 0) {
            continue;
        }
        switch (key) {
            // Properties to ignore
            case 'icon':
            case 'style':
            case 'onLoad':
            case 'mode':
                break;
            // Boolean attributes
            case 'inline':
            case 'hFlip':
            case 'vFlip':
                customisations[key] =
                    value === true || value === 'true' || value === 1;
                break;
            // Flip as string: 'horizontal,vertical'
            case 'flip':
                if (typeof value === 'string') {
                    flipFromString(customisations, value);
                }
                break;
            // Color: copy to style, add extra ';' in case style is missing it
            case 'color':
                style =
                    style +
                        (style.length > 0 && style.trim().slice(-1) !== ';'
                            ? ';'
                            : '') +
                        'color: ' +
                        value +
                        '; ';
                break;
            // Rotation as string
            case 'rotate':
                if (typeof value === 'string') {
                    customisations[key] = rotateFromString(value);
                }
                else if (typeof value === 'number') {
                    customisations[key] = value;
                }
                break;
            // Remove aria-hidden
            case 'ariaHidden':
            case 'aria-hidden':
                if (value !== true && value !== 'true') {
                    delete componentProps['aria-hidden'];
                }
                break;
            default:
                if (key.slice(0, 3) === 'on:') {
                    // Svelte event
                    break;
                }
                // Copy missing property if it does not exist in customisations
                if (defaultExtendedIconCustomisations[key] === void 0) {
                    componentProps[key] = value;
                }
        }
    }
    // Generate icon
    const item = iconToSVG(icon, customisations);
    const renderAttribs = item.attributes;
    // Inline display
    if (customisations.inline) {
        // Style overrides it
        style = 'vertical-align: -0.125em; ' + style;
    }
    if (mode === 'svg') {
        // Add icon stuff
        Object.assign(componentProps, renderAttribs);
        // Style
        if (style !== '') {
            componentProps.style = style;
        }
        // Counter for ids based on "id" property to render icons consistently on server and client
        let localCounter = 0;
        let id = props.id;
        if (typeof id === 'string') {
            // Convert '-' to '_' to avoid errors in animations
            id = id.replace(/-/g, '_');
        }
        // Generate HTML
        return {
            svg: true,
            attributes: componentProps,
            body: replaceIDs(item.body, id ? () => id + 'ID' + localCounter++ : 'iconifySvelte'),
        };
    }
    // Render <span> with style
    const { body, width, height } = icon;
    const useMask = mode === 'mask' ||
        (mode === 'bg' ? false : body.indexOf('currentColor') !== -1);
    // Generate SVG
    const html = iconToHTML(body, {
        ...renderAttribs,
        width: width + '',
        height: height + '',
    });
    // Generate style
    const url = svgToURL(html);
    const styles = {
        '--svg': url,
    };
    const size = (prop) => {
        const value = renderAttribs[prop];
        if (value) {
            styles[prop] = fixSize(value);
        }
    };
    size('width');
    size('height');
    Object.assign(styles, commonProps, useMask ? monotoneProps : coloredProps);
    let customStyle = '';
    for (const key in styles) {
        customStyle += key + ': ' + styles[key] + ';';
    }
    componentProps.style = customStyle + style;
    return {
        svg: false,
        attributes: componentProps,
    };
}

/**
 * Enable cache
 */
function enableCache(storage) {
    toggleBrowserCache(storage, true);
}
/**
 * Disable cache
 */
function disableCache(storage) {
    toggleBrowserCache(storage, false);
}
/**
 * Initialise stuff
 */
// Enable short names
allowSimpleNames(true);
// Set API module
setAPIModule('', fetchAPIModule);
/**
 * Browser stuff
 */
if (typeof document !== 'undefined' && typeof window !== 'undefined') {
    // Set cache and load existing cache
    initBrowserStorage();
    const _window = window;
    // Load icons from global "IconifyPreload"
    if (_window.IconifyPreload !== void 0) {
        const preload = _window.IconifyPreload;
        const err = 'Invalid IconifyPreload syntax.';
        if (typeof preload === 'object' && preload !== null) {
            (preload instanceof Array ? preload : [preload]).forEach((item) => {
                try {
                    if (
                    // Check if item is an object and not null/array
                    typeof item !== 'object' ||
                        item === null ||
                        item instanceof Array ||
                        // Check for 'icons' and 'prefix'
                        typeof item.icons !== 'object' ||
                        typeof item.prefix !== 'string' ||
                        // Add icon set
                        !addCollection(item)) {
                        console.error(err);
                    }
                }
                catch (e) {
                    console.error(err);
                }
            });
        }
    }
    // Set API from global "IconifyProviders"
    if (_window.IconifyProviders !== void 0) {
        const providers = _window.IconifyProviders;
        if (typeof providers === 'object' && providers !== null) {
            for (let key in providers) {
                const err = 'IconifyProviders[' + key + '] is invalid.';
                try {
                    const value = providers[key];
                    if (typeof value !== 'object' ||
                        !value ||
                        value.resources === void 0) {
                        continue;
                    }
                    if (!addAPIProvider(key, value)) {
                        console.error(err);
                    }
                }
                catch (e) {
                    console.error(err);
                }
            }
        }
    }
}
/**
 * Check if component needs to be updated
 */
function checkIconState(icon, state, mounted, callback, onload) {
    // Abort loading icon
    function abortLoading() {
        if (state.loading) {
            state.loading.abort();
            state.loading = null;
        }
    }
    // Icon is an object
    if (typeof icon === 'object' &&
        icon !== null &&
        typeof icon.body === 'string') {
        // Stop loading
        state.name = '';
        abortLoading();
        return { data: { ...defaultIconProps, ...icon } };
    }
    // Invalid icon?
    let iconName;
    if (typeof icon !== 'string' ||
        (iconName = stringToIcon(icon, false, true)) === null) {
        abortLoading();
        return null;
    }
    // Load icon
    const data = getIconData(iconName);
    if (!data) {
        // Icon data is not available
        // Do not load icon until component is mounted
        if (mounted && (!state.loading || state.loading.name !== icon)) {
            // New icon to load
            abortLoading();
            state.name = '';
            state.loading = {
                name: icon,
                abort: loadIcons([iconName], callback),
            };
        }
        return null;
    }
    // Icon data is available
    abortLoading();
    if (state.name !== icon) {
        state.name = icon;
        if (onload && !state.destroyed) {
            onload(icon);
        }
    }
    // Add classes
    const classes = ['iconify'];
    if (iconName.prefix !== '') {
        classes.push('iconify--' + iconName.prefix);
    }
    if (iconName.provider !== '') {
        classes.push('iconify--' + iconName.provider);
    }
    return { data, classes };
}
/**
 * Generate icon
 */
function generateIcon(icon, props) {
    return icon
        ? render({
            ...defaultIconProps,
            ...icon,
        }, props)
        : null;
}
/**
 * Internal API
 */
const _api = {
    getAPIConfig,
    setAPIModule,
    sendAPIQuery,
    setFetch,
    getFetch,
    listAPIProviders,
};



// EXTERNAL MODULE: ./node_modules/.pnpm/svelte@3.50.1/node_modules/svelte/index.mjs
var svelte = __webpack_require__("./node_modules/.pnpm/svelte@3.50.1/node_modules/svelte/index.mjs");
// EXTERNAL MODULE: ./node_modules/.pnpm/svelte-loader@3.1.3_svelte@3.50.1/node_modules/svelte-loader/lib/hot-api.js + 4 modules
var hot_api = __webpack_require__("./node_modules/.pnpm/svelte-loader@3.1.3_svelte@3.50.1/node_modules/svelte-loader/lib/hot-api.js");
// EXTERNAL MODULE: ./node_modules/.pnpm/svelte-hmr@0.14.12_svelte@3.50.1/node_modules/svelte-hmr/runtime/proxy-adapter-dom.js + 1 modules
var proxy_adapter_dom = __webpack_require__("./node_modules/.pnpm/svelte-hmr@0.14.12_svelte@3.50.1/node_modules/svelte-hmr/runtime/proxy-adapter-dom.js");
;// CONCATENATED MODULE: ./node_modules/.pnpm/@iconify+svelte@3.1.3_svelte@3.50.1/node_modules/@iconify/svelte/dist/Icon.svelte
/* module decorator */ module = __webpack_require__.hmd(module);
/* node_modules/.pnpm/@iconify+svelte@3.1.3_svelte@3.50.1/node_modules/@iconify/svelte/dist/Icon.svelte generated by Svelte v3.50.1 */






const file = "node_modules/.pnpm/@iconify+svelte@3.1.3_svelte@3.50.1/node_modules/@iconify/svelte/dist/Icon.svelte";

// (108:0) {#if data}
function create_if_block(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*data*/ ctx[0].svg) return create_if_block_1;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = (0,internal.empty)();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			(0,internal.insert_dev)(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) (0,internal.detach_dev)(if_block_anchor);
		}
	};

	(0,internal.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(108:0) {#if data}",
		ctx
	});

	return block;
}

// (113:1) {:else}
function create_else_block(ctx) {
	let span;
	let span_levels = [/*data*/ ctx[0].attributes];
	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = (0,internal.assign)(span_data, span_levels[i]);
	}

	const block = {
		c: function create() {
			span = (0,internal.element)("span");
			(0,internal.set_attributes)(span, span_data);
			(0,internal.add_location)(span, file, 113, 2, 2001);
		},
		m: function mount(target, anchor) {
			(0,internal.insert_dev)(target, span, anchor);
		},
		p: function update(ctx, dirty) {
			(0,internal.set_attributes)(span, span_data = (0,internal.get_spread_update)(span_levels, [dirty & /*data*/ 1 && /*data*/ ctx[0].attributes]));
		},
		d: function destroy(detaching) {
			if (detaching) (0,internal.detach_dev)(span);
		}
	};

	(0,internal.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(113:1) {:else}",
		ctx
	});

	return block;
}

// (109:1) {#if data.svg}
function create_if_block_1(ctx) {
	let svg;
	let raw_value = /*data*/ ctx[0].body + "";
	let svg_levels = [/*data*/ ctx[0].attributes];
	let svg_data = {};

	for (let i = 0; i < svg_levels.length; i += 1) {
		svg_data = (0,internal.assign)(svg_data, svg_levels[i]);
	}

	const block = {
		c: function create() {
			svg = (0,internal.svg_element)("svg");
			(0,internal.set_svg_attributes)(svg, svg_data);
			(0,internal.add_location)(svg, file, 109, 2, 1933);
		},
		m: function mount(target, anchor) {
			(0,internal.insert_dev)(target, svg, anchor);
			svg.innerHTML = raw_value;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*data*/ 1 && raw_value !== (raw_value = /*data*/ ctx[0].body + "")) svg.innerHTML = raw_value;;
			(0,internal.set_svg_attributes)(svg, svg_data = (0,internal.get_spread_update)(svg_levels, [dirty & /*data*/ 1 && /*data*/ ctx[0].attributes]));
		},
		d: function destroy(detaching) {
			if (detaching) (0,internal.detach_dev)(svg);
		}
	};

	(0,internal.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(109:1) {#if data.svg}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let if_block_anchor;
	let if_block = /*data*/ ctx[0] && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = (0,internal.empty)();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			(0,internal.insert_dev)(target, if_block_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (/*data*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: internal.noop,
		o: internal.noop,
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) (0,internal.detach_dev)(if_block_anchor);
		}
	};

	(0,internal.dispatch_dev)("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	(0,internal.validate_slots)('Icon', slots, []);

	const state = {
		// Last icon name
		name: '',
		// Loading status
		loading: null,
		// Destroyed status
		destroyed: false
	};

	// Mounted status
	let mounted = false;

	// Callback counter
	let counter = 0;

	// Generated data
	let data;

	const onLoad = icon => {
		// Legacy onLoad property
		if (typeof $$props.onLoad === 'function') {
			$$props.onLoad(icon);
		}

		// on:load event
		const dispatch = (0,svelte.createEventDispatcher)();

		dispatch('load', { icon });
	};

	// Increase counter when loaded to force re-calculation of data
	function loaded() {
		$$invalidate(3, counter++, counter);
	}

	// Force re-render
	(0,svelte.onMount)(() => {
		$$invalidate(2, mounted = true);
	});

	// Abort loading when component is destroyed
	(0,svelte.onDestroy)(() => {
		$$invalidate(1, state.destroyed = true, state);

		if (state.loading) {
			state.loading.abort();
			$$invalidate(1, state.loading = null, state);
		}
	});

	$$self.$$set = $$new_props => {
		$$invalidate(6, $$props = (0,internal.assign)((0,internal.assign)({}, $$props), (0,internal.exclude_internal_props)($$new_props)));
	};

	$$self.$capture_state = () => ({
		enableCache: enableCache,
		disableCache: disableCache,
		iconExists: iconExists,
		getIcon: getIcon,
		listIcons: listIcons,
		addIcon: addIcon,
		addCollection: addCollection,
		calculateSize: calculateSize,
		replaceIDs: replaceIDs,
		buildIcon: iconToSVG,
		loadIcons: loadIcons,
		loadIcon: loadIcon,
		addAPIProvider: addAPIProvider,
		_api: _api,
		onMount: svelte.onMount,
		onDestroy: svelte.onDestroy,
		createEventDispatcher: svelte.createEventDispatcher,
		checkIconState: checkIconState,
		generateIcon: generateIcon,
		state,
		mounted,
		counter,
		data,
		onLoad,
		loaded
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(6, $$props = (0,internal.assign)((0,internal.assign)({}, $$props), $$new_props));
		if ('mounted' in $$props) $$invalidate(2, mounted = $$new_props.mounted);
		if ('counter' in $$props) $$invalidate(3, counter = $$new_props.counter);
		if ('data' in $$props) $$invalidate(0, data = $$new_props.data);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		$: {
			counter;
			const iconData = checkIconState($$props.icon, state, mounted, loaded, onLoad);
			$$invalidate(0, data = iconData ? generateIcon(iconData.data, $$props) : null);

			if (data && iconData.classes) {
				// Add classes
				$$invalidate(
					0,
					data.attributes['class'] = (typeof $$props['class'] === 'string'
					? $$props['class'] + ' '
					: '') + iconData.classes.join(' '),
					data
				);
			}
		}
	};

	$$props = (0,internal.exclude_internal_props)($$props);
	return [data, state, mounted, counter];
}

class Icon extends internal.SvelteComponentDev {
	constructor(options) {
		super(options);
		(0,internal.init)(this, options, instance, create_fragment, internal.safe_not_equal, {});

		(0,internal.dispatch_dev)("SvelteRegisterComponent", {
			component: this,
			tagName: "Icon",
			options,
			id: create_fragment.name
		});
	}
}

if (module && module.hot) {}
/* harmony default export */ const Icon_svelte = (Icon);





/***/ }),

/***/ "./node_modules/.pnpm/svelte-loader@3.1.3_svelte@3.50.1/node_modules/svelte-loader/lib/hot-api.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/svelte-loader@3.1.3_svelte@3.50.1/node_modules/svelte-loader/lib/hot-api.js + 4 modules ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

// UNUSED EXPORTS: applyHmr

// EXTERNAL MODULE: ./node_modules/.pnpm/svelte@3.50.1/node_modules/svelte/internal/index.mjs
var internal = __webpack_require__("./node_modules/.pnpm/svelte@3.50.1/node_modules/svelte/internal/index.mjs");
;// CONCATENATED MODULE: ./node_modules/.pnpm/svelte-hmr@0.14.12_svelte@3.50.1/node_modules/svelte-hmr/runtime/svelte-hooks.js
/**
 * Emulates forthcoming HMR hooks in Svelte.
 *
 * All references to private component state ($$) are now isolated in this
 * module.
 */


const captureState = cmp => {
  // sanity check: propper behaviour here is to crash noisily so that
  // user knows that they're looking at something broken
  if (!cmp) {
    throw new Error('Missing component')
  }
  if (!cmp.$$) {
    throw new Error('Invalid component')
  }

  const {
    $$: { callbacks, bound, ctx, props },
  } = cmp

  const state = cmp.$capture_state()

  // capturing current value of props (or we'll recreate the component with the
  // initial prop values, that may have changed -- and would not be reflected in
  // options.props)
  const hmr_props_values = {}
  Object.keys(cmp.$$.props).forEach(prop => {
    hmr_props_values[prop] = ctx[props[prop]]
  })

  return {
    ctx,
    props,
    callbacks,
    bound,
    state,
    hmr_props_values,
  }
}

// remapping all existing bindings (including hmr_future_foo ones) to the
// new version's props indexes, and refresh them with the new value from
// context
const restoreBound = (cmp, restore) => {
  // reverse prop:ctxIndex in $$.props to ctxIndex:prop
  //
  // ctxIndex can be either a regular index in $$.ctx or a hmr_future_ prop
  //
  const propsByIndex = {}
  for (const [name, i] of Object.entries(restore.props)) {
    propsByIndex[i] = name
  }

  // NOTE $$.bound cannot change in the HMR lifetime of a component, because
  //      if bindings changes, that means the parent component has changed,
  //      which means the child (current) component will be wholly recreated
  for (const [oldIndex, updateBinding] of Object.entries(restore.bound)) {
    // can be either regular prop, or future_hmr_ prop
    const propName = propsByIndex[oldIndex]

    // this should never happen if remembering of future props is enabled...
    // in any case, there's nothing we can do about it if we have lost prop
    // name knowledge at this point
    if (propName == null) continue

    // NOTE $$.props[propName] also propagates knowledge of a possible
    //      future prop to the new $$.props (via $$.props being a Proxy)
    const newIndex = cmp.$$.props[propName]
    cmp.$$.bound[newIndex] = updateBinding

    // NOTE if the prop doesn't exist or doesn't exist anymore in the new
    //      version of the component, clearing the binding is the expected
    //      behaviour (since that's what would happen in non HMR code)
    const newValue = cmp.$$.ctx[newIndex]
    updateBinding(newValue)
  }
}

// restoreState
//
// It is too late to restore context at this point because component instance
// function has already been called (and so context has already been read).
// Instead, we rely on setting current_component to the same value it has when
// the component was first rendered -- which fix support for context, and is
// also generally more respectful of normal operation.
//
const restoreState = (cmp, restore) => {
  if (!restore) return

  if (restore.callbacks) {
    cmp.$$.callbacks = restore.callbacks
  }

  if (restore.bound) {
    restoreBound(cmp, restore)
  }

  // props, props.$$slots are restored at component creation (works
  // better -- well, at all actually)
}

const get_current_component_safe = () => {
  // NOTE relying on dynamic bindings (current_component) makes us dependent on
  // bundler config (and apparently it does not work in demo-svelte-nollup)
  try {
    // unfortunately, unlike current_component, get_current_component() can
    // crash in the normal path (when there is really no parent)
    return (0,internal.get_current_component)()
  } catch (err) {
    // ... so we need to consider that this error means that there is no parent
    //
    // that makes us tightly coupled to the error message but, at least, we
    // won't mute an unexpected error, which is quite a horrible thing to do
    if (err.message === 'Function called outside component initialization') {
      // who knows...
      return internal.current_component
    } else {
      throw err
    }
  }
}

const createProxiedComponent = (
  Component,
  initialOptions,
  { allowLiveBinding, onInstance, onMount, onDestroy }
) => {
  let cmp
  let options = initialOptions

  const isCurrent = _cmp => cmp === _cmp

  const assignOptions = (target, anchor, restore, preserveLocalState) => {
    const props = Object.assign({}, options.props)

    // Filtering props to avoid "unexpected prop" warning
    // NOTE this is based on props present in initial options, but it should
    //      always works, because props that are passed from the parent can't
    //      change without a code change to the parent itself -- hence, the
    //      child component will be fully recreated, and initial options should
    //      always represent props that are currnetly passed by the parent
    if (options.props && restore.hmr_props_values) {
      for (const prop of Object.keys(options.props)) {
        if (restore.hmr_props_values.hasOwnProperty(prop)) {
          props[prop] = restore.hmr_props_values[prop]
        }
      }
    }

    if (preserveLocalState && restore.state) {
      if (Array.isArray(preserveLocalState)) {
        // form ['a', 'b'] => preserve only 'a' and 'b'
        props.$$inject = {}
        for (const key of preserveLocalState) {
          props.$$inject[key] = restore.state[key]
        }
      } else {
        props.$$inject = restore.state
      }
    } else {
      delete props.$$inject
    }
    options = Object.assign({}, initialOptions, {
      target,
      anchor,
      props,
      hydrate: false,
    })
  }

  // Preserving knowledge of "future props" -- very hackish version (maybe
  // there should be an option to opt out of this)
  //
  // The use case is bind:something where something doesn't exist yet in the
  // target component, but comes to exist later, after a HMR update.
  //
  // If Svelte can't map a prop in the current version of the component, it
  // will just completely discard it:
  // https://github.com/sveltejs/svelte/blob/1632bca34e4803d6b0e0b0abd652ab5968181860/src/runtime/internal/Component.ts#L46
  //
  const rememberFutureProps = cmp => {
    if (typeof Proxy === 'undefined') return

    cmp.$$.props = new Proxy(cmp.$$.props, {
      get(target, name) {
        if (target[name] === undefined) {
          target[name] = 'hmr_future_' + name
        }
        return target[name]
      },
      set(target, name, value) {
        target[name] = value
      },
    })
  }

  const instrument = targetCmp => {
    const createComponent = (Component, restore, previousCmp) => {
      ;(0,internal.set_current_component)(parentComponent || previousCmp)
      const comp = new Component(options)
      // NOTE must be instrumented before restoreState, because restoring
      // bindings relies on hacked $$.props
      instrument(comp)
      restoreState(comp, restore)
      return comp
    }

    rememberFutureProps(targetCmp)

    targetCmp.$$.on_hmr = []

    // `conservative: true` means we want to be sure that the new component has
    // actually been successfuly created before destroying the old instance.
    // This could be useful for preventing runtime errors in component init to
    // bring down the whole HMR. Unfortunately the implementation bellow is
    // broken (FIXME), but that remains an interesting target for when HMR hooks
    // will actually land in Svelte itself.
    //
    // The goal would be to render an error inplace in case of error, to avoid
    // losing the navigation stack (especially annoying in native, that is not
    // based on URL navigation, so we lose the current page on each error).
    //
    targetCmp.$replace = (
      Component,
      {
        target = options.target,
        anchor = options.anchor,
        preserveLocalState,
        conservative = false,
      }
    ) => {
      const restore = captureState(targetCmp)
      assignOptions(
        target || options.target,
        anchor,
        restore,
        preserveLocalState
      )

      const callbacks = cmp ? cmp.$$.on_hmr : []

      const afterCallbacks = callbacks.map(fn => fn(cmp)).filter(Boolean)

      const previous = cmp
      if (conservative) {
        try {
          const next = createComponent(Component, restore, previous)
          // prevents on_destroy from firing on non-final cmp instance
          cmp = null
          previous.$destroy()
          cmp = next
        } catch (err) {
          cmp = previous
          throw err
        }
      } else {
        // prevents on_destroy from firing on non-final cmp instance
        cmp = null
        if (previous) {
          // previous can be null if last constructor has crashed
          previous.$destroy()
        }
        cmp = createComponent(Component, restore, cmp)
      }

      cmp.$$.hmr_cmp = cmp

      for (const fn of afterCallbacks) {
        fn(cmp)
      }

      cmp.$$.on_hmr = callbacks

      return cmp
    }

    // NOTE onMount must provide target & anchor (for us to be able to determinate
    // 			actual DOM insertion point)
    //
    // 			And also, to support keyed list, it needs to be called each time the
    // 			component is moved (same as $$.fragment.m)
    if (onMount) {
      const m = targetCmp.$$.fragment.m
      targetCmp.$$.fragment.m = (...args) => {
        const result = m(...args)
        onMount(...args)
        return result
      }
    }

    // NOTE onDestroy must be called even if the call doesn't pass through the
    //      component's $destroy method (that we can hook onto by ourselves, since
    //      it's public API) -- this happens a lot in svelte's internals, that
    //      manipulates cmp.$$.fragment directly, often binding to fragment.d,
    //      for example
    if (onDestroy) {
      targetCmp.$$.on_destroy.push(() => {
        if (isCurrent(targetCmp)) {
          onDestroy()
        }
      })
    }

    if (onInstance) {
      onInstance(targetCmp)
    }

    // Svelte 3 creates and mount components from their constructor if
    // options.target is present.
    //
    // This means that at this point, the component's `fragment.c` and,
    // most notably, `fragment.m` will already have been called _from inside
    // createComponent_. That is: before we have a chance to hook on it.
    //
    // Proxy's constructor
    //   -> createComponent
    //     -> component constructor
    //       -> component.$$.fragment.c(...) (or l, if hydrate:true)
    //       -> component.$$.fragment.m(...)
    //
    //   -> you are here <-
    //
    if (onMount) {
      const { target, anchor } = options
      if (target) {
        onMount(target, anchor)
      }
    }
  }

  const parentComponent = allowLiveBinding
    ? internal.current_component
    : get_current_component_safe()

  cmp = new Component(options)
  cmp.$$.hmr_cmp = cmp

  instrument(cmp)

  return cmp
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/svelte-hmr@0.14.12_svelte@3.50.1/node_modules/svelte-hmr/runtime/proxy.js
/* eslint-env browser */
/**
 * The HMR proxy is a component-like object whose task is to sit in the
 * component tree in place of the proxied component, and rerender each
 * successive versions of said component.
 */



const handledMethods = ['constructor', '$destroy']
const forwardedMethods = ['$set', '$on']

const logError = (msg, err) => {
  // eslint-disable-next-line no-console
  console.error('[HMR][Svelte]', msg)
  if (err) {
    // NOTE avoid too much wrapping around user errors
    // eslint-disable-next-line no-console
    console.error(err)
  }
}

const posixify = file => file.replace(/[/\\]/g, '/')

const getBaseName = id =>
  id
    .split('/')
    .pop()
    .split('.')
    .slice(0, -1)
    .join('.')

const capitalize = str => str[0].toUpperCase() + str.slice(1)

const getFriendlyName = id => capitalize(getBaseName(posixify(id)))

const getDebugName = id => `<${getFriendlyName(id)}>`

const relayCalls = (getTarget, names, dest = {}) => {
  for (const key of names) {
    dest[key] = function(...args) {
      const target = getTarget()
      if (!target) {
        return
      }
      return target[key] && target[key].call(this, ...args)
    }
  }
  return dest
}

const isInternal = key => key !== '$$' && key.slice(0, 2) === '$$'

// This is intented as a somewhat generic / prospective fix to the situation
// that arised with the introduction of $$set in Svelte 3.24.1 -- trying to
// avoid giving full knowledge (like its name) of this implementation detail
// to the proxy. The $$set method can be present or not on the component, and
// its presence impacts the behaviour (but with HMR it will be tested if it is
// present _on the proxy_). So the idea here is to expose exactly the same $$
// props as the current version of the component and, for those that are
// functions, proxy the calls to the current component.
const relayInternalMethods = (proxy, cmp) => {
  // delete any previously added $$ prop
  Object.keys(proxy)
    .filter(isInternal)
    .forEach(key => {
      delete proxy[key]
    })
  // guard: no component
  if (!cmp) return
  // proxy current $$ props to the actual component
  Object.keys(cmp)
    .filter(isInternal)
    .forEach(key => {
      Object.defineProperty(proxy, key, {
        configurable: true,
        get() {
          const value = cmp[key]
          if (typeof value !== 'function') return value
          return (
            value &&
            function(...args) {
              return value.apply(this, args)
            }
          )
        },
      })
    })
}

// proxy custom methods
const copyComponentProperties = (proxy, cmp, previous) => {
  if (previous) {
    previous.forEach(prop => {
      delete proxy[prop]
    })
  }

  const props = Object.getOwnPropertyNames(Object.getPrototypeOf(cmp))
  const wrappedProps = props.filter(prop => {
    if (!handledMethods.includes(prop) && !forwardedMethods.includes(prop)) {
      Object.defineProperty(proxy, prop, {
        configurable: true,
        get() {
          return cmp[prop]
        },
        set(value) {
          // we're changing it on the real component first to see what it
          // gives... if it throws an error, we want to throw the same error in
          // order to most closely follow non-hmr behaviour.
          cmp[prop] = value
        },
      })
      return true
    }
  })

  return wrappedProps
}

// everything in the constructor!
//
// so we don't polute the component class with new members
//
class ProxyComponent {
  constructor(
    {
      Adapter,
      id,
      debugName,
      current, // { Component, hotOptions: { preserveLocalState, ... } }
      register,
    },
    options // { target, anchor, ... }
  ) {
    let cmp
    let disposed = false
    let lastError = null

    const setComponent = _cmp => {
      cmp = _cmp
      relayInternalMethods(this, cmp)
    }

    const getComponent = () => cmp

    const destroyComponent = () => {
      // destroyComponent is tolerant (don't crash on no cmp) because it
      // is possible that reload/rerender is called after a previous
      // createComponent has failed (hence we have a proxy, but no cmp)
      if (cmp) {
        cmp.$destroy()
        setComponent(null)
      }
    }

    const refreshComponent = (target, anchor, conservativeDestroy) => {
      if (lastError) {
        lastError = null
        adapter.rerender()
      } else {
        try {
          const replaceOptions = {
            target,
            anchor,
            preserveLocalState: current.preserveLocalState,
          }
          if (conservativeDestroy) {
            replaceOptions.conservativeDestroy = true
          }
          cmp.$replace(current.Component, replaceOptions)
        } catch (err) {
          setError(err, target, anchor)
          if (
            !current.hotOptions.optimistic ||
            // non acceptable components (that is components that have to defer
            // to their parent for rerender -- e.g. accessors, named exports)
            // are most tricky, and they havent been considered when most of the
            // code has been written... as a result, they are especially tricky
            // to deal with, it's better to consider any error with them to be
            // fatal to avoid odities
            !current.canAccept ||
            (err && err.hmrFatal)
          ) {
            throw err
          } else {
            // const errString = String((err && err.stack) || err)
            logError(`Error during component init: ${debugName}`, err)
          }
        }
      }
    }

    const setError = err => {
      lastError = err
      adapter.renderError(err)
    }

    const instance = {
      hotOptions: current.hotOptions,
      proxy: this,
      id,
      debugName,
      refreshComponent,
    }

    const adapter = new Adapter(instance)

    const { afterMount, rerender } = adapter

    // $destroy is not called when a child component is disposed, so we
    // need to hook from fragment.
    const onDestroy = () => {
      // NOTE do NOT call $destroy on the cmp from here; the cmp is already
      //   dead, this would not work
      if (!disposed) {
        disposed = true
        adapter.dispose()
        unregister()
      }
    }

    // ---- register proxy instance ----

    const unregister = register(rerender)

    // ---- augmented methods ----

    this.$destroy = () => {
      destroyComponent()
      onDestroy()
    }

    // ---- forwarded methods ----

    relayCalls(getComponent, forwardedMethods, this)

    // ---- create & mount target component instance ---

    try {
      let lastProperties
      createProxiedComponent(current.Component, options, {
        allowLiveBinding: current.hotOptions.allowLiveBinding,
        onDestroy,
        onMount: afterMount,
        onInstance: comp => {
          setComponent(comp)
          // WARNING the proxy MUST use the same $$ object as its component
          // instance, because a lot of wiring happens during component
          // initialisation... lots of references to $$ and $$.fragment have
          // already been distributed around when the component constructor
          // returns, before we have a chance to wrap them (and so we can't
          // wrap them no more, because existing references would become
          // invalid)
          this.$$ = comp.$$
          lastProperties = copyComponentProperties(this, comp, lastProperties)
        },
      })
    } catch (err) {
      const { target, anchor } = options
      setError(err, target, anchor)
      throw err
    }
  }
}

const syncStatics = (component, proxy, previousKeys) => {
  // remove previously copied keys
  if (previousKeys) {
    for (const key of previousKeys) {
      delete proxy[key]
    }
  }

  // forward static properties and methods
  const keys = []
  for (const key in component) {
    keys.push(key)
    proxy[key] = component[key]
  }

  return keys
}

const globalListeners = {}

const onGlobal = (event, fn) => {
  event = event.toLowerCase()
  if (!globalListeners[event]) globalListeners[event] = []
  globalListeners[event].push(fn)
}

const fireGlobal = (event, ...args) => {
  const listeners = globalListeners[event]
  if (!listeners) return
  for (const fn of listeners) {
    fn(...args)
  }
}

const fireBeforeUpdate = () => fireGlobal('beforeupdate')

const fireAfterUpdate = () => fireGlobal('afterupdate')

if (typeof window !== 'undefined') {
  window.__SVELTE_HMR = {
    on: onGlobal,
  }
  window.dispatchEvent(new CustomEvent('svelte-hmr:ready'))
}

let fatalError = false

const hasFatalError = () => fatalError

/**
 * Creates a HMR proxy and its associated `reload` function that pushes a new
 * version to all existing instances of the component.
 */
function createProxy({
  Adapter,
  id,
  Component,
  hotOptions,
  canAccept,
  preserveLocalState,
}) {
  const debugName = getDebugName(id)
  const instances = []

  // current object will be updated, proxy instances will keep a ref
  const current = {
    Component,
    hotOptions,
    canAccept,
    preserveLocalState,
  }

  const name = `Proxy${debugName}`

  // this trick gives the dynamic name Proxy<MyComponent> to the concrete
  // proxy class... unfortunately, this doesn't shows in dev tools, but
  // it stills allow to inspect cmp.constructor.name to confirm an instance
  // is a proxy
  const proxy = {
    [name]: class extends ProxyComponent {
      constructor(options) {
        try {
          super(
            {
              Adapter,
              id,
              debugName,
              current,
              register: rerender => {
                instances.push(rerender)
                const unregister = () => {
                  const i = instances.indexOf(rerender)
                  instances.splice(i, 1)
                }
                return unregister
              },
            },
            options
          )
        } catch (err) {
          // If we fail to create a proxy instance, any instance, that means
          // that we won't be able to fix this instance when it is updated.
          // Recovering to normal state will be impossible. HMR's dead.
          //
          // Fatal error will trigger a full reload on next update (reloading
          // right now is kinda pointless since buggy code still exists).
          //
          // NOTE Only report first error to avoid too much polution -- following
          // errors are probably caused by the first one, or they will show up
          // in turn when the first one is fixed \_()_/
          //
          if (!fatalError) {
            fatalError = true
            logError(
              `Unrecoverable HMR error in ${debugName}: ` +
                `next update will trigger a full reload`
            )
          }
          throw err
        }
      }
    },
  }[name]

  // initialize static members
  let previousStatics = syncStatics(current.Component, proxy)

  const update = newState => Object.assign(current, newState)

  // reload all existing instances of this component
  const reload = () => {
    fireBeforeUpdate()

    // copy statics before doing anything because a static prop/method
    // could be used somewhere in the create/render call
    previousStatics = syncStatics(current.Component, proxy, previousStatics)

    const errors = []

    instances.forEach(rerender => {
      try {
        rerender()
      } catch (err) {
        logError(`Failed to rerender ${debugName}`, err)
        errors.push(err)
      }
    })

    if (errors.length > 0) {
      return false
    }

    fireAfterUpdate()

    return true
  }

  const hasFatalError = () => fatalError

  return { id, proxy, update, reload, hasFatalError, current }
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/svelte-hmr@0.14.12_svelte@3.50.1/node_modules/svelte-hmr/runtime/hot-api.js
/* eslint-env browser */



const logPrefix = '[HMR:Svelte]'

// eslint-disable-next-line no-console
const log = (...args) => console.log(logPrefix, ...args)

const domReload = () => {
  // eslint-disable-next-line no-undef
  const win = typeof window !== 'undefined' && window
  if (win && win.location && win.location.reload) {
    log('Reload')
    win.location.reload()
  } else {
    log('Full reload required')
  }
}

const replaceCss = (previousId, newId) => {
  if (typeof document === 'undefined') return false
  if (!previousId) return false
  if (!newId) return false
  // svelte-xxx-style => svelte-xxx
  const previousClass = previousId.slice(0, -6)
  const newClass = newId.slice(0, -6)
  // eslint-disable-next-line no-undef
  document.querySelectorAll('.' + previousClass).forEach(el => {
    el.classList.remove(previousClass)
    el.classList.add(newClass)
  })
  return true
}

const removeStylesheet = cssId => {
  if (cssId == null) return
  if (typeof document === 'undefined') return
  // eslint-disable-next-line no-undef
  const el = document.getElementById(cssId)
  if (el) el.remove()
  return
}

const defaultArgs = {
  reload: domReload,
}

const makeApplyHmr = transformArgs => args => {
  const allArgs = transformArgs({ ...defaultArgs, ...args })
  return applyHmr(allArgs)
}

let needsReload = false

function applyHmr(args) {
  const {
    id,
    cssId,
    nonCssHash,
    reload = domReload,
    // normalized hot API (must conform to rollup-plugin-hot)
    hot,
    hotOptions,
    Component,
    acceptable, // some types of components are impossible to HMR correctly
    preserveLocalState,
    ProxyAdapter,
    emitCss,
  } = args

  const existing = hot.data && hot.data.record

  const canAccept = acceptable && (!existing || existing.current.canAccept)

  const r =
    existing ||
    createProxy({
      Adapter: ProxyAdapter,
      id,
      Component,
      hotOptions,
      canAccept,
      preserveLocalState,
    })

  const cssOnly =
    hotOptions.injectCss &&
    existing &&
    nonCssHash &&
    existing.current.nonCssHash === nonCssHash

  r.update({
    Component,
    hotOptions,
    canAccept,
    nonCssHash,
    cssId,
    previousCssId: r.current.cssId,
    cssOnly,
    preserveLocalState,
  })

  hot.dispose(data => {
    // handle previous fatal errors
    if (needsReload || hasFatalError()) {
      if (hotOptions && hotOptions.noReload) {
        log('Full reload required')
      } else {
        reload()
      }
    }

    // 2020-09-21 Snowpack master doesn't pass data as arg to dispose handler
    data = data || hot.data

    data.record = r

    if (!emitCss && cssId && r.current.cssId !== cssId) {
      if (hotOptions.cssEjectDelay) {
        setTimeout(() => removeStylesheet(cssId), hotOptions.cssEjectDelay)
      } else {
        removeStylesheet(cssId)
      }
    }
  })

  if (canAccept) {
    hot.accept(async arg => {
      const { bubbled } = arg || {}

      // NOTE Snowpack registers accept handlers only once, so we can NOT rely
      // on the surrounding scope variables -- they're not the last version!
      const { cssId: newCssId, previousCssId } = r.current
      const cssChanged = newCssId !== previousCssId
      // ensure old style sheet has been removed by now
      if (!emitCss && cssChanged) removeStylesheet(previousCssId)
      // guard: css only change
      if (
        // NOTE bubbled is provided only by rollup-plugin-hot, and we
        // can't safely assume a CSS only change without it... this means we
        // can't support CSS only injection with Nollup or Webpack currently
        bubbled === false && // WARNING check false, not falsy!
        r.current.cssOnly &&
        (!cssChanged || replaceCss(previousCssId, newCssId))
      ) {
        return
      }

      const success = await r.reload()

      if (hasFatalError() || (!success && !hotOptions.optimistic)) {
        needsReload = true
      }
    })
  }

  // well, endgame... we won't be able to render next updates, even successful,
  // if we don't have proxies in svelte's tree
  //
  // since we won't return the proxy and the app will expect a svelte component,
  // it's gonna crash... so it's best to report the real cause
  //
  // full reload required
  //
  const proxyOk = r && r.proxy
  if (!proxyOk) {
    throw new Error(`Failed to create HMR proxy for Svelte component ${id}`)
  }

  return r.proxy
}

;// CONCATENATED MODULE: ./node_modules/.pnpm/svelte-hmr@0.14.12_svelte@3.50.1/node_modules/svelte-hmr/runtime/index.js


;// CONCATENATED MODULE: ./node_modules/.pnpm/svelte-loader@3.1.3_svelte@3.50.1/node_modules/svelte-loader/lib/hot-api.js


// eslint-disable-next-line no-undef
const g = typeof window !== 'undefined' ? window : __webpack_require__.g;

const globalKey =
	typeof Symbol !== 'undefined'
		? Symbol('SVELTE_LOADER_HOT')
		: '__SVELTE_LOADER_HOT';

if (!g[globalKey]) {
	// do updating refs counting to know when a full update has been applied
	let updatingCount = 0;

	const notifyStart = () => {
		updatingCount++;
	};

	const notifyError = reload => err => {
		const errString = (err && err.stack) || err;
		// eslint-disable-next-line no-console
		console.error(
			'[HMR] Failed to accept update (nollup compat mode)',
			errString
		);
		reload();
		notifyEnd();
	};

	const notifyEnd = () => {
		updatingCount--;
		if (updatingCount === 0) {
			// NOTE this message is important for timing in tests
			// eslint-disable-next-line no-console
			console.log('[HMR:Svelte] Up to date');
		}
	};

	g[globalKey] = {
		hotStates: {},
		notifyStart,
		notifyError,
		notifyEnd,
	};
}

const runAcceptHandlers = acceptHandlers => {
	const queue = [...acceptHandlers];
	const next = () => {
		const cur = queue.shift();
		if (cur) {
			return cur(null).then(next);
		} else {
			return Promise.resolve(null);
		}
	};
	return next();
};

const hot_api_applyHmr = makeApplyHmr(args => {
	const { notifyStart, notifyError, notifyEnd } = g[globalKey];
	const { m, reload } = args;

	let acceptHandlers = (m.hot.data && m.hot.data.acceptHandlers) || [];
	let nextAcceptHandlers = [];

	m.hot.dispose(data => {
		data.acceptHandlers = nextAcceptHandlers;
	});

	const dispose = (...args) => m.hot.dispose(...args);

	const accept = handler => {
		if (nextAcceptHandlers.length === 0) {
			m.hot.accept();
		}
		nextAcceptHandlers.push(handler);
	};

	const check = status => {
		if (status === 'ready') {
			notifyStart();
		} else if (status === 'idle') {
			runAcceptHandlers(acceptHandlers)
				.then(notifyEnd)
				.catch(notifyError(reload));
		}
	};

	m.hot.addStatusHandler(check);

	m.hot.dispose(() => {
		m.hot.removeStatusHandler(check);
	});

	const hot = {
		data: m.hot.data,
		dispose,
		accept,
	};

	return { ...args, hot };
});


/***/ }),

/***/ "./node_modules/.pnpm/theme-change@2.2.0/node_modules/theme-change/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/theme-change@2.2.0/node_modules/theme-change/index.js ***!
  \**********************************************************************************/
/***/ ((module) => {

function themeToggle(){var toggleEl=document.querySelector("[data-toggle-theme]");(function(theme=localStorage.getItem("theme")){if(localStorage.getItem("theme")){document.documentElement.setAttribute("data-theme",theme);if(toggleEl){[...document.querySelectorAll("[data-toggle-theme]")].forEach(el=>{el.classList.add(toggleEl.getAttribute("data-act-class"))})}}})();if(toggleEl){[...document.querySelectorAll("[data-toggle-theme]")].forEach(el=>{el.addEventListener("click",function(){var themesList=el.getAttribute("data-toggle-theme");if(themesList){var themesArray=themesList.split(",");if(document.documentElement.getAttribute("data-theme")==themesArray[0]){if(themesArray.length==1){document.documentElement.removeAttribute("data-theme");localStorage.removeItem("theme")}else{document.documentElement.setAttribute("data-theme",themesArray[1]);localStorage.setItem("theme",themesArray[1])}}else{document.documentElement.setAttribute("data-theme",themesArray[0]);localStorage.setItem("theme",themesArray[0])}}[...document.querySelectorAll("[data-toggle-theme]")].forEach(el=>{el.classList.toggle(this.getAttribute("data-act-class"))})})})}}function themeBtn(){(function(theme=localStorage.getItem("theme")){if(theme!=undefined&&theme!=""){if(localStorage.getItem("theme")&&localStorage.getItem("theme")!=""){document.documentElement.setAttribute("data-theme",theme);var btnEl=document.querySelector("[data-set-theme='"+theme.toString()+"']");if(btnEl){[...document.querySelectorAll("[data-set-theme]")].forEach(el=>{el.classList.remove(el.getAttribute("data-act-class"))});if(btnEl.getAttribute("data-act-class")){btnEl.classList.add(btnEl.getAttribute("data-act-class"))}}}else{var btnEl=document.querySelector("[data-set-theme='']");if(btnEl.getAttribute("data-act-class")){btnEl.classList.add(btnEl.getAttribute("data-act-class"))}}}})();[...document.querySelectorAll("[data-set-theme]")].forEach(el=>{el.addEventListener("click",function(){document.documentElement.setAttribute("data-theme",this.getAttribute("data-set-theme"));localStorage.setItem("theme",document.documentElement.getAttribute("data-theme"));[...document.querySelectorAll("[data-set-theme]")].forEach(el=>{el.classList.remove(el.getAttribute("data-act-class"))});if(el.getAttribute("data-act-class")){el.classList.add(el.getAttribute("data-act-class"))}})})}function themeSelect(){(function(theme=localStorage.getItem("theme")){if(localStorage.getItem("theme")){document.documentElement.setAttribute("data-theme",theme);var optionToggler=document.querySelector("select[data-choose-theme] [value='"+theme.toString()+"']");if(optionToggler){[...document.querySelectorAll("select[data-choose-theme] [value='"+theme.toString()+"']")].forEach(el=>{el.selected=true})}}})();if(document.querySelector("select[data-choose-theme]")){[...document.querySelectorAll("select[data-choose-theme]")].forEach(el=>{el.addEventListener("change",function(){document.documentElement.setAttribute("data-theme",this.value);localStorage.setItem("theme",document.documentElement.getAttribute("data-theme"));[...document.querySelectorAll("select[data-choose-theme] [value='"+localStorage.getItem("theme")+"']")].forEach(el=>{el.selected=true})})})}}function themeChange(attach=true){if(attach===true){document.addEventListener("DOMContentLoaded",function(event){themeToggle();themeSelect();themeBtn()})}else{themeToggle();themeSelect();themeBtn()}}if(true){module.exports={themeChange:themeChange}}else{}

/***/ }),

/***/ "./node_modules/.pnpm/webextension-polyfill@0.10.0/node_modules/webextension-polyfill/dist/browser-polyfill.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/webextension-polyfill@0.10.0/node_modules/webextension-polyfill/dist/browser-polyfill.js ***!
  \*********************************************************************************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (module) {
  /* webextension-polyfill - v0.10.0 - Fri Aug 12 2022 19:42:44 */

  /* -*- Mode: indent-tabs-mode: nil; js-indent-level: 2 -*- */

  /* vim: set sts=2 sw=2 et tw=80: */

  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
  "use strict";

  if (!globalThis.chrome?.runtime?.id) {
    throw new Error("This script should only be loaded in a browser extension.");
  }

  if (typeof globalThis.browser === "undefined" || Object.getPrototypeOf(globalThis.browser) !== Object.prototype) {
    const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = "The message port closed before a response was received."; // Wrapping the bulk of this polyfill in a one-time-use function is a minor
    // optimization for Firefox. Since Spidermonkey does not fully parse the
    // contents of a function until the first time it's called, and since it will
    // never actually need to be called, this allows the polyfill to be included
    // in Firefox nearly for free.

    const wrapAPIs = extensionAPIs => {
      // NOTE: apiMetadata is associated to the content of the api-metadata.json file
      // at build time by replacing the following "include" with the content of the
      // JSON file.
      const apiMetadata = {
        "alarms": {
          "clear": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "clearAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "get": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "bookmarks": {
          "create": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getChildren": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getRecent": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getSubTree": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTree": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "move": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeTree": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "browserAction": {
          "disable": {
            "minArgs": 0,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "enable": {
            "minArgs": 0,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "getBadgeBackgroundColor": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getBadgeText": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getPopup": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTitle": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "openPopup": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "setBadgeBackgroundColor": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setBadgeText": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setIcon": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "setPopup": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setTitle": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "browsingData": {
          "remove": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "removeCache": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeCookies": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeDownloads": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeFormData": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeHistory": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeLocalStorage": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removePasswords": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removePluginData": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "settings": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "commands": {
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "contextMenus": {
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "cookies": {
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAllCookieStores": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "set": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "devtools": {
          "inspectedWindow": {
            "eval": {
              "minArgs": 1,
              "maxArgs": 2,
              "singleCallbackArg": false
            }
          },
          "panels": {
            "create": {
              "minArgs": 3,
              "maxArgs": 3,
              "singleCallbackArg": true
            },
            "elements": {
              "createSidebarPane": {
                "minArgs": 1,
                "maxArgs": 1
              }
            }
          }
        },
        "downloads": {
          "cancel": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "download": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "erase": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getFileIcon": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "open": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "pause": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeFile": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "resume": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "show": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "extension": {
          "isAllowedFileSchemeAccess": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "isAllowedIncognitoAccess": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "history": {
          "addUrl": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "deleteAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "deleteRange": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "deleteUrl": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getVisits": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "i18n": {
          "detectLanguage": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAcceptLanguages": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "identity": {
          "launchWebAuthFlow": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "idle": {
          "queryState": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "management": {
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getSelf": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "setEnabled": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "uninstallSelf": {
            "minArgs": 0,
            "maxArgs": 1
          }
        },
        "notifications": {
          "clear": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "create": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getPermissionLevel": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "pageAction": {
          "getPopup": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTitle": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "hide": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setIcon": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "setPopup": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setTitle": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "show": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "permissions": {
          "contains": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "request": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "runtime": {
          "getBackgroundPage": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getPlatformInfo": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "openOptionsPage": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "requestUpdateCheck": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "sendMessage": {
            "minArgs": 1,
            "maxArgs": 3
          },
          "sendNativeMessage": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "setUninstallURL": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "sessions": {
          "getDevices": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getRecentlyClosed": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "restore": {
            "minArgs": 0,
            "maxArgs": 1
          }
        },
        "storage": {
          "local": {
            "clear": {
              "minArgs": 0,
              "maxArgs": 0
            },
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "remove": {
              "minArgs": 1,
              "maxArgs": 1
            },
            "set": {
              "minArgs": 1,
              "maxArgs": 1
            }
          },
          "managed": {
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            }
          },
          "sync": {
            "clear": {
              "minArgs": 0,
              "maxArgs": 0
            },
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "remove": {
              "minArgs": 1,
              "maxArgs": 1
            },
            "set": {
              "minArgs": 1,
              "maxArgs": 1
            }
          }
        },
        "tabs": {
          "captureVisibleTab": {
            "minArgs": 0,
            "maxArgs": 2
          },
          "create": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "detectLanguage": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "discard": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "duplicate": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "executeScript": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getCurrent": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getZoom": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getZoomSettings": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "goBack": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "goForward": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "highlight": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "insertCSS": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "move": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "query": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "reload": {
            "minArgs": 0,
            "maxArgs": 2
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeCSS": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "sendMessage": {
            "minArgs": 2,
            "maxArgs": 3
          },
          "setZoom": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "setZoomSettings": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "update": {
            "minArgs": 1,
            "maxArgs": 2
          }
        },
        "topSites": {
          "get": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "webNavigation": {
          "getAllFrames": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getFrame": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "webRequest": {
          "handlerBehaviorChanged": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "windows": {
          "create": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getCurrent": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getLastFocused": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        }
      };

      if (Object.keys(apiMetadata).length === 0) {
        throw new Error("api-metadata.json has not been included in browser-polyfill");
      }
      /**
       * A WeakMap subclass which creates and stores a value for any key which does
       * not exist when accessed, but behaves exactly as an ordinary WeakMap
       * otherwise.
       *
       * @param {function} createItem
       *        A function which will be called in order to create the value for any
       *        key which does not exist, the first time it is accessed. The
       *        function receives, as its only argument, the key being created.
       */


      class DefaultWeakMap extends WeakMap {
        constructor(createItem, items = undefined) {
          super(items);
          this.createItem = createItem;
        }

        get(key) {
          if (!this.has(key)) {
            this.set(key, this.createItem(key));
          }

          return super.get(key);
        }

      }
      /**
       * Returns true if the given object is an object with a `then` method, and can
       * therefore be assumed to behave as a Promise.
       *
       * @param {*} value The value to test.
       * @returns {boolean} True if the value is thenable.
       */


      const isThenable = value => {
        return value && typeof value === "object" && typeof value.then === "function";
      };
      /**
       * Creates and returns a function which, when called, will resolve or reject
       * the given promise based on how it is called:
       *
       * - If, when called, `chrome.runtime.lastError` contains a non-null object,
       *   the promise is rejected with that value.
       * - If the function is called with exactly one argument, the promise is
       *   resolved to that value.
       * - Otherwise, the promise is resolved to an array containing all of the
       *   function's arguments.
       *
       * @param {object} promise
       *        An object containing the resolution and rejection functions of a
       *        promise.
       * @param {function} promise.resolve
       *        The promise's resolution function.
       * @param {function} promise.reject
       *        The promise's rejection function.
       * @param {object} metadata
       *        Metadata about the wrapped method which has created the callback.
       * @param {boolean} metadata.singleCallbackArg
       *        Whether or not the promise is resolved with only the first
       *        argument of the callback, alternatively an array of all the
       *        callback arguments is resolved. By default, if the callback
       *        function is invoked with only a single argument, that will be
       *        resolved to the promise, while all arguments will be resolved as
       *        an array if multiple are given.
       *
       * @returns {function}
       *        The generated callback function.
       */


      const makeCallback = (promise, metadata) => {
        return (...callbackArgs) => {
          if (extensionAPIs.runtime.lastError) {
            promise.reject(new Error(extensionAPIs.runtime.lastError.message));
          } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {
            promise.resolve(callbackArgs[0]);
          } else {
            promise.resolve(callbackArgs);
          }
        };
      };

      const pluralizeArguments = numArgs => numArgs == 1 ? "argument" : "arguments";
      /**
       * Creates a wrapper function for a method with the given name and metadata.
       *
       * @param {string} name
       *        The name of the method which is being wrapped.
       * @param {object} metadata
       *        Metadata about the method being wrapped.
       * @param {integer} metadata.minArgs
       *        The minimum number of arguments which must be passed to the
       *        function. If called with fewer than this number of arguments, the
       *        wrapper will raise an exception.
       * @param {integer} metadata.maxArgs
       *        The maximum number of arguments which may be passed to the
       *        function. If called with more than this number of arguments, the
       *        wrapper will raise an exception.
       * @param {boolean} metadata.singleCallbackArg
       *        Whether or not the promise is resolved with only the first
       *        argument of the callback, alternatively an array of all the
       *        callback arguments is resolved. By default, if the callback
       *        function is invoked with only a single argument, that will be
       *        resolved to the promise, while all arguments will be resolved as
       *        an array if multiple are given.
       *
       * @returns {function(object, ...*)}
       *       The generated wrapper function.
       */


      const wrapAsyncFunction = (name, metadata) => {
        return function asyncFunctionWrapper(target, ...args) {
          if (args.length < metadata.minArgs) {
            throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
          }

          if (args.length > metadata.maxArgs) {
            throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
          }

          return new Promise((resolve, reject) => {
            if (metadata.fallbackToNoCallback) {
              // This API method has currently no callback on Chrome, but it return a promise on Firefox,
              // and so the polyfill will try to call it with a callback first, and it will fallback
              // to not passing the callback if the first call fails.
              try {
                target[name](...args, makeCallback({
                  resolve,
                  reject
                }, metadata));
              } catch (cbError) {
                console.warn(`${name} API method doesn't seem to support the callback parameter, ` + "falling back to call it without a callback: ", cbError);
                target[name](...args); // Update the API method metadata, so that the next API calls will not try to
                // use the unsupported callback anymore.

                metadata.fallbackToNoCallback = false;
                metadata.noCallback = true;
                resolve();
              }
            } else if (metadata.noCallback) {
              target[name](...args);
              resolve();
            } else {
              target[name](...args, makeCallback({
                resolve,
                reject
              }, metadata));
            }
          });
        };
      };
      /**
       * Wraps an existing method of the target object, so that calls to it are
       * intercepted by the given wrapper function. The wrapper function receives,
       * as its first argument, the original `target` object, followed by each of
       * the arguments passed to the original method.
       *
       * @param {object} target
       *        The original target object that the wrapped method belongs to.
       * @param {function} method
       *        The method being wrapped. This is used as the target of the Proxy
       *        object which is created to wrap the method.
       * @param {function} wrapper
       *        The wrapper function which is called in place of a direct invocation
       *        of the wrapped method.
       *
       * @returns {Proxy<function>}
       *        A Proxy object for the given method, which invokes the given wrapper
       *        method in its place.
       */


      const wrapMethod = (target, method, wrapper) => {
        return new Proxy(method, {
          apply(targetMethod, thisObj, args) {
            return wrapper.call(thisObj, target, ...args);
          }

        });
      };

      let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
      /**
       * Wraps an object in a Proxy which intercepts and wraps certain methods
       * based on the given `wrappers` and `metadata` objects.
       *
       * @param {object} target
       *        The target object to wrap.
       *
       * @param {object} [wrappers = {}]
       *        An object tree containing wrapper functions for special cases. Any
       *        function present in this object tree is called in place of the
       *        method in the same location in the `target` object tree. These
       *        wrapper methods are invoked as described in {@see wrapMethod}.
       *
       * @param {object} [metadata = {}]
       *        An object tree containing metadata used to automatically generate
       *        Promise-based wrapper functions for asynchronous. Any function in
       *        the `target` object tree which has a corresponding metadata object
       *        in the same location in the `metadata` tree is replaced with an
       *        automatically-generated wrapper function, as described in
       *        {@see wrapAsyncFunction}
       *
       * @returns {Proxy<object>}
       */

      const wrapObject = (target, wrappers = {}, metadata = {}) => {
        let cache = Object.create(null);
        let handlers = {
          has(proxyTarget, prop) {
            return prop in target || prop in cache;
          },

          get(proxyTarget, prop, receiver) {
            if (prop in cache) {
              return cache[prop];
            }

            if (!(prop in target)) {
              return undefined;
            }

            let value = target[prop];

            if (typeof value === "function") {
              // This is a method on the underlying object. Check if we need to do
              // any wrapping.
              if (typeof wrappers[prop] === "function") {
                // We have a special-case wrapper for this method.
                value = wrapMethod(target, target[prop], wrappers[prop]);
              } else if (hasOwnProperty(metadata, prop)) {
                // This is an async method that we have metadata for. Create a
                // Promise wrapper for it.
                let wrapper = wrapAsyncFunction(prop, metadata[prop]);
                value = wrapMethod(target, target[prop], wrapper);
              } else {
                // This is a method that we don't know or care about. Return the
                // original method, bound to the underlying object.
                value = value.bind(target);
              }
            } else if (typeof value === "object" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {
              // This is an object that we need to do some wrapping for the children
              // of. Create a sub-object wrapper for it with the appropriate child
              // metadata.
              value = wrapObject(value, wrappers[prop], metadata[prop]);
            } else if (hasOwnProperty(metadata, "*")) {
              // Wrap all properties in * namespace.
              value = wrapObject(value, wrappers[prop], metadata["*"]);
            } else {
              // We don't need to do any wrapping for this property,
              // so just forward all access to the underlying object.
              Object.defineProperty(cache, prop, {
                configurable: true,
                enumerable: true,

                get() {
                  return target[prop];
                },

                set(value) {
                  target[prop] = value;
                }

              });
              return value;
            }

            cache[prop] = value;
            return value;
          },

          set(proxyTarget, prop, value, receiver) {
            if (prop in cache) {
              cache[prop] = value;
            } else {
              target[prop] = value;
            }

            return true;
          },

          defineProperty(proxyTarget, prop, desc) {
            return Reflect.defineProperty(cache, prop, desc);
          },

          deleteProperty(proxyTarget, prop) {
            return Reflect.deleteProperty(cache, prop);
          }

        }; // Per contract of the Proxy API, the "get" proxy handler must return the
        // original value of the target if that value is declared read-only and
        // non-configurable. For this reason, we create an object with the
        // prototype set to `target` instead of using `target` directly.
        // Otherwise we cannot return a custom object for APIs that
        // are declared read-only and non-configurable, such as `chrome.devtools`.
        //
        // The proxy handlers themselves will still use the original `target`
        // instead of the `proxyTarget`, so that the methods and properties are
        // dereferenced via the original targets.

        let proxyTarget = Object.create(target);
        return new Proxy(proxyTarget, handlers);
      };
      /**
       * Creates a set of wrapper functions for an event object, which handles
       * wrapping of listener functions that those messages are passed.
       *
       * A single wrapper is created for each listener function, and stored in a
       * map. Subsequent calls to `addListener`, `hasListener`, or `removeListener`
       * retrieve the original wrapper, so that  attempts to remove a
       * previously-added listener work as expected.
       *
       * @param {DefaultWeakMap<function, function>} wrapperMap
       *        A DefaultWeakMap object which will create the appropriate wrapper
       *        for a given listener function when one does not exist, and retrieve
       *        an existing one when it does.
       *
       * @returns {object}
       */


      const wrapEvent = wrapperMap => ({
        addListener(target, listener, ...args) {
          target.addListener(wrapperMap.get(listener), ...args);
        },

        hasListener(target, listener) {
          return target.hasListener(wrapperMap.get(listener));
        },

        removeListener(target, listener) {
          target.removeListener(wrapperMap.get(listener));
        }

      });

      const onRequestFinishedWrappers = new DefaultWeakMap(listener => {
        if (typeof listener !== "function") {
          return listener;
        }
        /**
         * Wraps an onRequestFinished listener function so that it will return a
         * `getContent()` property which returns a `Promise` rather than using a
         * callback API.
         *
         * @param {object} req
         *        The HAR entry object representing the network request.
         */


        return function onRequestFinished(req) {
          const wrappedReq = wrapObject(req, {}
          /* wrappers */
          , {
            getContent: {
              minArgs: 0,
              maxArgs: 0
            }
          });
          listener(wrappedReq);
        };
      });
      const onMessageWrappers = new DefaultWeakMap(listener => {
        if (typeof listener !== "function") {
          return listener;
        }
        /**
         * Wraps a message listener function so that it may send responses based on
         * its return value, rather than by returning a sentinel value and calling a
         * callback. If the listener function returns a Promise, the response is
         * sent when the promise either resolves or rejects.
         *
         * @param {*} message
         *        The message sent by the other end of the channel.
         * @param {object} sender
         *        Details about the sender of the message.
         * @param {function(*)} sendResponse
         *        A callback which, when called with an arbitrary argument, sends
         *        that value as a response.
         * @returns {boolean}
         *        True if the wrapped listener returned a Promise, which will later
         *        yield a response. False otherwise.
         */


        return function onMessage(message, sender, sendResponse) {
          let didCallSendResponse = false;
          let wrappedSendResponse;
          let sendResponsePromise = new Promise(resolve => {
            wrappedSendResponse = function (response) {
              didCallSendResponse = true;
              resolve(response);
            };
          });
          let result;

          try {
            result = listener(message, sender, wrappedSendResponse);
          } catch (err) {
            result = Promise.reject(err);
          }

          const isResultThenable = result !== true && isThenable(result); // If the listener didn't returned true or a Promise, or called
          // wrappedSendResponse synchronously, we can exit earlier
          // because there will be no response sent from this listener.

          if (result !== true && !isResultThenable && !didCallSendResponse) {
            return false;
          } // A small helper to send the message if the promise resolves
          // and an error if the promise rejects (a wrapped sendMessage has
          // to translate the message into a resolved promise or a rejected
          // promise).


          const sendPromisedResult = promise => {
            promise.then(msg => {
              // send the message value.
              sendResponse(msg);
            }, error => {
              // Send a JSON representation of the error if the rejected value
              // is an instance of error, or the object itself otherwise.
              let message;

              if (error && (error instanceof Error || typeof error.message === "string")) {
                message = error.message;
              } else {
                message = "An unexpected error occurred";
              }

              sendResponse({
                __mozWebExtensionPolyfillReject__: true,
                message
              });
            }).catch(err => {
              // Print an error on the console if unable to send the response.
              console.error("Failed to send onMessage rejected reply", err);
            });
          }; // If the listener returned a Promise, send the resolved value as a
          // result, otherwise wait the promise related to the wrappedSendResponse
          // callback to resolve and send it as a response.


          if (isResultThenable) {
            sendPromisedResult(result);
          } else {
            sendPromisedResult(sendResponsePromise);
          } // Let Chrome know that the listener is replying.


          return true;
        };
      });

      const wrappedSendMessageCallback = ({
        reject,
        resolve
      }, reply) => {
        if (extensionAPIs.runtime.lastError) {
          // Detect when none of the listeners replied to the sendMessage call and resolve
          // the promise to undefined as in Firefox.
          // See https://github.com/mozilla/webextension-polyfill/issues/130
          if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {
            resolve();
          } else {
            reject(new Error(extensionAPIs.runtime.lastError.message));
          }
        } else if (reply && reply.__mozWebExtensionPolyfillReject__) {
          // Convert back the JSON representation of the error into
          // an Error instance.
          reject(new Error(reply.message));
        } else {
          resolve(reply);
        }
      };

      const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {
        if (args.length < metadata.minArgs) {
          throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
        }

        if (args.length > metadata.maxArgs) {
          throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
        }

        return new Promise((resolve, reject) => {
          const wrappedCb = wrappedSendMessageCallback.bind(null, {
            resolve,
            reject
          });
          args.push(wrappedCb);
          apiNamespaceObj.sendMessage(...args);
        });
      };

      const staticWrappers = {
        devtools: {
          network: {
            onRequestFinished: wrapEvent(onRequestFinishedWrappers)
          }
        },
        runtime: {
          onMessage: wrapEvent(onMessageWrappers),
          onMessageExternal: wrapEvent(onMessageWrappers),
          sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
            minArgs: 1,
            maxArgs: 3
          })
        },
        tabs: {
          sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
            minArgs: 2,
            maxArgs: 3
          })
        }
      };
      const settingMetadata = {
        clear: {
          minArgs: 1,
          maxArgs: 1
        },
        get: {
          minArgs: 1,
          maxArgs: 1
        },
        set: {
          minArgs: 1,
          maxArgs: 1
        }
      };
      apiMetadata.privacy = {
        network: {
          "*": settingMetadata
        },
        services: {
          "*": settingMetadata
        },
        websites: {
          "*": settingMetadata
        }
      };
      return wrapObject(extensionAPIs, staticWrappers, apiMetadata);
    }; // The build process adds a UMD wrapper around this file, which makes the
    // `module` variable available.


    module.exports = wrapAPIs(chrome);
  } else {
    module.exports = globalThis.browser;
  }
});
//# sourceMappingURL=browser-polyfill.js.map


/***/ }),

/***/ "./node_modules/.pnpm/wunderbaum@0.3.5/node_modules/wunderbaum/dist/wunderbaum.esm.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/wunderbaum@0.3.5/node_modules/wunderbaum/dist/wunderbaum.esm.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Wunderbaum": () => (/* binding */ Wunderbaum)
/* harmony export */ });
/*!
 * Wunderbaum - util
 * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.
 * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)
 */
/** @module util */
/** Readable names for `MouseEvent.button` */
const MOUSE_BUTTONS = {
    0: "",
    1: "left",
    2: "middle",
    3: "right",
    4: "back",
    5: "forward",
};
const MAX_INT = 9007199254740991;
const userInfo = _getUserInfo();
/**True if the client is using a macOS platform. */
const isMac = userInfo.isMac;
const REX_HTML = /[&<>"'/]/g; // Escape those characters
const REX_TOOLTIP = /[<>"'/]/g; // Don't escape `&` in tooltips
const ENTITY_MAP = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
    "/": "&#x2F;",
};
/**
 * A ES6 Promise, that exposes the resolve()/reject() methods.
 */
let Deferred$1 = class Deferred {
    constructor() {
        this.thens = [];
        this.catches = [];
        this.status = "";
    }
    resolve(value) {
        if (this.status) {
            throw new Error("already settled");
        }
        this.status = "resolved";
        this.resolvedValue = value;
        this.thens.forEach((t) => t(value));
        this.thens = []; // Avoid memleaks.
    }
    reject(error) {
        if (this.status) {
            throw new Error("already settled");
        }
        this.status = "rejected";
        this.rejectedError = error;
        this.catches.forEach((c) => c(error));
        this.catches = []; // Avoid memleaks.
    }
    then(cb) {
        if (status === "resolved") {
            cb(this.resolvedValue);
        }
        else {
            this.thens.unshift(cb);
        }
    }
    catch(cb) {
        if (this.status === "rejected") {
            cb(this.rejectedError);
        }
        else {
            this.catches.unshift(cb);
        }
    }
    promise() {
        return {
            then: this.then,
            catch: this.catch,
        };
    }
};
/**Throw an `Error` if `cond` is falsey. */
function assert(cond, msg) {
    if (!cond) {
        msg = msg || "Assertion failed.";
        throw new Error(msg);
    }
}
function _getUserInfo() {
    const nav = navigator;
    // const ua = nav.userAgentData;
    const res = {
        isMac: /Mac/.test(nav.platform),
    };
    return res;
}
/** Run `callback` when document was loaded. */
function documentReady(callback) {
    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", callback);
    }
    else {
        callback();
    }
}
/** Resolve when document was loaded. */
function documentReadyPromise() {
    return new Promise((resolve) => {
        documentReady(resolve);
    });
}
/**
 * Iterate over Object properties or array elements.
 *
 * @param obj `Object`, `Array` or null
 * @param callback(index, item) called for every item.
 *  `this` also contains the item.
 *  Return `false` to stop the iteration.
 */
function each(obj, callback) {
    if (obj == null) {
        // accept `null` or `undefined`
        return obj;
    }
    let length = obj.length, i = 0;
    if (typeof length === "number") {
        for (; i < length; i++) {
            if (callback.call(obj[i], i, obj[i]) === false) {
                break;
            }
        }
    }
    else {
        for (let k in obj) {
            if (callback.call(obj[i], k, obj[k]) === false) {
                break;
            }
        }
    }
    return obj;
}
/** Shortcut for `throw new Error(msg)`.*/
function error(msg) {
    throw new Error(msg);
}
/** Convert `<`, `>`, `&`, `"`, `'`, and `/` to the equivalent entities. */
function escapeHtml(s) {
    return ("" + s).replace(REX_HTML, function (s) {
        return ENTITY_MAP[s];
    });
}
// export function escapeRegExp(s: string) {
//   return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
// }
/**Convert a regular expression string by escaping special characters (e.g. `"$"` -> `"\$"`) */
function escapeRegex(s) {
    return ("" + s).replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
}
/** Convert `<`, `>`, `"`, `'`, and `/` (but not `&`) to the equivalent entities. */
function escapeTooltip(s) {
    return ("" + s).replace(REX_TOOLTIP, function (s) {
        return ENTITY_MAP[s];
    });
}
/** TODO */
function extractHtmlText(s) {
    if (s.indexOf(">") >= 0) {
        error("Not implemented");
        // return $("<div/>").html(s).text();
    }
    return s;
}
/**
 * Read the value from an HTML input element.
 *
 * If a `<span class="wb-col">` is passed, the first child input is used.
 * Depending on the target element type, `value` is interpreted accordingly.
 * For example for a checkbox, a value of true, false, or null is returned if
 * the element is checked, unchecked, or indeterminate.
 * For datetime input control a numerical value is assumed, etc.
 *
 * Common use case: store the new user input in a `change` event handler:
 *
 * ```ts
 *   change: (e) => {
 *     const tree = e.tree;
 *     const node = e.node;
 *     // Read the value from the input control that triggered the change event:
 *     let value = tree.getValueFromElem(e.element);
 *     // and store it to the node model (assuming the column id matches the property name)
 *     node.data[e.info.colId] = value;
 *   },
 * ```
 * @param elem `<input>` or `<select>` element. Also a parent `span.wb-col` is accepted.
 * @param coerce pass true to convert date/time inputs to `Date`.
 * @returns the value
 */
function getValueFromElem(elem, coerce = false) {
    const tag = elem.tagName;
    let value = null;
    if (tag === "SPAN" && elem.classList.contains("wb-col")) {
        const span = elem;
        const embeddedInput = span.querySelector("input,select");
        if (embeddedInput) {
            return getValueFromElem(embeddedInput, coerce);
        }
        span.innerText = "" + value;
    }
    else if (tag === "INPUT") {
        const input = elem;
        const type = input.type;
        switch (type) {
            case "button":
            case "reset":
            case "submit":
            case "image":
                break;
            case "checkbox":
                value = input.indeterminate ? null : input.checked;
                break;
            case "date":
            case "datetime":
            case "datetime-local":
            case "month":
            case "time":
            case "week":
                value = coerce ? input.valueAsDate : input.value;
                break;
            case "number":
            case "range":
                value = input.valueAsNumber;
                break;
            case "radio":
                const name = input.name;
                const checked = input.parentElement.querySelector(`input[name="${name}"]:checked`);
                value = checked ? checked.value : undefined;
                break;
            case "text":
            default:
                value = input.value;
        }
    }
    else if (tag === "SELECT") {
        const select = elem;
        value = select.value;
    }
    return value;
}
/**
 * Set the value of an HTML input element.
 *
 * If a `<span class="wb-col">` is passed, the first child input is used.
 * Depending on the target element type, `value` is interpreted accordingly.
 * For example a checkbox is set to checked, unchecked, or indeterminate if the
 * value is truethy, falsy, or `null`.
 * For datetime input control a numerical value is assumed, etc.
 *
 * Common use case: update embedded input controls in a `render` event handler:
 *
 * ```ts
 *   render: (e) => {
 *     // e.node.log(e.type, e, e.node.data);
 *
 *     for (const col of Object.values(e.renderColInfosById)) {
 *       switch (col.id) {
 *         default:
 *           // Assumption: we named column.id === node.data.NAME
 *           util.setValueToElem(col.elem, e.node.data[col.id]);
 *           break;
 *       }
 *     }
 *   },
 * ```
 *
 * @param elem `<input>` or `<select>` element Also a parent `span.wb-col` is accepted.
 * @param value a value that matches the target element.
 */
function setValueToElem(elem, value) {
    const tag = elem.tagName;
    if (tag === "SPAN" && elem.classList.contains("wb-col")) {
        const span = elem;
        const embeddedInput = span.querySelector("input,select");
        if (embeddedInput) {
            return setValueToElem(embeddedInput, value);
        }
        // No embedded input: simply write as escaped html
        span.innerText = "" + value;
    }
    else if (tag === "INPUT") {
        const input = elem;
        const type = input.type;
        switch (type) {
            case "checkbox":
                // An explicit `null` value is interpreted as 'indeterminate'.
                // `undefined` is interpreted as 'unchecked'
                input.indeterminate = value === null;
                input.checked = !!value;
                break;
            case "date":
            case "month":
            case "time":
            case "week":
            case "datetime":
            case "datetime-local":
                input.valueAsDate = new Date(value);
                break;
            case "number":
            case "range":
                if (value == null) {
                    input.value = value;
                }
                else {
                    input.valueAsNumber = value;
                }
                break;
            case "radio":
                error(`Not yet implemented: ${type}`);
                // const name = input.name;
                // const checked = input.parentElement!.querySelector(
                //   `input[name="${name}"]:checked`
                // );
                // value = checked ? (<HTMLInputElement>checked).value : undefined;
                break;
            case "button":
            case "reset":
            case "submit":
            case "image":
                break;
            case "text":
            default:
                input.value = value !== null && value !== void 0 ? value : "";
        }
    }
    else if (tag === "SELECT") {
        const select = elem;
        if (value == null) {
            select.selectedIndex = -1;
        }
        else {
            select.value = value;
        }
    }
}
/** Show/hide element by setting the `display` style to 'none'. */
function setElemDisplay(elem, flag) {
    const style = elemFromSelector(elem).style;
    if (flag) {
        if (style.display === "none") {
            style.display = "";
        }
    }
    else if (style.display === "") {
        style.display = "none";
    }
}
/** Create and return an unconnected `HTMLElement` from a HTML string. */
function elemFromHtml(html) {
    const t = document.createElement("template");
    t.innerHTML = html.trim();
    return t.content.firstElementChild;
}
const _IGNORE_KEYS = new Set(["Alt", "Control", "Meta", "Shift"]);
/** Return a HtmlElement from selector or cast an existing element. */
function elemFromSelector(obj) {
    if (!obj) {
        return null; //(null as unknown) as HTMLElement;
    }
    if (typeof obj === "string") {
        return document.querySelector(obj);
    }
    return obj;
}
/** Return a EventTarget from selector or cast an existing element. */
function eventTargetFromSelector(obj) {
    if (!obj) {
        return null;
    }
    if (typeof obj === "string") {
        return document.querySelector(obj);
    }
    return obj;
}
/**
 * Return a canonical descriptive string for a keyboard or mouse event.
 *
 * The result also contains a prefix for modifiers if any, for example
 * `"x"`, `"F2"`, `"Control+Home"`, or `"Shift+clickright"`.
 * This is especially useful in `switch` statements, to make sure that modifier
 * keys are considered and handled correctly:
 * ```ts
 *   const eventName = util.eventToString(e);
 *   switch (eventName) {
 *     case "+":
 *     case "Add":
 *       ...
 *       break;
 *     case "Enter":
 *     case "End":
 *     case "Control+End":
 *     case "Meta+ArrowDown":
 *     case "PageDown":
 *       ...
 *       break;
 *   }
 * ```
 */
function eventToString(event) {
    let key = event.key, et = event.type, s = [];
    if (event.altKey) {
        s.push("Alt");
    }
    if (event.ctrlKey) {
        s.push("Control");
    }
    if (event.metaKey) {
        s.push("Meta");
    }
    if (event.shiftKey) {
        s.push("Shift");
    }
    if (et === "click" || et === "dblclick") {
        s.push(MOUSE_BUTTONS[event.button] + et);
    }
    else if (et === "wheel") {
        s.push(et);
        // } else if (!IGNORE_KEYCODES[key]) {
        //   s.push(
        //     SPECIAL_KEYCODES[key] ||
        //     String.fromCharCode(key).toLowerCase()
        //   );
    }
    else if (!_IGNORE_KEYS.has(key)) {
        s.push(key);
    }
    return s.join("+");
}
/**
 * Copy allproperties from one or more source objects to a target object.
 *
 * @returns the modified target object.
 */
// TODO: use Object.assign()? --> https://stackoverflow.com/a/42740894
// TODO: support deep merge --> https://stackoverflow.com/a/42740894
function extend(...args) {
    for (let i = 1; i < args.length; i++) {
        let arg = args[i];
        if (arg == null) {
            continue;
        }
        for (let key in arg) {
            if (Object.prototype.hasOwnProperty.call(arg, key)) {
                args[0][key] = arg[key];
            }
        }
    }
    return args[0];
}
/** Return true if `obj` is of type `array`. */
function isArray(obj) {
    return Array.isArray(obj);
}
/** Return true if `obj` is of type `Object` and has no propertied. */
function isEmptyObject(obj) {
    return Object.keys(obj).length === 0 && obj.constructor === Object;
}
/** Return true if `obj` is of type `function`. */
function isFunction(obj) {
    return typeof obj === "function";
}
/** Return true if `obj` is of type `Object`. */
function isPlainObject(obj) {
    return Object.prototype.toString.call(obj) === "[object Object]";
}
/** A dummy function that does nothing ('no operation'). */
function noop(...args) { }
function onEvent(rootTarget, eventNames, selectorOrHandler, handlerOrNone) {
    let selector, handler;
    rootTarget = eventTargetFromSelector(rootTarget);
    if (handlerOrNone) {
        selector = selectorOrHandler;
        handler = handlerOrNone;
    }
    else {
        selector = "";
        handler = selectorOrHandler;
    }
    eventNames.split(" ").forEach((evn) => {
        rootTarget.addEventListener(evn, function (e) {
            // console.log(evn, selector, e)
            if (!selector) {
                return handler(e); // no event delegation
            }
            else if (e.target) {
                let elem = e.target;
                if (elem.matches(selector)) {
                    return handler(e);
                }
                elem = elem.closest(selector);
                if (elem) {
                    return handler(e);
                }
            }
        });
    });
}
/** Return a wrapped handler method, that provides `this._super` and `this._superApply`.
 *
 * ```ts
  // Implement `opts.createNode` event to add the 'draggable' attribute
  overrideMethod(ctx.options, "createNode", (event, data) => {
    // Default processing if any
    this._super.apply(this, event, data);
    // Add 'draggable' attribute
    data.node.span.draggable = true;
  });
  ```
  */
function overrideMethod(instance, methodName, handler, ctx) {
    let prevSuper, prevSuperApply, self = ctx || instance, prevFunc = instance[methodName], _super = (...args) => {
        return prevFunc.apply(self, args);
    }, _superApply = (argsArray) => {
        return prevFunc.apply(self, argsArray);
    };
    let wrapper = (...args) => {
        try {
            prevSuper = self._super;
            prevSuperApply = self._superApply;
            self._super = _super;
            self._superApply = _superApply;
            return handler.apply(self, args);
        }
        finally {
            self._super = prevSuper;
            self._superApply = prevSuperApply;
        }
    };
    instance[methodName] = wrapper;
}
/** Run function after ms milliseconds and return a promise that resolves when done. */
function setTimeoutPromise(callback, ms) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            try {
                resolve(callback.apply(this));
            }
            catch (err) {
                reject(err);
            }
        }, ms);
    });
}
/**
 * Wait `ms` microseconds.
 *
 * Example:
 * ```js
 * await sleep(1000);
 * ```
 * @param ms duration
 * @returns
 */
async function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
/**
 * Set or rotate checkbox status with support for tri-state.
 *
 * An initial 'indeterminate' state becomes 'checked' on the first call.
 *
 * If the input element has the class 'wb-tristate' assigned, the sequence is:<br>
 * 'indeterminate' -> 'checked' -> 'unchecked' -> 'indeterminate' -> ...<br>
 * Otherwise we toggle like <br>
 * 'checked' -> 'unchecked' -> 'checked' -> ...
 */
function toggleCheckbox(element, value, tristate) {
    const input = elemFromSelector(element);
    assert(input.type === "checkbox");
    tristate !== null && tristate !== void 0 ? tristate : (tristate = input.classList.contains("wb-tristate") || input.indeterminate);
    if (value === undefined) {
        const curValue = input.indeterminate ? null : input.checked;
        switch (curValue) {
            case true:
                value = false;
                break;
            case false:
                value = tristate ? null : true;
                break;
            case null:
                value = true;
                break;
        }
    }
    input.indeterminate = value == null;
    input.checked = !!value;
}
/**
 * Return `opts.NAME` if opts is valid and
 *
 * @param opts dict, object, or null
 * @param name option name (use dot notation to access extension option, e.g. `filter.mode`)
 * @param defaultValue returned when `opts` is not an object, or does not have a NAME property
 */
function getOption(opts, name, defaultValue = undefined) {
    let ext;
    // Lookup `name` in options dict
    if (opts && name.indexOf(".") >= 0) {
        [ext, name] = name.split(".");
        opts = opts[ext];
    }
    let value = opts ? opts[name] : null;
    // Use value from value options dict, fallback do default
    return value !== null && value !== void 0 ? value : defaultValue;
}
/** Convert an Array or space-separated string to a Set. */
function toSet(val) {
    if (val instanceof Set) {
        return val;
    }
    if (typeof val === "string") {
        let set = new Set();
        for (const c of val.split(" ")) {
            set.add(c.trim());
        }
        return set;
    }
    if (Array.isArray(val)) {
        return new Set(val);
    }
    throw new Error("Cannot convert to Set<string>: " + val);
}
// /** Check if a string is contained in an Array or Set. */
// export function isAnyOf(s: string, items: Array<string>|Set<string>): boolean {
//   return Array.prototype.includes.call(items, s)
// }
// /** Check if an Array or Set has at least one matching entry. */
// export function hasAnyOf(container: Array<string>|Set<string>, items: Array<string>): boolean {
//   if (Array.isArray(container)) {
//     return container.some(v => )
//   }
//   return container.some(v => {})
//   // const container = toSet(items);
//   // const itemSet = toSet(items);
//   // Array.prototype.includes
//   // throw new Error("Cannot convert to Set<string>: " + val);
// }
/** Return a canonical string representation for an object's type (e.g. 'array', 'number', ...). */
function type(obj) {
    return Object.prototype.toString
        .call(obj)
        .replace(/^\[object (.+)\]$/, "$1")
        .toLowerCase();
}
/**
 * Return a function that can be called instead of `callback`, but guarantees
 * a limited execution rate.
 * The execution rate is calculated based on the runtime duration of the
 * previous call.
 * Example:
 * ```js
 * throttledFoo = util.adaptiveThrottle(foo.bind(this), {});
 * throttledFoo();
 * throttledFoo();
 * ```
 */
function adaptiveThrottle(callback, options) {
    let waiting = 0; // Initially, we're not waiting
    let pendingArgs = null;
    const opts = Object.assign({
        minDelay: 16,
        defaultDelay: 200,
        maxDelay: 5000,
        delayFactor: 2.0,
    }, options);
    const minDelay = Math.max(16, +opts.minDelay);
    const maxDelay = +opts.maxDelay;
    const throttledFn = (...args) => {
        if (waiting) {
            pendingArgs = args;
            // console.log(`adaptiveThrottle() queing request #${waiting}...`, args);
            waiting += 1;
        }
        else {
            // Prevent invocations while running or blocking
            waiting = 1;
            const useArgs = args; // pendingArgs || args;
            pendingArgs = null;
            // console.log(`adaptiveThrottle() execute...`, useArgs);
            const start = Date.now();
            try {
                callback.apply(this, useArgs);
            }
            catch (error) {
                console.error(error);
            }
            const elap = Date.now() - start;
            const curDelay = Math.min(Math.max(minDelay, elap * opts.delayFactor), maxDelay);
            const useDelay = Math.max(minDelay, curDelay - elap);
            // console.log(
            //   `adaptiveThrottle() calling worker took ${elap}ms. delay = ${curDelay}ms, using ${useDelay}ms`,
            //   pendingArgs
            // );
            setTimeout(() => {
                // Unblock, and trigger pending requests if any
                // const skipped = waiting - 1;
                waiting = 0; // And allow future invocations
                if (pendingArgs != null) {
                    // There was another request while running or waiting
                    // console.log(
                    //   `adaptiveThrottle() re-trigger (missed ${skipped})...`,
                    //   pendingArgs
                    // );
                    throttledFn.apply(this, pendingArgs);
                }
            }, useDelay);
        }
    };
    return throttledFn;
}

var util = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Deferred: Deferred$1,
  MAX_INT: MAX_INT,
  MOUSE_BUTTONS: MOUSE_BUTTONS,
  adaptiveThrottle: adaptiveThrottle,
  assert: assert,
  documentReady: documentReady,
  documentReadyPromise: documentReadyPromise,
  each: each,
  elemFromHtml: elemFromHtml,
  elemFromSelector: elemFromSelector,
  error: error,
  escapeHtml: escapeHtml,
  escapeRegex: escapeRegex,
  escapeTooltip: escapeTooltip,
  eventTargetFromSelector: eventTargetFromSelector,
  eventToString: eventToString,
  extend: extend,
  extractHtmlText: extractHtmlText,
  getOption: getOption,
  getValueFromElem: getValueFromElem,
  isArray: isArray,
  isEmptyObject: isEmptyObject,
  isFunction: isFunction,
  isMac: isMac,
  isPlainObject: isPlainObject,
  noop: noop,
  onEvent: onEvent,
  overrideMethod: overrideMethod,
  setElemDisplay: setElemDisplay,
  setTimeoutPromise: setTimeoutPromise,
  setValueToElem: setValueToElem,
  sleep: sleep,
  toSet: toSet,
  toggleCheckbox: toggleCheckbox,
  type: type
});

/*!
 * Wunderbaum - types
 * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.
 * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)
 */
/**
 * Possible values for {@link WunderbaumNode.setModified()} and {@link Wunderbaum.setModified()}.
 */
var ChangeType;
(function (ChangeType) {
    /** Re-render the whole viewport, headers, and all rows. */
    ChangeType["any"] = "any";
    /** A node's title, icon, columns, or status have changed. Update the existing row markup. */
    ChangeType["data"] = "data";
    /** The `tree.columns` definition has changed beyond simple width adjustments. */
    ChangeType["colStructure"] = "colStructure";
    /** The viewport/window was resized. Adjust layout attributes for all elements. */
    ChangeType["resize"] = "resize";
    /** A node's definition has changed beyond status and data. Re-render the whole row's markup. */
    ChangeType["row"] = "row";
    /** Nodes have been added, removed, etc. Update markup. */
    ChangeType["structure"] = "structure";
    /** A node's status has changed. Update current row's classes, to reflect active, selected, ... */
    ChangeType["status"] = "status";
    /** Vertical scroll event. Update the 'top' property of all rows. */
    ChangeType["scroll"] = "scroll";
})(ChangeType || (ChangeType = {}));
/* Internal use. */
var RenderFlag;
(function (RenderFlag) {
    RenderFlag["clearMarkup"] = "clearMarkup";
    RenderFlag["header"] = "header";
    RenderFlag["redraw"] = "redraw";
    RenderFlag["scroll"] = "scroll";
})(RenderFlag || (RenderFlag = {}));
/** Possible values for {@link WunderbaumNode.setStatus()}. */
var NodeStatusType;
(function (NodeStatusType) {
    NodeStatusType["ok"] = "ok";
    NodeStatusType["loading"] = "loading";
    NodeStatusType["error"] = "error";
    NodeStatusType["noData"] = "noData";
    // paging = "paging",
})(NodeStatusType || (NodeStatusType = {}));
/** Define the subregion of a node, where an event occurred. */
var NodeRegion;
(function (NodeRegion) {
    NodeRegion["unknown"] = "";
    NodeRegion["checkbox"] = "checkbox";
    NodeRegion["column"] = "column";
    NodeRegion["expander"] = "expander";
    NodeRegion["icon"] = "icon";
    NodeRegion["prefix"] = "prefix";
    NodeRegion["title"] = "title";
})(NodeRegion || (NodeRegion = {}));
/** Initial navigation mode and possible transition. */
var NavModeEnum;
(function (NavModeEnum) {
    NavModeEnum["startRow"] = "startRow";
    NavModeEnum["cell"] = "cell";
    NavModeEnum["startCell"] = "startCell";
    NavModeEnum["row"] = "row";
})(NavModeEnum || (NavModeEnum = {}));

/*!
 * Wunderbaum - wb_extension_base
 * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.
 * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)
 */
class WunderbaumExtension {
    constructor(tree, id, defaults) {
        this.enabled = true;
        this.tree = tree;
        this.id = id;
        this.treeOpts = tree.options;
        const opts = tree.options;
        if (this.treeOpts[id] === undefined) {
            opts[id] = this.extensionOpts = extend({}, defaults);
        }
        else {
            // TODO: do we break existing object instance references here?
            this.extensionOpts = extend({}, defaults, opts[id]);
            opts[id] = this.extensionOpts;
        }
        this.enabled = this.getPluginOption("enabled", true);
    }
    /** Called on tree (re)init after all extensions are added, but before loading.*/
    init() {
        this.tree.element.classList.add("wb-ext-" + this.id);
    }
    // protected callEvent(type: string, extra?: any): any {
    //   let func = this.extensionOpts[type];
    //   if (func) {
    //     return func.call(
    //       this.tree,
    //       util.extend(
    //         {
    //           event: this.id + "." + type,
    //         },
    //         extra
    //       )
    //     );
    //   }
    // }
    getPluginOption(name, defaultValue) {
        var _a;
        return (_a = this.extensionOpts[name]) !== null && _a !== void 0 ? _a : defaultValue;
    }
    setPluginOption(name, value) {
        this.extensionOpts[name] = value;
    }
    setEnabled(flag = true) {
        return this.setPluginOption("enabled", !!flag);
        // this.enabled = !!flag;
    }
    onKeyEvent(data) {
        return;
    }
    onRender(data) {
        return;
    }
}

/*!
 * debounce & throttle, taken from https://github.com/lodash/lodash v4.17.21
 * MIT License: https://raw.githubusercontent.com/lodash/lodash/4.17.21-npm/LICENSE
 * Modified for TypeScript type annotations.
 */
/* --- */
/** Detect free variable `global` from Node.js. */
const freeGlobal = typeof __webpack_require__.g === "object" &&
    __webpack_require__.g !== null &&
    __webpack_require__.g.Object === Object &&
    __webpack_require__.g;
/** Detect free variable `globalThis` */
const freeGlobalThis = typeof globalThis === "object" &&
    globalThis !== null &&
    globalThis.Object == Object &&
    globalThis;
/** Detect free variable `self`. */
const freeSelf = typeof self === "object" && self !== null && self.Object === Object && self;
/** Used as a reference to the global object. */
const root = freeGlobalThis || freeGlobal || freeSelf || Function("return this")();
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * isObject({})
 * // => true
 *
 * isObject([1, 2, 3])
 * // => true
 *
 * isObject(Function)
 * // => true
 *
 * isObject(null)
 * // => false
 */
function isObject(value) {
    const type = typeof value;
    return value != null && (type === "object" || type === "function");
}
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked, or until the next browser frame is drawn. The debounced function
 * comes with a `cancel` method to cancel delayed `func` invocations and a
 * `flush` method to immediately invoke them. Provide `options` to indicate
 * whether `func` should be invoked on the leading and/or trailing edge of the
 * `wait` timeout. The `func` is invoked with the last arguments provided to the
 * debounced function. Subsequent calls to the debounced function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`
 * invocation will be deferred until the next frame is drawn (typically about
 * 16ms).
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `debounce` and `throttle`.
 *
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0]
 *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is
 *  used (if available).
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', debounce(calculateLayout, 150))
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }))
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * const debounced = debounce(batchLog, 250, { 'maxWait': 1000 })
 * const source = new EventSource('/stream')
 * jQuery(source).on('message', debounced)
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel)
 *
 * // Check for pending invocations.
 * const status = debounced.pending() ? "Pending..." : "Ready"
 */
function debounce(func, wait = 0, options = {}) {
    let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;
    let lastInvokeTime = 0;
    let leading = false;
    let maxing = false;
    let trailing = true;
    // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.
    const useRAF = !wait && wait !== 0 && typeof root.requestAnimationFrame === "function";
    if (typeof func !== "function") {
        throw new TypeError("Expected a function");
    }
    wait = +wait || 0;
    if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
        const args = lastArgs;
        const thisArg = lastThis;
        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
    }
    function startTimer(pendingFunc, wait) {
        if (useRAF) {
            root.cancelAnimationFrame(timerId);
            return root.requestAnimationFrame(pendingFunc);
        }
        return setTimeout(pendingFunc, wait);
    }
    function cancelTimer(id) {
        if (useRAF) {
            return root.cancelAnimationFrame(id);
        }
        clearTimeout(id);
    }
    function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = startTimer(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
        const timeSinceLastCall = time - lastCallTime;
        const timeSinceLastInvoke = time - lastInvokeTime;
        const timeWaiting = wait - timeSinceLastCall;
        return maxing
            ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)
            : timeWaiting;
    }
    function shouldInvoke(time) {
        const timeSinceLastCall = time - lastCallTime;
        const timeSinceLastInvoke = time - lastInvokeTime;
        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined ||
            timeSinceLastCall >= wait ||
            timeSinceLastCall < 0 ||
            (maxing && timeSinceLastInvoke >= maxWait));
    }
    function timerExpired() {
        const time = Date.now();
        if (shouldInvoke(time)) {
            return trailingEdge(time);
        }
        // Restart the timer.
        timerId = startTimer(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
        timerId = undefined;
        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
            return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
    }
    function cancel() {
        if (timerId !== undefined) {
            cancelTimer(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
    }
    function flush() {
        return timerId === undefined ? result : trailingEdge(Date.now());
    }
    function pending() {
        return timerId !== undefined;
    }
    function debounced(...args) {
        const time = Date.now();
        const isInvoking = shouldInvoke(time);
        lastArgs = args;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
            if (timerId === undefined) {
                return leadingEdge(lastCallTime);
            }
            if (maxing) {
                // Handle invocations in a tight loop.
                timerId = startTimer(timerExpired, wait);
                return invokeFunc(lastCallTime);
            }
        }
        if (timerId === undefined) {
            timerId = startTimer(timerExpired, wait);
        }
        return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    debounced.pending = pending;
    return debounced;
}

/*!
 * Wunderbaum - ext-filter
 * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.
 * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)
 */
const START_MARKER = "\uFFF7";
const END_MARKER = "\uFFF8";
const RE_START_MARKER = new RegExp(escapeRegex(START_MARKER), "g");
const RE_END_MARTKER = new RegExp(escapeRegex(END_MARKER), "g");
class FilterExtension extends WunderbaumExtension {
    constructor(tree) {
        super(tree, "filter", {
            connectInput: null,
            autoApply: true,
            autoExpand: false,
            counter: true,
            fuzzy: false,
            hideExpandedCounter: true,
            hideExpanders: false,
            highlight: true,
            leavesOnly: false,
            mode: "dim",
            noData: true, // Display a 'no data' status node if result is empty
        });
        this.lastFilterArgs = null;
    }
    init() {
        super.init();
        const connectInput = this.getPluginOption("connectInput");
        if (connectInput) {
            this.queryInput = elemFromSelector(connectInput);
            onEvent(this.queryInput, "input", debounce((e) => {
                // this.tree.log("query", e);
                this.filterNodes(this.queryInput.value.trim(), {});
            }, 700));
        }
    }
    setPluginOption(name, value) {
        // alert("filter opt=" + name + ", " + value)
        super.setPluginOption(name, value);
        switch (name) {
            case "mode":
                this.tree.filterMode = value === "hide" ? "hide" : "dim";
                this.tree.updateFilter();
                break;
        }
    }
    _applyFilterNoUpdate(filter, branchMode, _opts) {
        return this.tree.runWithoutUpdate(() => {
            return this._applyFilterImpl(filter, branchMode, _opts);
        });
    }
    _applyFilterImpl(filter, branchMode, _opts) {
        let match, temp, start = Date.now(), count = 0, tree = this.tree, treeOpts = tree.options,
        // escapeTitles = treeOpts.escapeTitles,
        prevAutoCollapse = treeOpts.autoCollapse, opts = extend({}, treeOpts.filter, _opts), hideMode = opts.mode === "hide", leavesOnly = !!opts.leavesOnly && !branchMode;
        // Default to 'match title substring (case insensitive)'
        if (typeof filter === "string") {
            if (filter === "") {
                tree.logInfo("Passing an empty string as a filter is handled as clearFilter().");
                this.clearFilter();
                return;
            }
            if (opts.fuzzy) {
                // See https://codereview.stackexchange.com/questions/23899/faster-javascript-fuzzy-string-matching-function/23905#23905
                // and http://www.quora.com/How-is-the-fuzzy-search-algorithm-in-Sublime-Text-designed
                // and http://www.dustindiaz.com/autocomplete-fuzzy-matching
                match = filter
                    .split("")
                    // Escaping the `filter` will not work because,
                    // it gets further split into individual characters. So,
                    // escape each character after splitting
                    .map(escapeRegex)
                    .reduce(function (a, b) {
                    // create capture groups for parts that comes before
                    // the character
                    return a + "([^" + b + "]*)" + b;
                }, "");
            }
            else {
                match = escapeRegex(filter); // make sure a '.' is treated literally
            }
            let re = new RegExp(match, "i");
            let reHighlight = new RegExp(escapeRegex(filter), "gi");
            filter = (node) => {
                if (!node.title) {
                    return false;
                }
                // let text = escapeTitles ? node.title : extractHtmlText(node.title);
                let text = node.title;
                // `.match` instead of `.test` to get the capture groups
                let res = text.match(re);
                if (res && opts.highlight) {
                    // if (escapeTitles) {
                    if (opts.fuzzy) {
                        temp = _markFuzzyMatchedChars(text, res, true);
                    }
                    else {
                        // #740: we must not apply the marks to escaped entity names, e.g. `&quot;`
                        // Use some exotic characters to mark matches:
                        temp = text.replace(reHighlight, function (s) {
                            return START_MARKER + s + END_MARKER;
                        });
                    }
                    // now we can escape the title...
                    node.titleWithHighlight = escapeHtml(temp)
                        // ... and finally insert the desired `<mark>` tags
                        .replace(RE_START_MARKER, "<mark>")
                        .replace(RE_END_MARTKER, "</mark>");
                    // } else {
                    //   if (opts.fuzzy) {
                    //     node.titleWithHighlight = _markFuzzyMatchedChars(text, res);
                    //   } else {
                    //     node.titleWithHighlight = text.replace(reHighlight, function (s) {
                    //       return "<mark>" + s + "</mark>";
                    //     });
                    //   }
                    // }
                    // node.debug("filter", escapeTitles, text, node.titleWithHighlight);
                }
                return !!res;
            };
        }
        tree.filterMode = opts.mode;
        this.lastFilterArgs = arguments;
        tree.element.classList.toggle("wb-ext-filter-hide", !!hideMode);
        tree.element.classList.toggle("wb-ext-filter-dim", !hideMode);
        tree.element.classList.toggle("wb-ext-filter-hide-expanders", !!opts.hideExpanders);
        // Reset current filter
        tree.root.subMatchCount = 0;
        tree.visit((node) => {
            delete node.match;
            delete node.titleWithHighlight;
            node.subMatchCount = 0;
        });
        // statusNode = tree.root.findDirectChild(KEY_NODATA);
        // if (statusNode) {
        //   statusNode.remove();
        // }
        tree.setStatus(NodeStatusType.ok);
        // Adjust node.hide, .match, and .subMatchCount properties
        treeOpts.autoCollapse = false; // #528
        tree.visit((node) => {
            if (leavesOnly && node.children != null) {
                return;
            }
            let res = filter(node);
            if (res === "skip") {
                node.visit(function (c) {
                    c.match = false;
                }, true);
                return "skip";
            }
            let matchedByBranch = false;
            if ((branchMode || res === "branch") && node.parent.match) {
                res = true;
                matchedByBranch = true;
            }
            if (res) {
                count++;
                node.match = true;
                node.visitParents((p) => {
                    if (p !== node) {
                        p.subMatchCount += 1;
                    }
                    // Expand match (unless this is no real match, but only a node in a matched branch)
                    if (opts.autoExpand && !matchedByBranch && !p.expanded) {
                        p.setExpanded(true, {
                            noAnimation: true,
                            noEvents: true,
                            scrollIntoView: false,
                        });
                        p._filterAutoExpanded = true;
                    }
                }, true);
            }
        });
        treeOpts.autoCollapse = prevAutoCollapse;
        if (count === 0 && opts.noData && hideMode) {
            tree.root.setStatus(NodeStatusType.noData);
        }
        // Redraw whole tree
        tree.logInfo(`Filter '${match}' found ${count} nodes in ${Date.now() - start} ms.`);
        return count;
    }
    /**
     * [ext-filter] Dim or hide nodes.
     */
    filterNodes(filter, options) {
        return this._applyFilterNoUpdate(filter, false, options);
    }
    /**
     * [ext-filter] Dim or hide whole branches.
     */
    filterBranches(filter, options) {
        return this._applyFilterNoUpdate(filter, true, options);
    }
    /**
     * [ext-filter] Re-apply current filter.
     */
    updateFilter() {
        let tree = this.tree;
        if (tree.filterMode &&
            this.lastFilterArgs &&
            tree.options.filter.autoApply) {
            this._applyFilterNoUpdate.apply(this, this.lastFilterArgs);
        }
        else {
            tree.logWarn("updateFilter(): no filter active.");
        }
    }
    /**
     * [ext-filter] Reset the filter.
     */
    clearFilter() {
        let tree = this.tree;
        // statusNode = tree.root.findDirectChild(KEY_NODATA),
        // escapeTitles = tree.options.escapeTitles;
        // enhanceTitle = tree.options.enhanceTitle,
        tree.enableUpdate(false);
        // if (statusNode) {
        //   statusNode.remove();
        // }
        tree.setStatus(NodeStatusType.ok);
        // we also counted root node's subMatchCount
        delete tree.root.match;
        delete tree.root.subMatchCount;
        tree.visit((node) => {
            if (node.match && node._rowElem) {
                // #491, #601
                let titleElem = node._rowElem.querySelector("span.wb-title");
                // if (escapeTitles) {
                titleElem.textContent = node.title;
                // } else {
                //   titleElem.innerHTML = node.title;
                // }
                node._callEvent("enhanceTitle", { titleElem: titleElem });
            }
            delete node.match;
            delete node.subMatchCount;
            delete node.titleWithHighlight;
            if (node.subMatchBadge) {
                node.subMatchBadge.remove();
                delete node.subMatchBadge;
            }
            if (node._filterAutoExpanded && node.expanded) {
                node.setExpanded(false, {
                    noAnimation: true,
                    noEvents: true,
                    scrollIntoView: false,
                });
            }
            delete node._filterAutoExpanded;
        });
        tree.filterMode = null;
        this.lastFilterArgs = null;
        tree.element.classList.remove(
        // "wb-ext-filter",
        "wb-ext-filter-dim", "wb-ext-filter-hide");
        // tree._callHook("treeStructureChanged", this, "clearFilter");
        // tree.render();
        tree.enableUpdate(true);
    }
}
/**
 * @description Marks the matching charecters of `text` either by `mark` or
 * by exotic*Chars (if `escapeTitles` is `true`) based on `matches`
 * which is an array of matching groups.
 * @param {string} text
 * @param {RegExpMatchArray} matches
 */
function _markFuzzyMatchedChars(text, matches, escapeTitles = true) {
    let matchingIndices = [];
    // get the indices of matched characters (Iterate through `RegExpMatchArray`)
    for (let _matchingArrIdx = 1; _matchingArrIdx < matches.length; _matchingArrIdx++) {
        let _mIdx =
        // get matching char index by cumulatively adding
        // the matched group length
        matches[_matchingArrIdx].length +
            (_matchingArrIdx === 1 ? 0 : 1) +
            (matchingIndices[matchingIndices.length - 1] || 0);
        matchingIndices.push(_mIdx);
    }
    // Map each `text` char to its position and store in `textPoses`.
    let textPoses = text.split("");
    if (escapeTitles) {
        // If escaping the title, then wrap the matching char within exotic chars
        matchingIndices.forEach(function (v) {
            textPoses[v] = START_MARKER + textPoses[v] + END_MARKER;
        });
    }
    else {
        // Otherwise, Wrap the matching chars within `mark`.
        matchingIndices.forEach(function (v) {
            textPoses[v] = "<mark>" + textPoses[v] + "</mark>";
        });
    }
    // Join back the modified `textPoses` to create final highlight markup.
    return textPoses.join("");
}

/*!
 * Wunderbaum - ext-keynav
 * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.
 * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)
 */
const QUICKSEARCH_DELAY = 500;
class KeynavExtension extends WunderbaumExtension {
    constructor(tree) {
        super(tree, "keynav", {});
    }
    _getEmbeddedInputElem(elem) {
        var _a;
        let input = null;
        if (elem && elem.type != null) {
            input = elem;
        }
        else {
            // ,[contenteditable]
            const ace = (_a = this.tree.getActiveColElem()) === null || _a === void 0 ? void 0 : _a.querySelector("input,select");
            if (ace) {
                input = ace;
            }
        }
        return input;
    }
    /* Return true if the current cell's embedded input has keyboard focus. */
    _isCurInputFocused() {
        var _a;
        const ace = (_a = this.tree
            .getActiveColElem()) === null || _a === void 0 ? void 0 : _a.querySelector("input:focus,select:focus");
        return !!ace;
    }
    onKeyEvent(data) {
        const event = data.event, tree = this.tree, opts = data.options, activate = !event.ctrlKey || opts.autoActivate, curInput = this._getEmbeddedInputElem(event.target), inputHasFocus = curInput && this._isCurInputFocused(), navModeOption = opts.navigationModeOption;
        // isCellEditMode = tree.navMode === NavigationMode.cellEdit;
        let focusNode, eventName = eventToString(event), node = data.node, handled = true;
        // tree.log(`onKeyEvent: ${eventName}, curInput`, curInput);
        if (!tree.isEnabled()) {
            // tree.logDebug(`onKeyEvent ignored for disabled tree: ${eventName}`);
            return false;
        }
        // Let callback prevent default processing
        if (tree._callEvent("keydown", data) === false) {
            return false;
        }
        // Let ext-edit trigger editing
        if (tree._callMethod("edit._preprocessKeyEvent", data) === false) {
            return false;
        }
        // Set focus to active (or first node) if no other node has the focus yet
        if (!node) {
            const currentNode = tree.getFocusNode() || tree.getActiveNode();
            const firstNode = tree.getFirstChild();
            if (!currentNode && firstNode && eventName === "ArrowDown") {
                firstNode.logInfo("Keydown: activate first node.");
                firstNode.setActive();
                return;
            }
            focusNode = currentNode || firstNode;
            if (focusNode) {
                focusNode.setFocus();
                node = tree.getFocusNode();
                node.logInfo("Keydown: force focus on active node.");
            }
        }
        const isColspan = node.isColspan();
        if (tree.isRowNav()) {
            // -----------------------------------------------------------------------
            // --- Row Mode ---
            // -----------------------------------------------------------------------
            if (inputHasFocus) {
                // If editing an embedded input control, let the control handle all
                // keys. Only Enter and Escape should apply / discard, but keep the
                // keyboard focus.
                switch (eventName) {
                    case "Enter":
                        curInput.blur();
                        tree.setFocus();
                        break;
                    case "Escape":
                        node.render();
                        tree.setFocus();
                        break;
                }
                return;
            }
            // --- Quick-Search
            if (opts.quicksearch &&
                eventName.length === 1 &&
                /^\w$/.test(eventName) &&
                !curInput) {
                // Allow to search for longer streaks if typed in quickly
                const stamp = Date.now();
                if (stamp - tree.lastQuicksearchTime > QUICKSEARCH_DELAY) {
                    tree.lastQuicksearchTerm = "";
                }
                tree.lastQuicksearchTime = stamp;
                tree.lastQuicksearchTerm += eventName;
                let matchNode = tree.findNextNode(tree.lastQuicksearchTerm, tree.getActiveNode());
                if (matchNode) {
                    matchNode.setActive(true, { event: event });
                }
                event.preventDefault();
                return;
            }
            // Pre-Evaluate expand/collapse action for LEFT/RIGHT
            switch (eventName) {
                case "Enter":
                    if (node.isActive()) {
                        if (node.isExpanded()) {
                            eventName = "Subtract"; // callapse
                        }
                        else if (node.isExpandable(true)) {
                            eventName = "Add"; // expand
                        }
                    }
                    break;
                case "ArrowLeft":
                    if (node.expanded) {
                        eventName = "Subtract"; // collapse
                    }
                    break;
                case "ArrowRight":
                    if (!node.expanded && node.isExpandable(true)) {
                        eventName = "Add"; // expand
                    }
                    else if (navModeOption === NavModeEnum.startCell ||
                        navModeOption === NavModeEnum.startRow) {
                        event.preventDefault();
                        tree.setCellNav();
                        return false;
                    }
                    break;
            }
            // Standard navigation (row mode)
            switch (eventName) {
                case "+":
                case "Add":
                    // case "=": // 187: '+' @ Chrome, Safari
                    node.setExpanded(true);
                    break;
                case "-":
                case "Subtract":
                    node.setExpanded(false);
                    break;
                case " ": // Space
                    // if (node.isPagingNode()) {
                    //   tree._triggerNodeEvent("clickPaging", ctx, event);
                    // } else
                    if (node.getOption("checkbox")) {
                        node.setSelected(!node.isSelected());
                    }
                    else {
                        node.setActive(true, { event: event });
                    }
                    break;
                case "Enter":
                    node.setActive(true, { event: event });
                    break;
                case "ArrowDown":
                case "ArrowLeft":
                case "ArrowRight":
                case "ArrowUp":
                case "Backspace":
                case "End":
                case "Home":
                case "Control+End":
                case "Control+Home":
                case "Meta+ArrowDown":
                case "Meta+ArrowUp":
                case "PageDown":
                case "PageUp":
                    node.navigate(eventName, { activate: activate, event: event });
                    break;
                default:
                    handled = false;
            }
        }
        else {
            const curInput = this._getEmbeddedInputElem(null);
            const curInputType = curInput ? curInput.type || curInput.tagName : "";
            const inputHasFocus = curInput && this._isCurInputFocused();
            const inputCanFocus = curInput && curInputType !== "checkbox";
            if (inputHasFocus) {
                if (eventName === "Escape") {
                    // Discard changes
                    node.render();
                    // Keep cell-nav mode
                    node.logDebug(`Reset focused input`);
                    tree.setFocus();
                    tree.setColumn(tree.activeColIdx);
                    return;
                    // } else if (!INPUT_BREAKOUT_KEYS.has(eventName)) {
                }
                else if (eventName !== "Enter") {
                    // Let current `<input>` handle it
                    node.logDebug(`Ignored ${eventName} inside focused input`);
                    return;
                }
                // const curInputType = curInput.type || curInput.tagName;
                // const breakoutKeys = INPUT_KEYS[curInputType];
                // if (!breakoutKeys.includes(eventName)) {
                //   node.logDebug(`Ignored ${eventName} inside ${curInputType} input`);
                //   return;
                // }
            }
            else if (curInput) {
                // On a cell that has an embedded, unfocused <input>
                if (eventName.length === 1 && inputCanFocus) {
                    curInput.focus();
                    curInput.value = "";
                    node.logDebug(`Focus imput: ${eventName}`);
                    return false;
                }
            }
            if (eventName === "Tab") {
                eventName = "ArrowRight";
                handled = true;
            }
            else if (eventName === "Shift+Tab") {
                eventName = tree.activeColIdx > 0 ? "ArrowLeft" : "";
                handled = true;
            }
            else ;
            switch (eventName) {
                case "+":
                case "Add":
                    // case "=": // 187: '+' @ Chrome, Safari
                    node.setExpanded(true);
                    break;
                case "-":
                case "Subtract":
                    node.setExpanded(false);
                    break;
                case " ": // Space
                    if (tree.activeColIdx === 0 && node.getOption("checkbox")) {
                        node.setSelected(!node.isSelected());
                        handled = true;
                    }
                    else if (curInput && curInputType === "checkbox") {
                        curInput.click();
                        // toggleCheckbox(curInput)
                        // new Event("change")
                        // curInput.change
                        handled = true;
                    }
                    break;
                case "F2":
                    if (curInput && !inputHasFocus && inputCanFocus) {
                        curInput.focus();
                        handled = true;
                    }
                    break;
                case "Enter":
                    tree.setFocus(); // Blur prev. input if any
                    if ((tree.activeColIdx === 0 || isColspan) && node.isExpandable()) {
                        node.setExpanded(!node.isExpanded());
                        handled = true;
                    }
                    else if (curInput && !inputHasFocus && inputCanFocus) {
                        curInput.focus();
                        handled = true;
                    }
                    break;
                case "Escape":
                    tree.setFocus(); // Blur prev. input if any
                    node.log(`keynav: focus tree...`);
                    if (tree.isCellNav() && navModeOption !== NavModeEnum.cell) {
                        node.log(`keynav: setCellNav(false)`);
                        tree.setCellNav(false); // row-nav mode
                        tree.setFocus(); //
                        handled = true;
                    }
                    break;
                case "ArrowLeft":
                    tree.setFocus(); // Blur prev. input if any
                    if (isColspan && node.isExpanded()) {
                        node.setExpanded(false);
                    }
                    else if (!isColspan && tree.activeColIdx > 0) {
                        tree.setColumn(tree.activeColIdx - 1);
                    }
                    else if (navModeOption !== NavModeEnum.cell) {
                        tree.setCellNav(false); // row-nav mode
                    }
                    handled = true;
                    break;
                case "ArrowRight":
                    tree.setFocus(); // Blur prev. input if any
                    if (isColspan && !node.isExpanded()) {
                        node.setExpanded();
                    }
                    else if (!isColspan &&
                        tree.activeColIdx < tree.columns.length - 1) {
                        tree.setColumn(tree.activeColIdx + 1);
                    }
                    handled = true;
                    break;
                case "Home": // Generated by [Fn] + ArrowLeft on Mac
                    // case "Meta+ArrowLeft":
                    tree.setFocus(); // Blur prev. input if any
                    if (!isColspan && tree.activeColIdx > 0) {
                        tree.setColumn(0);
                    }
                    handled = true;
                    break;
                case "End": // Generated by [Fn] + ArrowRight on Mac
                    // case "Meta+ArrowRight":
                    tree.setFocus(); // Blur prev. input if any
                    if (!isColspan && tree.activeColIdx < tree.columns.length - 1) {
                        tree.setColumn(tree.columns.length - 1);
                    }
                    handled = true;
                    break;
                case "ArrowDown":
                case "ArrowUp":
                case "Backspace":
                case "Control+End": // Generated by Control + [Fn] + ArrowRight on Mac
                case "Control+Home": // Generated by Control + [Fn] + Arrowleft on Mac
                case "Meta+ArrowDown": // [] + ArrowDown on Mac
                case "Meta+ArrowUp": // [] + ArrowUp on Mac
                case "PageDown": // Generated by [Fn] + ArrowDown on Mac
                case "PageUp": // Generated by [Fn] + ArrowUp on Mac
                    node.navigate(eventName, { activate: activate, event: event });
                    // if (isCellEditMode) {
                    //   this._getEmbeddedInputElem(null, true); // set focus to input
                    // }
                    handled = true;
                    break;
                default:
                    handled = false;
            }
        }
        if (handled) {
            event.preventDefault();
        }
        return;
    }
}

/*!
 * Wunderbaum - ext-logger
 * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.
 * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)
 */
class LoggerExtension extends WunderbaumExtension {
    constructor(tree) {
        super(tree, "logger", {});
        this.ignoreEvents = new Set([
            "enhanceTitle",
            "render",
            "discard",
        ]);
        this.prefix = tree + ".ext-logger";
    }
    init() {
        const tree = this.tree;
        // this.ignoreEvents.add();
        if (tree.getOption("debugLevel") >= 4) {
            // const self = this;
            const ignoreEvents = this.ignoreEvents;
            const prefix = this.prefix;
            overrideMethod(tree, "callEvent", function (name, extra) {
                if (ignoreEvents.has(name)) {
                    return tree._superApply(arguments);
                }
                const start = Date.now();
                const res = tree._superApply(arguments);
                console.debug(`${prefix}: callEvent('${name}') took ${Date.now() - start} ms.`, arguments[1]);
                return res;
            });
        }
    }
    onKeyEvent(data) {
        // this.tree.logInfo("onKeyEvent", eventToString(data.event), data);
        console.debug(`${this.prefix}: onKeyEvent()`, data);
        return;
    }
}

/*!
 * Wunderbaum - common
 * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.
 * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)
 */
const DEFAULT_DEBUGLEVEL = 4; // Replaced by rollup script
/**
 * Fixed height of a row in pixel. Must match the SCSS variable `$row-outer-height`.
 */
const ROW_HEIGHT = 22;
/**
 * Fixed width of node icons in pixel. Must match the SCSS variable `$icon-outer-width`.
 */
const ICON_WIDTH = 20;
/**
 * Adjust the width of the title span, so overflow ellipsis work.
 * (2 x `$col-padding-x` + 3px rounding errors).
 */
const TITLE_SPAN_PAD_Y = 7;
/** Render row markup for N nodes above and below the visible viewport. */
const RENDER_MAX_PREFETCH = 5;
/** Regular expression to detect if a string describes an image URL (in contrast
 * to a class name). Strings are considered image urls if they contain '.' or '/'.
 */
const TEST_IMG = new RegExp(/\.|\//);
// export const RECURSIVE_REQUEST_ERROR = "$recursive_request";
// export const INVALID_REQUEST_TARGET_ERROR = "$request_target_invalid";
/**
 * Default node icons.
 * Requires bootstrap icons https://icons.getbootstrap.com
 */
const iconMap = {
    error: "bi bi-exclamation-triangle",
    // loading: "bi bi-hourglass-split wb-busy",
    loading: "bi bi-chevron-right wb-busy",
    // loading: "bi bi-arrow-repeat wb-spin",
    // loading: '<div class="spinner-border spinner-border-sm" role="status"> <span class="visually-hidden">Loading...</span> </div>',
    // noData: "bi bi-search",
    noData: "bi bi-question-circle",
    expanderExpanded: "bi bi-chevron-down",
    // expanderExpanded: "bi bi-dash-square",
    expanderCollapsed: "bi bi-chevron-right",
    // expanderCollapsed: "bi bi-plus-square",
    expanderLazy: "bi bi-chevron-right wb-helper-lazy-expander",
    // expanderLazy: "bi bi-chevron-bar-right",
    checkChecked: "bi bi-check-square",
    checkUnchecked: "bi bi-square",
    checkUnknown: "bi dash-square-dotted",
    radioChecked: "bi bi-circle-fill",
    radioUnchecked: "bi bi-circle",
    radioUnknown: "bi bi-circle-dotted",
    folder: "bi bi-folder2",
    folderOpen: "bi bi-folder2-open",
    folderLazy: "bi bi-folder-symlink",
    doc: "bi bi-file-earmark",
};
/** Dict keys that are evaluated by source loader (others are added to `tree.data` instead). */
const RESERVED_TREE_SOURCE_KEYS = new Set([
    "_format",
    "_keyMap",
    "_positional",
    "_typeList",
    "_version",
    "children",
    "columns",
    "types",
]);
// /** Key codes that trigger grid navigation, even when inside an input element. */
// export const INPUT_BREAKOUT_KEYS: Set<string> = new Set([
//   // "ArrowDown",
//   // "ArrowUp",
//   "Enter",
//   "Escape",
// ]);
/** Map `KeyEvent.key` to navigation action. */
const KEY_TO_ACTION_DICT = {
    " ": "toggleSelect",
    "+": "expand",
    Add: "expand",
    ArrowDown: "down",
    ArrowLeft: "left",
    ArrowRight: "right",
    ArrowUp: "up",
    Backspace: "parent",
    "/": "collapseAll",
    Divide: "collapseAll",
    End: "lastCol",
    Home: "firstCol",
    "Control+End": "last",
    "Control+Home": "first",
    "Meta+ArrowDown": "last",
    "Meta+ArrowUp": "first",
    "*": "expandAll",
    Multiply: "expandAll",
    PageDown: "pageDown",
    PageUp: "pageUp",
    "-": "collapse",
    Subtract: "collapse",
};
/** Return a callback that returns true if the node title matches the string
 * or regular expression.
 * @see {@link WunderbaumNode.findAll}
 */
function makeNodeTitleMatcher(match) {
    if (match instanceof RegExp) {
        return function (node) {
            return match.test(node.title);
        };
    }
    assert(typeof match === "string");
    // s = escapeRegex(s.toLowerCase());
    return function (node) {
        return node.title === match;
        // console.log("match " + node, node.title.toLowerCase().indexOf(match))
        // return node.title.toLowerCase().indexOf(match) >= 0;
    };
}
/** Return a callback that returns true if the node title starts with a string (case-insensitive). */
function makeNodeTitleStartMatcher(s) {
    s = escapeRegex(s);
    const reMatch = new RegExp("^" + s, "i");
    return function (node) {
        return reMatch.test(node.title);
    };
}
/** Compare two nodes by title (case-insensitive). */
function nodeTitleSorter(a, b) {
    const x = a.title.toLowerCase();
    const y = b.title.toLowerCase();
    return x === y ? 0 : x > y ? 1 : -1;
}
function unflattenSource(source) {
    var _a, _b, _c;
    const { _format, _keyMap, _positional, children } = source;
    if (_format !== "flat") {
        throw new Error(`Expected source._format: "flat", but got ${_format}`);
    }
    if (_positional && _positional.includes("children")) {
        throw new Error(`source._positional must not include "children": ${_positional}`);
    }
    // Inverse keyMap:
    let longToShort = {};
    if (_keyMap) {
        for (const [key, value] of Object.entries(_keyMap)) {
            longToShort[value] = key;
        }
    }
    const positionalShort = _positional.map((e) => longToShort[e]);
    const newChildren = [];
    const keyToNodeMap = {};
    const indexToNodeMap = {};
    const keyAttrName = (_a = longToShort["key"]) !== null && _a !== void 0 ? _a : "key";
    const childrenAttrName = (_b = longToShort["children"]) !== null && _b !== void 0 ? _b : "children";
    for (const [index, node] of children.entries()) {
        // Node entry format:
        //   [PARENT_ID, [POSITIONAL_ARGS]]
        // or
        //   [PARENT_ID, [POSITIONAL_ARGS], {KEY_VALUE_ARGS}]
        const [parentId, args, kwargs = {}] = node;
        // Free up some memory as we go
        node[1] = null;
        if (node[2] != null) {
            node[2] = null;
        }
        // console.log("flatten", parentId, args, kwargs)
        // We keep `kwargs` as our new node definition. Then we add all positional
        // values to this object:
        args.forEach((val, positionalIdx) => {
            kwargs[positionalShort[positionalIdx]] = val;
        });
        // Find the parent node. `null` means 'toplevel'. PARENT_ID may be the numeric
        // index of the source.children list. If PARENT_ID is a string, we search
        // a parent with node.key of this value.
        indexToNodeMap[index] = kwargs;
        const key = kwargs[keyAttrName];
        if (key != null) {
            keyToNodeMap[key] = kwargs;
        }
        let parentNode = null;
        if (parentId === null) ;
        else if (typeof parentId === "number") {
            parentNode = indexToNodeMap[parentId];
            if (parentNode === undefined) {
                throw new Error(`unflattenSource: Could not find parent node by index: ${parentId}.`);
            }
        }
        else {
            parentNode = keyToNodeMap[parentId];
            if (parentNode === undefined) {
                throw new Error(`unflattenSource: Could not find parent node by key: ${parentId}`);
            }
        }
        if (parentNode) {
            (_c = parentNode[childrenAttrName]) !== null && _c !== void 0 ? _c : (parentNode[childrenAttrName] = []);
            parentNode[childrenAttrName].push(kwargs);
        }
        else {
            newChildren.push(kwargs);
        }
    }
    delete source.children;
    source.children = newChildren;
}
function inflateSourceData(source) {
    const { _format, _keyMap, _typeList } = source;
    if (_format === "flat") {
        unflattenSource(source);
    }
    delete source._format;
    delete source._version;
    delete source._keyMap;
    delete source._typeList;
    delete source._positional;
    function _iter(childList) {
        for (let node of childList) {
            // Expand short alias names
            if (_keyMap) {
                // Iterate over a list of names, because we modify inside the loop:
                Object.getOwnPropertyNames(node).forEach((propName) => {
                    var _a;
                    const long = (_a = _keyMap[propName]) !== null && _a !== void 0 ? _a : propName;
                    if (long !== propName) {
                        node[long] = node[propName];
                        delete node[propName];
                    }
                });
            }
            // `node` now has long attribute names
            // Resolve node type indexes
            const type = node.type;
            if (_typeList && type != null && typeof type === "number") {
                const newType = _typeList[type];
                if (newType == null) {
                    throw new Error(`Expected typeList[${type}] entry in [${_typeList}]`);
                }
                node.type = newType;
            }
            // Recursion
            if (node.children) {
                _iter(node.children);
            }
        }
    }
    _iter(source.children);
}

/*!
 * Wunderbaum - ext-dnd
 * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.
 * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)
 */
const nodeMimeType = "application/x-wunderbaum-node";
class DndExtension extends WunderbaumExtension {
    constructor(tree) {
        super(tree, "dnd", {
            autoExpandMS: 1500,
            // dropMarkerInsertOffsetX: -16, // Additional offset for drop-marker with hitMode = "before"/"after"
            // dropMarkerOffsetX: -24, // Absolute position offset for .fancytree-drop-marker relatively to ..fancytree-title (icon/img near a node accepting drop)
            // #1021 `document.body` is not available yet
            // dropMarkerParent: "body", // Root Container used for drop marker (could be a shadow root)
            multiSource: false,
            effectAllowed: "all",
            // dropEffect: "auto", // 'copy'|'link'|'move'|'auto'(calculate from `effectAllowed`+modifier keys) or callback(node, data) that returns such string.
            dropEffectDefault: "move",
            preventForeignNodes: false,
            preventLazyParents: true,
            preventNonNodes: false,
            preventRecursion: true,
            preventSameParent: false,
            preventVoidMoves: true,
            scroll: true,
            scrollSensitivity: 20,
            scrollSpeed: 5,
            // setTextTypeJson: false, // Allow dragging of nodes to different IE windows
            sourceCopyHook: null,
            // Events (drag support)
            dragStart: null,
            dragDrag: null,
            dragEnd: null,
            // Events (drop support)
            dragEnter: null,
            dragOver: null,
            dragExpand: null,
            dragDrop: null,
            dragLeave: null, // Callback(targetNode, data)
        });
        // public dropMarkerElem?: HTMLElement;
        this.srcNode = null;
        this.lastTargetNode = null;
        this.lastEnterStamp = 0;
        this.lastAllowedDropRegions = null;
        this.lastDropEffect = null;
        this.lastDropRegion = false;
    }
    init() {
        super.init();
        // Store the current scroll parent, which may be the tree
        // container, any enclosing div, or the document.
        // #761: scrollParent() always needs a container child
        // $temp = $("<span>").appendTo(this.$container);
        // this.$scrollParent = $temp.scrollParent();
        // $temp.remove();
        const tree = this.tree;
        const dndOpts = tree.options.dnd;
        // Enable drag support if dragStart() is specified:
        if (dndOpts.dragStart) {
            onEvent(tree.element, "dragstart drag dragend", this.onDragEvent.bind(this));
        }
        // Enable drop support if dragEnter() is specified:
        if (dndOpts.dragEnter) {
            onEvent(tree.element, "dragenter dragover dragleave drop", this.onDropEvent.bind(this));
        }
    }
    /** Cleanup classes after target node is no longer hovered. */
    _leaveNode() {
        // We remove the marker on dragenter from the previous target:
        const ltn = this.lastTargetNode;
        this.lastEnterStamp = 0;
        if (ltn) {
            ltn.setClass("wb-drop-target wb-drop-over wb-drop-after wb-drop-before", false);
            this.lastTargetNode = null;
        }
    }
    /** */
    unifyDragover(res) {
        if (res === false) {
            return false;
        }
        else if (res instanceof Set) {
            return res.size > 0 ? res : false;
        }
        else if (res === true) {
            return new Set(["over", "before", "after"]);
        }
        else if (typeof res === "string" || isArray(res)) {
            res = toSet(res);
            return res.size > 0 ? res : false;
        }
        throw new Error("Unsupported drop region definition: " + res);
    }
    /** */
    _calcDropRegion(e, allowed) {
        const dy = e.offsetY;
        if (!allowed) {
            return false;
        }
        else if (allowed.size === 3) {
            return dy < 0.25 * ROW_HEIGHT
                ? "before"
                : dy > 0.75 * ROW_HEIGHT
                    ? "after"
                    : "over";
        }
        else if (allowed.size === 1 && allowed.has("over")) {
            return "over";
        }
        else {
            // Only 'before' and 'after':
            return dy > ROW_HEIGHT / 2 ? "after" : "before";
        }
        // return "over";
    }
    /* Implement auto scrolling when drag cursor is in top/bottom area of scroll parent. */
    autoScroll(event) {
        let tree = this.tree, dndOpts = tree.options.dnd, sp = tree.listContainerElement, sensitivity = dndOpts.scrollSensitivity, speed = dndOpts.scrollSpeed, scrolled = 0;
        const scrollTop = sp.offsetTop;
        if (scrollTop + sp.offsetHeight - event.pageY < sensitivity) {
            const delta = sp.scrollHeight - sp.clientHeight - scrollTop;
            if (delta > 0) {
                sp.scrollTop = scrolled = scrollTop + speed;
            }
        }
        else if (scrollTop > 0 && event.pageY - scrollTop < sensitivity) {
            sp.scrollTop = scrolled = scrollTop - speed;
        }
        // if (scrolled) {
        //   tree.logDebug("autoScroll: " + scrolled + "px");
        // }
        return scrolled;
    }
    onDragEvent(e) {
        // const tree = this.tree;
        const dndOpts = this.treeOpts.dnd;
        const srcNode = Wunderbaum.getNode(e);
        if (!srcNode) {
            return;
        }
        if (e.type !== "drag") {
            this.tree.logDebug("onDragEvent." + e.type + ", srcNode: " + srcNode, e);
        }
        // --- dragstart ---
        if (e.type === "dragstart") {
            // Set a default definition of allowed effects
            e.dataTransfer.effectAllowed = dndOpts.effectAllowed; //"copyMove"; // "all";
            if (srcNode.isEditing()) {
                srcNode.logDebug("Prevented dragging node in edit mode.");
                e.preventDefault();
                return false;
            }
            // Let user cancel the drag operation, override effectAllowed, etc.:
            const res = srcNode._callEvent("dnd.dragStart", { event: e });
            if (!res) {
                e.preventDefault();
                return false;
            }
            let nodeData = srcNode.toDict(true, (n) => {
                // We don't want to re-use the key on drop:
                n._org_key = n.key;
                delete n.key;
            });
            nodeData.treeId = srcNode.tree.id;
            const json = JSON.stringify(nodeData);
            e.dataTransfer.setData(nodeMimeType, json);
            // e.dataTransfer!.setData("text/html", $(node.span).html());
            e.dataTransfer.setData("text/plain", srcNode.title);
            this.srcNode = srcNode;
            setTimeout(() => {
                // Decouple this call, so the CSS is applied to the node, but not to
                // the system generated drag image
                srcNode.setClass("wb-drag-source");
            }, 0);
            // --- drag ---
        }
        else if (e.type === "drag") ;
        else if (e.type === "dragend") {
            srcNode.setClass("wb-drag-source", false);
            this.srcNode = null;
            if (this.lastTargetNode) {
                this._leaveNode();
            }
        }
        return true;
    }
    onDropEvent(e) {
        // const isLink = event.dataTransfer.types.includes("text/uri-list");
        const srcNode = this.srcNode;
        const srcTree = srcNode ? srcNode.tree : null;
        const targetNode = Wunderbaum.getNode(e);
        const dndOpts = this.treeOpts.dnd;
        const dt = e.dataTransfer;
        if (!targetNode) {
            this._leaveNode();
            return;
        }
        if (!["dragenter", "dragover", "dragleave"].includes(e.type)) {
            this.tree.logDebug("onDropEvent." +
                e.type +
                " targetNode: " +
                targetNode +
                ", ea: " +
                (dt === null || dt === void 0 ? void 0 : dt.effectAllowed) +
                ", de: " +
                (dt === null || dt === void 0 ? void 0 : dt.dropEffect), ", cy: " + e.offsetY, ", r: " + this._calcDropRegion(e, this.lastAllowedDropRegions), e);
        }
        // --- dragenter ---
        if (e.type === "dragenter") {
            this.lastAllowedDropRegions = null;
            // `dragleave` is not reliable with event delegation, so we generate it
            // from dragenter:
            if (this.lastTargetNode && this.lastTargetNode !== targetNode) {
                this._leaveNode();
            }
            this.lastTargetNode = targetNode;
            this.lastEnterStamp = Date.now();
            if (
            // Don't drop on status node:
            targetNode.isStatusNode() ||
                // Prevent dropping nodes from different Wunderbaum trees:
                (dndOpts.preventForeignNodes && targetNode.tree !== srcTree) ||
                // Prevent dropping items on unloaded lazy Wunderbaum tree nodes:
                (dndOpts.preventLazyParents && !targetNode.isLoaded()) ||
                // Prevent dropping items other than Wunderbaum tree nodes:
                (dndOpts.preventNonNodes && !srcNode) ||
                // Prevent dropping nodes on own descendants:
                (dndOpts.preventRecursion &&
                    srcNode &&
                    srcNode.isAncestorOf(targetNode)) ||
                // Prevent dropping nodes under same direct parent:
                (dndOpts.preventSameParent &&
                    srcNode &&
                    targetNode.parent === srcNode.parent) ||
                // Don't allow void operation ('drop on self'): TODO: should be checke onn  move only
                (dndOpts.preventVoidMoves && targetNode === srcNode)) {
                dt.dropEffect = "none";
                return true; // Prevent drop operation
            }
            // User may return a set of regions (or `false` to prevent drop)
            let regionSet = targetNode._callEvent("dnd.dragEnter", { event: e });
            //
            regionSet = this.unifyDragover(regionSet);
            if (!regionSet) {
                dt.dropEffect = "none";
                return true; // Prevent drop operation
            }
            this.lastAllowedDropRegions = regionSet;
            this.lastDropEffect = dt.dropEffect;
            targetNode.setClass("wb-drop-target");
            e.preventDefault(); // Allow drop (Drop operation is denied by default)
            return false;
            // --- dragover ---
        }
        else if (e.type === "dragover") {
            this.autoScroll(e);
            const region = this._calcDropRegion(e, this.lastAllowedDropRegions);
            this.lastDropRegion = region;
            if (dndOpts.autoExpandMS > 0 &&
                targetNode.isExpandable(true) &&
                !targetNode._isLoading &&
                Date.now() - this.lastEnterStamp > dndOpts.autoExpandMS &&
                targetNode._callEvent("dnd.dragExpand", { event: e }) !== false) {
                targetNode.setExpanded();
            }
            if (!region) {
                return; // We already rejected in dragenter
            }
            targetNode.setClass("wb-drop-over", region === "over");
            targetNode.setClass("wb-drop-before", region === "before");
            targetNode.setClass("wb-drop-after", region === "after");
            // console.log("dragover", e);
            // dt.dropEffect = this.lastDropEffect!;
            e.preventDefault(); // Allow drop (Drop operation is denied by default)
            return false;
            // --- dragleave ---
        }
        else if (e.type === "dragleave") ;
        else if (e.type === "drop") {
            e.stopPropagation(); // prevent browser from opening links?
            this._leaveNode();
            const region = this.lastDropRegion;
            targetNode._callEvent("dnd.drop", {
                event: e,
                region: region,
                defaultDropMode: region === "over" ? "appendChild" : region,
                sourceNode: this.srcNode,
            });
        }
    }
}

/*!
 * Wunderbaum - drag_observer
 * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.
 * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)
 */
/**
 * Convert mouse- and touch events to 'dragstart', 'drag', and 'dragstop'.
 */
class DragObserver {
    constructor(opts) {
        this.start = {
            x: 0,
            y: 0,
            altKey: false,
            ctrlKey: false,
            metaKey: false,
            shiftKey: false,
        };
        this.dragElem = null;
        this.dragging = false;
        // TODO: touch events
        this.events = ["mousedown", "mouseup", "mousemove", "keydown"];
        if (!opts.root) {
            throw new Error("Missing `root` option.");
        }
        this.opts = Object.assign({ thresh: 5 }, opts);
        this.root = opts.root;
        this._handler = this.handleEvent.bind(this);
        this.events.forEach((type) => {
            this.root.addEventListener(type, this._handler);
        });
    }
    /** Unregister all event listeners. */
    disconnect() {
        this.events.forEach((type) => {
            this.root.removeEventListener(type, this._handler);
        });
    }
    getDragElem() {
        return this.dragElem;
    }
    isDragging() {
        return this.dragging;
    }
    stopDrag(cb_event) {
        if (this.dragging && this.opts.dragstop && cb_event) {
            cb_event.type = "dragstop";
            this.opts.dragstop(cb_event);
        }
        this.dragElem = null;
        this.dragging = false;
    }
    handleEvent(e) {
        const type = e.type;
        const opts = this.opts;
        const cb_event = {
            type: e.type,
            event: e,
            dragElem: this.dragElem,
            dx: e.pageX - this.start.x,
            dy: e.pageY - this.start.y,
            apply: undefined,
        };
        switch (type) {
            case "keydown":
                this.stopDrag(cb_event);
                break;
            case "mousedown":
                if (this.dragElem) {
                    this.stopDrag(cb_event);
                    break;
                }
                if (opts.selector) {
                    let elem = e.target;
                    if (elem.matches(opts.selector)) {
                        this.dragElem = elem;
                    }
                    else {
                        elem = elem.closest(opts.selector);
                        if (elem) {
                            this.dragElem = elem;
                        }
                        else {
                            break; // no event delegation selector matched
                        }
                    }
                }
                this.start.x = e.pageX;
                this.start.y = e.pageY;
                this.start.altKey = e.altKey;
                this.start.ctrlKey = e.ctrlKey;
                this.start.metaKey = e.metaKey;
                this.start.shiftKey = e.shiftKey;
                break;
            case "mousemove":
                // TODO: debounce/throttle?
                // TODO: horizontal mode: ignore if dx unchanged
                if (!this.dragElem) {
                    break;
                }
                if (!this.dragging) {
                    if (opts.thresh) {
                        const dist2 = cb_event.dx * cb_event.dx + cb_event.dy * cb_event.dy;
                        if (dist2 < opts.thresh * opts.thresh) {
                            break;
                        }
                    }
                    cb_event.type = "dragstart";
                    if (opts.dragstart(cb_event) === false) {
                        this.stopDrag(cb_event);
                        break;
                    }
                    this.dragging = true;
                }
                if (this.dragging && this.opts.drag) {
                    cb_event.type = "drag";
                    this.opts.drag(cb_event);
                }
                break;
            case "mouseup":
                if (!this.dragging) {
                    this.stopDrag(cb_event);
                    break;
                }
                if (e.button === 0) {
                    cb_event.apply = true;
                }
                else {
                    cb_event.apply = false;
                }
                this.stopDrag(cb_event);
                break;
        }
    }
}

/*!
 * Wunderbaum - ext-grid
 * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.
 * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)
 */
class GridExtension extends WunderbaumExtension {
    constructor(tree) {
        super(tree, "grid", {
        // throttle: 200,
        });
        this.observer = new DragObserver({
            root: window.document,
            selector: "span.wb-col-resizer",
            thresh: 4,
            // throttle: 400,
            dragstart: (e) => {
                return this.tree.element.contains(e.dragElem);
            },
            drag: (e) => {
                // TODO: throttle
                return this.handleDrag(e);
            },
            dragstop: (e) => {
                return this.handleDrag(e);
            },
        });
    }
    init() {
        super.init();
    }
    handleDrag(e) {
        const info = Wunderbaum.getEventInfo(e.event);
        // this.tree.options.
        this.tree.log(`${e.type}(${e.dx})`, e, info);
    }
}

/*!
 * Wunderbaum - deferred
 * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.
 * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)
 */
/**
 * Implement a ES6 Promise, that exposes a resolve() and reject() method.
 *
 * Loosely mimics {@link https://api.jquery.com/category/deferred-object/ | jQuery.Deferred}.
 * Example:
 * ```js
 * function foo() {
 *   let dfd = new Deferred(),
 *   ...
 *   dfd.resolve('foo')
 *   ...
 *   return dfd.promise();
 * }
 * ```
 */
class Deferred {
    constructor() {
        this._promise = new Promise((resolve, reject) => {
            this._resolve = resolve;
            this._reject = reject;
        });
    }
    /** Resolve the [[Promise]]. */
    resolve(value) {
        this._resolve(value);
    }
    /** Reject the [[Promise]]. */
    reject(reason) {
        this._reject(reason);
    }
    /** Return the native [[Promise]] instance.*/
    promise() {
        return this._promise;
    }
    /** Call [[Promise.then]] on the embedded promise instance.*/
    then(cb) {
        return this._promise.then(cb);
    }
    /** Call [[Promise.catch]] on the embedded promise instance.*/
    catch(cb) {
        return this._promise.catch(cb);
    }
    /** Call [[Promise.finally]] on the embedded promise instance.*/
    finally(cb) {
        return this._promise.finally(cb);
    }
}

/*!
 * Wunderbaum - wunderbaum_node
 * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.
 * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)
 */
/** Top-level properties that can be passed with `data`. */
const NODE_PROPS = new Set([
    // TODO: use NODE_ATTRS instead?
    "classes",
    "expanded",
    "icon",
    "key",
    "lazy",
    "refKey",
    "selected",
    "title",
    "tooltip",
    "type",
]);
const NODE_ATTRS = new Set([
    "checkbox",
    "expanded",
    "classes",
    "folder",
    "icon",
    "iconTooltip",
    "key",
    "lazy",
    "partsel",
    "radiogroup",
    "refKey",
    "selected",
    "statusNodeType",
    "title",
    "tooltip",
    "type",
    "unselectable",
    "unselectableIgnore",
    "unselectableStatus",
]);
/**
 * A single tree node.
 *
 * **NOTE:** <br>
 * Generally you should not modify properties directly, since this may break
 * the internal bookkeeping.
 */
class WunderbaumNode {
    constructor(tree, parent, data) {
        var _a, _b;
        /** Reference key. Unlike {@link key}, a `refKey` may occur multiple
         * times within a tree (in this case we have 'clone nodes').
         * @see Use {@link setKey} to modify.
         */
        this.refKey = undefined;
        this.children = null;
        this.lazy = false;
        /** Expansion state.
         * @see {@link isExpandable}, {@link isExpanded}, {@link setExpanded}. */
        this.expanded = false;
        /** Selection state.
         * @see {@link isSelected}, {@link setSelected}. */
        this.selected = false;
        /** Additional classes added to `div.wb-row`.
         * @see {@link hasClass}, {@link setClass}. */
        this.classes = null; //new Set<string>();
        /** Custom data that was passed to the constructor */
        this.data = {};
        this._isLoading = false;
        this._requestId = 0;
        this._errorInfo = null;
        this._partsel = false;
        this._partload = false;
        this.subMatchCount = 0;
        this._rowIdx = 0;
        this._rowElem = undefined;
        assert(!parent || parent.tree === tree);
        assert(!data.children);
        this.tree = tree;
        this.parent = parent;
        this.key = "" + ((_a = data.key) !== null && _a !== void 0 ? _a : ++WunderbaumNode.sequence);
        this.title = "" + ((_b = data.title) !== null && _b !== void 0 ? _b : "<" + this.key + ">");
        data.refKey != null ? (this.refKey = "" + data.refKey) : 0;
        data.statusNodeType != null
            ? (this.statusNodeType = "" + data.statusNodeType)
            : 0;
        data.type != null ? (this.type = "" + data.type) : 0;
        data.checkbox != null ? (this.checkbox = !!data.checkbox) : 0;
        data.colspan != null ? (this.colspan = !!data.colspan) : 0;
        this.expanded = data.expanded === true;
        data.icon != null ? (this.icon = data.icon) : 0;
        this.lazy = data.lazy === true;
        this.selected = data.selected === true;
        if (data.classes) {
            this.setClass(data.classes);
        }
        // Store custom fields as `node.data`
        for (const [key, value] of Object.entries(data)) {
            if (!NODE_PROPS.has(key)) {
                this.data[key] = value;
            }
        }
        if (parent && !this.statusNodeType) {
            // Don't register root node or status nodes
            tree._registerNode(this);
        }
    }
    /**
     * Return readable string representation for this instance.
     * @internal
     */
    toString() {
        return `WunderbaumNode@${this.key}<'${this.title}'>`;
    }
    /**
     * Iterate all descendant nodes depth-first, pre-order using `for ... of ...` syntax.
     * More concise, but slightly slower than {@link WunderbaumNode.visit}.
     *
     * Example:
     * ```js
     * for(const n of node) {
     *   ...
     * }
     * ```
     */
    *[Symbol.iterator]() {
        // let node: WunderbaumNode | null = this;
        const cl = this.children;
        if (cl) {
            for (let i = 0, l = cl.length; i < l; i++) {
                const n = cl[i];
                yield n;
                if (n.children) {
                    yield* n;
                }
            }
            // Slower:
            // for (let node of this.children) {
            //   yield node;
            //   yield* node : 0;
            // }
        }
    }
    // /** Return an option value. */
    // protected _getOpt(
    //   name: string,
    //   nodeObject: any = null,
    //   treeOptions: any = null,
    //   defaultValue: any = null
    // ): any {
    //   return evalOption(
    //     name,
    //     this,
    //     nodeObject || this,
    //     treeOptions || this.tree.options,
    //     defaultValue
    //   );
    // }
    /** Call event handler if defined in tree.options.
     * Example:
     * ```js
     * node._callEvent("edit.beforeEdit", {foo: 42})
     * ```
     */
    _callEvent(type, extra) {
        return this.tree._callEvent(type, extend({
            node: this,
            typeInfo: this.type ? this.tree.types[this.type] : {},
        }, extra));
    }
    /**
     * Append (or insert) a list of child nodes.
     *
     * Tip: pass `{ before: 0 }` to prepend new nodes as first children.
     *
     * @returns first child added
     */
    addChildren(nodeData, options) {
        const tree = this.tree;
        let { before = null, applyMinExpanLevel = true, _level } = options !== null && options !== void 0 ? options : {};
        // let { before, loadLazy=true, _level } = options ?? {};
        // const isTopCall = _level == null;
        _level !== null && _level !== void 0 ? _level : (_level = this.getLevel());
        const nodeList = [];
        try {
            tree.enableUpdate(false);
            if (isPlainObject(nodeData)) {
                nodeData = [nodeData];
            }
            const forceExpand = applyMinExpanLevel && _level < tree.options.minExpandLevel;
            for (let child of nodeData) {
                const subChildren = child.children;
                delete child.children;
                const n = new WunderbaumNode(tree, this, child);
                if (forceExpand && !n.isUnloaded()) {
                    n.expanded = true;
                }
                nodeList.push(n);
                if (subChildren) {
                    n.addChildren(subChildren, { _level: _level + 1 });
                }
            }
            if (!this.children) {
                this.children = nodeList;
            }
            else if (before == null || this.children.length === 0) {
                this.children = this.children.concat(nodeList);
            }
            else {
                // Returns null if before is not a direct child:
                before = this.findDirectChild(before);
                let pos = this.children.indexOf(before);
                assert(pos >= 0, `options.before must be a direct child of ${this}`);
                // insert nodeList after children[pos]
                this.children.splice(pos, 0, ...nodeList);
            }
            // TODO:
            // if (tree.options.selectMode === 3) {
            //   this.fixSelection3FromEndNodes();
            // }
            // this.triggerModifyChild("add", nodeList.length === 1 ? nodeList[0] : null);
            tree.setModified(ChangeType.structure);
        }
        finally {
            tree.enableUpdate(true);
        }
        // if(isTopCall && loadLazy){
        //   this.logWarn("addChildren(): loadLazy is not yet implemented.")
        // }
        return nodeList[0];
    }
    /**
     * Append or prepend a node, or append a child node.
     *
     * This a convenience function that calls addChildren()
     *
     * @param nodeData node definition
     * @param [mode=child] 'before', 'after', 'firstChild', or 'child' ('over' is a synonym for 'child')
     * @returns new node
     */
    addNode(nodeData, mode = "appendChild") {
        if (mode === "over") {
            mode = "appendChild"; // compatible with drop region
        }
        switch (mode) {
            case "after":
                return this.parent.addChildren(nodeData, {
                    before: this.getNextSibling(),
                });
            case "before":
                return this.parent.addChildren(nodeData, { before: this });
            case "prependChild":
                // Insert before the first child if any
                // let insertBefore = this.children ? this.children[0] : undefined;
                return this.addChildren(nodeData, { before: 0 });
            case "appendChild":
                return this.addChildren(nodeData);
        }
        assert(false, "Invalid mode: " + mode);
        return undefined;
    }
    /**
     * Apply a modification (or navigation) operation.
     *
     * @see {@link Wunderbaum.applyCommand}
     */
    applyCommand(cmd, options) {
        return this.tree.applyCommand(cmd, this, options);
    }
    /**
     * Add/remove one or more classes to `<div class='wb-row'>`.
     *
     * This also maintains `node.classes`, so the class will survive a re-render.
     *
     * @param className one or more class names. Multiple classes can be passed
     *     as space-separated string, array of strings, or set of strings.
     */
    setClass(className, flag = true) {
        const cnSet = toSet(className);
        if (flag) {
            if (this.classes === null) {
                this.classes = new Set();
            }
            cnSet.forEach((cn) => {
                var _a;
                this.classes.add(cn);
                (_a = this._rowElem) === null || _a === void 0 ? void 0 : _a.classList.toggle(cn, flag);
            });
        }
        else {
            if (this.classes === null) {
                return;
            }
            cnSet.forEach((cn) => {
                var _a;
                this.classes.delete(cn);
                (_a = this._rowElem) === null || _a === void 0 ? void 0 : _a.classList.toggle(cn, flag);
            });
            if (this.classes.size === 0) {
                this.classes = null;
            }
        }
    }
    /** Call `setExpanded()` on all descendant nodes. */
    async expandAll(flag = true, options) {
        const tree = this.tree;
        const minExpandLevel = this.tree.options.minExpandLevel;
        let { depth = 99, loadLazy, force } = options !== null && options !== void 0 ? options : {};
        const expand_opts = {
            scrollIntoView: false,
            force: force,
            loadLazy: loadLazy,
        };
        // this.logInfo(`expandAll(${flag})`);
        // Expand all direct children in parallel:
        async function _iter(n, level) {
            var _a;
            // n.logInfo(`  _iter(${level})`);
            if (level === 0) {
                return;
            }
            // if (!flag && minExpandLevel && !force && n.getLevel() <= minExpandLevel) {
            //   return; // Do not collapse until minExpandLevel
            // }
            const level_1 = level == null ? null : level - 1;
            const promises = [];
            (_a = n.children) === null || _a === void 0 ? void 0 : _a.forEach((cn) => {
                if (flag) {
                    if (!cn.expanded && (cn.children || (loadLazy && cn.lazy))) {
                        // Node is collapsed and may be expanded (i.e. has children or is lazy)
                        // Expanding may be async, so we store the promise.
                        // Also the recursion is delayed until expansion finished.
                        const p = cn.setExpanded(true, expand_opts);
                        promises.push(p);
                        p.then(async () => {
                            await _iter(cn, level_1);
                        });
                    }
                    else {
                        // We don't expand the node, but still visit descendants.
                        // There we may find lazy nodes, so we
                        promises.push(_iter(cn, level_1));
                    }
                }
                else {
                    // Collapsing is always synchronous, so no promises required
                    if (!minExpandLevel || force || cn.getLevel() > minExpandLevel) {
                        // Do not collapse until minExpandLevel
                        cn.setExpanded(false, expand_opts);
                    }
                    _iter(cn, level_1); // recursion, even if cn was already collapsed
                }
            });
            return new Promise((resolve) => {
                Promise.all(promises).then(() => {
                    resolve(true);
                });
            });
        }
        const tag = tree.logTime(`${this}.expandAll(${flag})`);
        try {
            tree.enableUpdate(false);
            await _iter(this, depth);
        }
        finally {
            tree.enableUpdate(true);
            tree.logTimeEnd(tag);
        }
    }
    /**
     * Find all descendant nodes that match condition (excluding self).
     *
     * If `match` is a string, search for exact node title.
     * If `match` is a RegExp expression, apply it to node.title, using
     * [RegExp.test()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test).
     * If `match` is a callback, match all nodes for that the callback(node) returns true.
     *
     * Returns an empty array if no nodes were found.
     *
     * Examples:
     * ```js
     * // Match all node titles that match exactly 'Joe':
     * nodeList = node.findAll("Joe")
     * // Match all node titles that start with 'Joe' case sensitive:
     * nodeList = node.findAll(/^Joe/)
     * // Match all node titles that contain 'oe', case insensitive:
     * nodeList = node.findAll(/oe/i)
     * // Match all nodes with `data.price` >= 99:
     * nodeList = node.findAll((n) => {
     *   return n.data.price >= 99;
     * })
     * ```
     */
    findAll(match) {
        const matcher = typeof match === "function" ? match : makeNodeTitleMatcher(match);
        const res = [];
        this.visit((n) => {
            if (matcher(n)) {
                res.push(n);
            }
        });
        return res;
    }
    /** Return the direct child with a given key, index or null. */
    findDirectChild(ptr) {
        let cl = this.children;
        if (!cl)
            return null;
        if (typeof ptr === "string") {
            for (let i = 0, l = cl.length; i < l; i++) {
                if (cl[i].key === ptr) {
                    return cl[i];
                }
            }
        }
        else if (typeof ptr === "number") {
            return cl[ptr];
        }
        else if (ptr.parent === this) {
            // Return null if `ptr` is not a direct child
            return ptr;
        }
        return null;
    }
    /**
     * Find first descendant node that matches condition (excluding self) or null.
     *
     * @see {@link WunderbaumNode.findAll} for examples.
     */
    findFirst(match) {
        const matcher = typeof match === "function" ? match : makeNodeTitleMatcher(match);
        let res = null;
        this.visit((n) => {
            if (matcher(n)) {
                res = n;
                return false;
            }
        });
        return res;
    }
    /** Find a node relative to self.
     *
     * @see {@link Wunderbaum.findRelatedNode|tree.findRelatedNode()}
     */
    findRelatedNode(where, includeHidden = false) {
        return this.tree.findRelatedNode(this, where, includeHidden);
    }
    /**
     * Iterator version of {@link WunderbaumNode.format}.
     */
    *format_iter(name_cb, connectors) {
        connectors !== null && connectors !== void 0 ? connectors : (connectors = ["    ", " |  ", "  ", "  "]);
        name_cb !== null && name_cb !== void 0 ? name_cb : (name_cb = (node) => "" + node);
        function _is_last(node) {
            const ca = node.parent.children;
            return node === ca[ca.length - 1];
        }
        const _format_line = (node) => {
            // https://www.measurethat.net/Benchmarks/Show/12196/0/arr-unshift-vs-push-reverse-small-array
            const parts = [name_cb(node)];
            parts.unshift(connectors[_is_last(node) ? 2 : 3]);
            let p = node.parent;
            while (p && p !== this) {
                // `this` is the top node
                parts.unshift(connectors[_is_last(p) ? 0 : 1]);
                p = p.parent;
            }
            return parts.join("");
        };
        yield name_cb(this);
        for (let node of this) {
            yield _format_line(node);
        }
    }
    /**
     * Return a multiline string representation of a node/subnode hierarchy.
     * Mostly useful for debugging.
     *
     * Example:
     * ```js
     * console.info(tree.getActiveNode().format((n)=>n.title));
     * ```
     * logs
     * ```
     * Books
     *   Art of War
     *   Don Quixote
     * ```
     * @see {@link WunderbaumNode.format_iter}
     */
    format(name_cb, connectors) {
        const a = [];
        for (let line of this.format_iter(name_cb, connectors)) {
            a.push(line);
        }
        return a.join("\n");
    }
    /** Return the `<span class='wb-col'>` element with a given index or id.
     * @returns {WunderbaumNode | null}
     */
    getColElem(colIdx) {
        var _a;
        if (typeof colIdx === "string") {
            colIdx = this.tree.columns.findIndex((value) => value.id === colIdx);
        }
        const colElems = (_a = this._rowElem) === null || _a === void 0 ? void 0 : _a.querySelectorAll("span.wb-col");
        return colElems ? colElems[colIdx] : null;
    }
    /** Return the first child node or null.
     * @returns {WunderbaumNode | null}
     */
    getFirstChild() {
        return this.children ? this.children[0] : null;
    }
    /** Return the last child node or null.
     * @returns {WunderbaumNode | null}
     */
    getLastChild() {
        return this.children ? this.children[this.children.length - 1] : null;
    }
    /** Return node depth (starting with 1 for top level nodes). */
    getLevel() {
        let i = 0, p = this.parent;
        while (p) {
            i++;
            p = p.parent;
        }
        return i;
    }
    /** Return the successive node (under the same parent) or null. */
    getNextSibling() {
        let ac = this.parent.children;
        let idx = ac.indexOf(this);
        return ac[idx + 1] || null;
    }
    /** Return the parent node (null for the system root node). */
    getParent() {
        // TODO: return null for top-level nodes?
        return this.parent;
    }
    /** Return an array of all parent nodes (top-down).
     * @param includeRoot Include the invisible system root node.
     * @param includeSelf Include the node itself.
     */
    getParentList(includeRoot = false, includeSelf = false) {
        let l = [], dtn = includeSelf ? this : this.parent;
        while (dtn) {
            if (includeRoot || dtn.parent) {
                l.unshift(dtn);
            }
            dtn = dtn.parent;
        }
        return l;
    }
    /** Return a string representing the hierachical node path, e.g. "a/b/c".
     * @param includeSelf
     * @param node property name or callback
     * @param separator
     */
    getPath(includeSelf = true, part = "title", separator = "/") {
        // includeSelf = includeSelf !== false;
        // part = part || "title";
        // separator = separator || "/";
        let val, path = [], isFunc = typeof part === "function";
        this.visitParents((n) => {
            if (n.parent) {
                val = isFunc
                    ? part(n)
                    : n[part];
                path.unshift(val);
            }
            return undefined; // TODO remove this line
        }, includeSelf);
        return path.join(separator);
    }
    /** Return the preceeding node (under the same parent) or null. */
    getPrevSibling() {
        let ac = this.parent.children;
        let idx = ac.indexOf(this);
        return ac[idx - 1] || null;
    }
    /** Return true if node has children.
     * Return undefined if not sure, i.e. the node is lazy and not yet loaded.
     */
    hasChildren() {
        if (this.lazy) {
            if (this.children == null) {
                return undefined; // null or undefined: Not yet loaded
            }
            else if (this.children.length === 0) {
                return false; // Loaded, but response was empty
            }
            else if (this.children.length === 1 &&
                this.children[0].isStatusNode()) {
                return undefined; // Currently loading or load error
            }
            return true; // One or more child nodes
        }
        return !!(this.children && this.children.length);
    }
    /** Return true if node has className set. */
    hasClass(className) {
        return this.classes ? this.classes.has(className) : false;
    }
    /** Return true if this node is the currently active tree node. */
    isActive() {
        return this.tree.activeNode === this;
    }
    /** Return true if this node is a direct or indirect parent of `other`.
     * (See also [[isParentOf]].)
     */
    isAncestorOf(other) {
        return other && other.isDescendantOf(this);
    }
    /** Return true if this node is a **direct** subnode of `other`.
     * (See also [[isDescendantOf]].)
     */
    isChildOf(other) {
        return other && this.parent === other;
    }
    /** Return true if this node's title spans all columns, i.e. the node has no
     * grid cells.
     */
    isColspan() {
        return !!this.getOption("colspan");
    }
    /** Return true if this node is a direct or indirect subnode of `other`.
     * (See also [[isChildOf]].)
     */
    isDescendantOf(other) {
        if (!other || other.tree !== this.tree) {
            return false;
        }
        var p = this.parent;
        while (p) {
            if (p === other) {
                return true;
            }
            if (p === p.parent) {
                error(`Recursive parent link: ${p}`);
            }
            p = p.parent;
        }
        return false;
    }
    /** Return true if this node has children, i.e. the node is generally expandable.
     * If `andCollapsed` is set, we also check if this node is collapsed, i.e.
     * an expand operation is currently possible.
     */
    isExpandable(andCollapsed = false) {
        // `false` is never expandable (unoffical)
        if ((andCollapsed && this.expanded) || this.children === false) {
            return false;
        }
        if (this.children == null) {
            return this.lazy; // null or undefined can trigger lazy load
        }
        if (this.children.length === 0) {
            return !!this.tree.options.emptyChildListExpandable;
        }
        return true;
    }
    /** Return true if this node is currently in edit-title mode. */
    isEditing() {
        return this.tree._callMethod("edit.isEditingTitle", this);
    }
    /** Return true if this node is currently expanded. */
    isExpanded() {
        return !!this.expanded;
    }
    /** Return true if this node is the first node of its parent's children. */
    isFirstSibling() {
        var p = this.parent;
        return !p || p.children[0] === this;
    }
    /** Return true if this node is the last node of its parent's children. */
    isLastSibling() {
        var p = this.parent;
        return !p || p.children[p.children.length - 1] === this;
    }
    /** Return true if this node is lazy (even if data was already loaded) */
    isLazy() {
        return !!this.lazy;
    }
    /** Return true if node is lazy and loaded. For non-lazy nodes always return true. */
    isLoaded() {
        return !this.lazy || this.hasChildren() !== undefined; // Also checks if the only child is a status node
    }
    /** Return true if node is currently loading, i.e. a GET request is pending. */
    isLoading() {
        return this._isLoading;
    }
    /** Return true if this node is a temporarily generated status node of type 'paging'. */
    isPagingNode() {
        return this.statusNodeType === "paging";
    }
    /** Return true if this node is a **direct** parent of `other`.
     * (See also [[isAncestorOf]].)
     */
    isParentOf(other) {
        return other && other.parent === this;
    }
    /** (experimental) Return true if this node is partially loaded. */
    isPartload() {
        return !!this._partload;
    }
    /** Return true if this node is partially selected (tri-state). */
    isPartsel() {
        return !this.selected && !!this._partsel;
    }
    /** Return true if this node has DOM representaion, i.e. is displayed in the viewport. */
    isRendered() {
        return !!this._rowElem;
    }
    /** Return true if this node is the (invisible) system root node.
     * (See also [[isTopLevel()]].)
     */
    isRootNode() {
        return this.tree.root === this;
    }
    /** Return true if this node is selected, i.e. the checkbox is set. */
    isSelected() {
        return !!this.selected;
    }
    /** Return true if this node is a temporarily generated system node like
     * 'loading', 'paging', or 'error' (node.statusNodeType contains the type).
     */
    isStatusNode() {
        return !!this.statusNodeType;
    }
    /** Return true if this a top level node, i.e. a direct child of the (invisible) system root node. */
    isTopLevel() {
        return this.tree.root === this.parent;
    }
    /** Return true if node is marked lazy but not yet loaded.
     * For non-lazy nodes always return false.
     */
    isUnloaded() {
        // Also checks if the only child is a status node:
        return this.hasChildren() === undefined;
    }
    /** Return true if all parent nodes are expanded. Note: this does not check
     * whether the node is scrolled into the visible part of the screen or viewport.
     */
    isVisible() {
        let i, l, n, hasFilter = this.tree.filterMode === "hide", parents = this.getParentList(false, false);
        // TODO: check $(n.span).is(":visible")
        // i.e. return false for nodes (but not parents) that are hidden
        // by a filter
        if (hasFilter && !this.match && !this.subMatchCount) {
            // this.debug( "isVisible: HIDDEN (" + hasFilter + ", " + this.match + ", " + this.match + ")" );
            return false;
        }
        for (i = 0, l = parents.length; i < l; i++) {
            n = parents[i];
            if (!n.expanded) {
                // this.debug("isVisible: HIDDEN (parent collapsed)");
                return false;
            }
            // if (hasFilter && !n.match && !n.subMatchCount) {
            // 	this.debug("isVisible: HIDDEN (" + hasFilter + ", " + this.match + ", " + this.match + ")");
            // 	return false;
            // }
        }
        // this.debug("isVisible: VISIBLE");
        return true;
    }
    _loadSourceObject(source, level) {
        var _a;
        const tree = this.tree;
        level !== null && level !== void 0 ? level : (level = this.getLevel());
        // Let caller modify the parsed JSON response:
        const res = this._callEvent("receive", { response: source });
        if (res != null) {
            source = res;
        }
        if (isArray(source)) {
            source = { children: source };
        }
        assert(isPlainObject(source));
        const format = (_a = source.format) !== null && _a !== void 0 ? _a : "nested";
        assert(format === "nested" || format === "flat");
        // Pre-rocess for 'nested' or 'flat' format
        inflateSourceData(source);
        assert(source.children, "If `source` is an object, it must have a `children` property");
        if (source.types) {
            tree.logInfo("Redefine types", source.columns);
            tree.setTypes(source.types, false);
            delete source.types;
        }
        if (source.columns) {
            tree.logInfo("Redefine columns", source.columns);
            tree.columns = source.columns;
            delete source.columns;
            tree.setModified(ChangeType.colStructure);
        }
        this.addChildren(source.children);
        // Add extra data to `tree.data`
        for (const [key, value] of Object.entries(source)) {
            if (!RESERVED_TREE_SOURCE_KEYS.has(key)) {
                tree.data[key] = value;
                tree.logDebug(`Add source.${key} to tree.data.${key}`);
            }
        }
        this._callEvent("load");
    }
    async _fetchWithOptions(source) {
        var _a, _b;
        // Either a URL string or an object with a `.url` property.
        let url, params, body, options, rest;
        let fetchOpts = {};
        if (typeof source === "string") {
            // source is a plain URL string: assume GET request
            url = source;
            fetchOpts.method = "GET";
        }
        else if (isPlainObject(source)) {
            // source is a plain object with `.url` property.
            ({ url, params, body, options, ...rest } = source);
            assert(typeof url === "string", `expected source.url as string`);
            if (isPlainObject(options)) {
                fetchOpts = options;
            }
            if (isPlainObject(body)) {
                // we also accept 'body' as object...
                assert(!fetchOpts.body, "options.body should be passed as source.body");
                fetchOpts.body = JSON.stringify(fetchOpts.body);
                (_a = fetchOpts.method) !== null && _a !== void 0 ? _a : (fetchOpts.method = "POST"); // set default
            }
            if (isPlainObject(params)) {
                url += "?" + new URLSearchParams(params);
                (_b = fetchOpts.method) !== null && _b !== void 0 ? _b : (fetchOpts.method = "GET"); // set default
            }
        }
        else {
            url = ""; // keep linter happy
            error(`Unsupported source format: ${source}`);
        }
        this.setStatus(NodeStatusType.loading);
        const response = await fetch(url, fetchOpts);
        if (!response.ok) {
            error(`GET ${url} returned ${response.status}, ${response}`);
        }
        return await response.json();
    }
    /** Download  data from the cloud, then call `.update()`. */
    async load(source) {
        const tree = this.tree;
        const requestId = Date.now();
        const prevParent = this.parent;
        const start = Date.now();
        let elap = 0, elapLoad = 0, elapProcess = 0;
        // Check for overlapping requests
        if (this._requestId) {
            this.logWarn(`Recursive load request #${requestId} while #${this._requestId} is pending.`);
            // 	node.debug("Send load request #" + requestId);
        }
        this._requestId = requestId;
        // const timerLabel = tree.logTime(this + ".load()");
        try {
            let url = typeof source === "string" ? source : source.url;
            if (!url) {
                // An array or a plain object (that does NOT contain a `.url` property)
                // will be treated as native Wunderbaum data
                this._loadSourceObject(source);
                elapProcess = Date.now() - start;
            }
            else {
                // Either a URL string or an object with a `.url` property.
                const data = await this._fetchWithOptions(source);
                elapLoad = Date.now() - start;
                if (this._requestId && this._requestId > requestId) {
                    this.logWarn(`Ignored load response #${requestId} because #${this._requestId} is pending.`);
                    return;
                }
                else {
                    this.logDebug(`Received response for load request #${requestId}`);
                }
                if (this.parent === null && prevParent !== null) {
                    this.logWarn("Lazy parent node was removed while loading: discarding response.");
                    return;
                }
                this.setStatus(NodeStatusType.ok);
                // if (data.columns) {
                //   tree.logInfo("Re-define columns", data.columns);
                //   util.assert(!this.parent);
                //   tree.columns = data.columns;
                //   delete data.columns;
                //   tree.updateColumns({ calculateCols: false });
                // }
                const startProcess = Date.now();
                this._loadSourceObject(data);
                elapProcess = Date.now() - startProcess;
            }
        }
        catch (error) {
            this.logError("Error during load()", source, error);
            this._callEvent("error", { error: error });
            this.setStatus(NodeStatusType.error, { message: "" + error });
            throw error;
        }
        finally {
            this._requestId = 0;
            elap = Date.now() - start;
            if (tree.options.debugLevel >= 3) {
                tree.logInfo(`Load source took ${elap / 1000} seconds (transfer: ${elapLoad / 1000}s, processing: ${elapProcess / 1000}s)`);
            }
        }
    }
    /**Load content of a lazy node. */
    async loadLazy(forceReload = false) {
        const wasExpanded = this.expanded;
        assert(this.lazy, "load() requires a lazy node");
        // _assert( forceReload || this.isUndefined(), "Pass forceReload=true to re-load a lazy node" );
        if (!forceReload && !this.isUnloaded()) {
            return;
        }
        if (this.isLoaded()) {
            this.resetLazy(); // Also collapses if currently expanded
        }
        // `lazyLoad` may be long-running, so mark node as loading now. `this.load()`
        // will reset the status later.
        this.setStatus(NodeStatusType.loading);
        try {
            const source = await this._callEvent("lazyLoad");
            if (source === false) {
                this.setStatus(NodeStatusType.ok);
                return;
            }
            assert(isArray(source) || (source && source.url), "The lazyLoad event must return a node list, `{url: ...}`, or false.");
            await this.load(source); // also calls setStatus('ok')
            if (wasExpanded) {
                this.expanded = true;
                this.tree.setModified(ChangeType.structure);
            }
            else {
                this.setModified(); // Fix expander icon to 'loaded'
            }
        }
        catch (e) {
            this.logError("Error during loadLazy()", e);
            this._callEvent("error", { error: e });
            this.setStatus(NodeStatusType.error, { message: "" + e });
        }
        return;
    }
    /** Alias for `logDebug` */
    log(...args) {
        this.logDebug.apply(this, args);
    }
    /* Log to console if opts.debugLevel >= 4 */
    logDebug(...args) {
        if (this.tree.options.debugLevel >= 4) {
            Array.prototype.unshift.call(args, this.toString());
            console.log.apply(console, args);
        }
    }
    /* Log error to console. */
    logError(...args) {
        if (this.tree.options.debugLevel >= 1) {
            Array.prototype.unshift.call(args, this.toString());
            console.error.apply(console, args);
        }
    }
    /* Log to console if opts.debugLevel >= 3 */
    logInfo(...args) {
        if (this.tree.options.debugLevel >= 3) {
            Array.prototype.unshift.call(args, this.toString());
            console.info.apply(console, args);
        }
    }
    /* Log warning to console if opts.debugLevel >= 2 */
    logWarn(...args) {
        if (this.tree.options.debugLevel >= 2) {
            Array.prototype.unshift.call(args, this.toString());
            console.warn.apply(console, args);
        }
    }
    /** Expand all parents and optionally scroll into visible area as neccessary.
     * Promise is resolved, when lazy loading and animations are done.
     * @param {object} [options] passed to `setExpanded()`.
     *     Defaults to {noAnimation: false, noEvents: false, scrollIntoView: true}
     */
    async makeVisible(options) {
        let i, dfd = new Deferred(), deferreds = [], parents = this.getParentList(false, false), len = parents.length, noAnimation = getOption(options, "noAnimation", false), scroll = getOption(options, "scrollIntoView", true);
        // scroll = !(options && options.scrollIntoView === false);
        // Expand bottom-up, so only the top node is animated
        for (i = len - 1; i >= 0; i--) {
            // self.debug("pushexpand" + parents[i]);
            const seOpts = { noAnimation: noAnimation };
            deferreds.push(parents[i].setExpanded(true, seOpts));
        }
        Promise.all(deferreds).then(() => {
            // All expands have finished
            // self.debug("expand DONE", scroll);
            // Note: this.tree may be none when switching demo trees
            if (scroll && this.tree) {
                // Make sure markup and _rowIdx is updated before we do the scroll calculations
                this.tree.updatePendingModifications();
                this.scrollIntoView().then(() => {
                    // self.debug("scroll DONE");
                    dfd.resolve();
                });
            }
            else {
                dfd.resolve();
            }
        });
        return dfd.promise();
    }
    /** Move this node to targetNode. */
    moveTo(targetNode, mode = "appendChild", map) {
        if (mode === "over") {
            mode = "appendChild"; // compatible with drop region
        }
        if (mode === "prependChild") {
            if (targetNode.children && targetNode.children.length) {
                mode = "before";
                targetNode = targetNode.children[0];
            }
            else {
                mode = "appendChild";
            }
        }
        let pos, tree = this.tree, prevParent = this.parent, targetParent = mode === "appendChild" ? targetNode : targetNode.parent;
        if (this === targetNode) {
            return;
        }
        else if (!this.parent) {
            error("Cannot move system root");
        }
        else if (targetParent.isDescendantOf(this)) {
            error("Cannot move a node to its own descendant");
        }
        if (targetParent !== prevParent) {
            prevParent.triggerModifyChild("remove", this);
        }
        // Unlink this node from current parent
        if (this.parent.children.length === 1) {
            if (this.parent === targetParent) {
                return; // #258
            }
            this.parent.children = this.parent.lazy ? [] : null;
            this.parent.expanded = false;
        }
        else {
            pos = this.parent.children.indexOf(this);
            assert(pos >= 0, "invalid source parent");
            this.parent.children.splice(pos, 1);
        }
        // Insert this node to target parent's child list
        this.parent = targetParent;
        if (targetParent.hasChildren()) {
            switch (mode) {
                case "appendChild":
                    // Append to existing target children
                    targetParent.children.push(this);
                    break;
                case "before":
                    // Insert this node before target node
                    pos = targetParent.children.indexOf(targetNode);
                    assert(pos >= 0, "invalid target parent");
                    targetParent.children.splice(pos, 0, this);
                    break;
                case "after":
                    // Insert this node after target node
                    pos = targetParent.children.indexOf(targetNode);
                    assert(pos >= 0, "invalid target parent");
                    targetParent.children.splice(pos + 1, 0, this);
                    break;
                default:
                    error(`Invalid mode '${mode}'.`);
            }
        }
        else {
            targetParent.children = [this];
        }
        // Let caller modify the nodes
        if (map) {
            targetNode.visit(map, true);
        }
        if (targetParent === prevParent) {
            targetParent.triggerModifyChild("move", this);
        }
        else {
            // prevParent.triggerModifyChild("remove", this);
            targetParent.triggerModifyChild("add", this);
        }
        // Handle cross-tree moves
        if (tree !== targetNode.tree) {
            // Fix node.tree for all source nodes
            // 	util.assert(false, "Cross-tree move is not yet implemented.");
            this.logWarn("Cross-tree moveTo is experimental!");
            this.visit(function (n) {
                // TODO: fix selection state and activation, ...
                n.tree = targetNode.tree;
            }, true);
        }
        // Make sure we update async, because discarding the markup would prevent
        // DragAndDrop to generate a dragend event on the source node
        setTimeout(() => {
            // Even indentation may have changed:
            tree.setModified(ChangeType.any);
        }, 0);
        // TODO: fix selection state
        // TODO: fix active state
    }
    /** Set focus relative to this node and optionally activate.
     *
     * 'left' collapses the node if it is expanded, or move to the parent
     * otherwise.
     * 'right' expands the node if it is collapsed, or move to the first
     * child otherwise.
     *
     * @param where 'down', 'first', 'last', 'left', 'parent', 'right', or 'up'.
     *   (Alternatively the `event.key` that would normally trigger this move,
     *   e.g. `ArrowLeft` = 'left'.
     * @param options
     */
    async navigate(where, options) {
        // Allow to pass 'ArrowLeft' instead of 'left'
        where = KEY_TO_ACTION_DICT[where] || where;
        // Otherwise activate or focus the related node
        const node = this.findRelatedNode(where);
        if (!node) {
            this.logWarn(`Could not find related node '${where}'.`);
            return Promise.resolve(this);
        }
        // setFocus/setActive will scroll later (if autoScroll is specified)
        try {
            node.makeVisible({ scrollIntoView: false });
        }
        catch (e) { } // #272
        node.setFocus();
        if ((options === null || options === void 0 ? void 0 : options.activate) === false) {
            return Promise.resolve(this);
        }
        return node.setActive(true, { event: options === null || options === void 0 ? void 0 : options.event });
    }
    /** Delete this node and all descendants. */
    remove() {
        const tree = this.tree;
        const pos = this.parent.children.indexOf(this);
        this.triggerModify("remove");
        this.parent.children.splice(pos, 1);
        this.visit((n) => {
            n.removeMarkup();
            tree._unregisterNode(n);
        }, true);
        tree.setModified(ChangeType.structure);
    }
    /** Remove all descendants of this node. */
    removeChildren() {
        const tree = this.tree;
        if (!this.children) {
            return;
        }
        if (tree.activeNode && tree.activeNode.isDescendantOf(this)) {
            tree.activeNode.setActive(false); // TODO: don't fire events
        }
        if (tree.focusNode && tree.focusNode.isDescendantOf(this)) {
            tree.focusNode = null;
        }
        // TODO: persist must take care to clear select and expand cookies
        // Unlink children to support GC
        // TODO: also delete this.children (not possible using visit())
        this.triggerModifyChild("remove", null);
        this.visit((n) => {
            tree._unregisterNode(n);
        });
        if (this.lazy) {
            // 'undefined' would be interpreted as 'not yet loaded' for lazy nodes
            this.children = [];
        }
        else {
            this.children = null;
        }
        // util.assert(this.parent); // don't call this for root node
        if (!this.isRootNode()) {
            this.expanded = false;
        }
        this.tree.setModified(ChangeType.structure);
    }
    /** Remove all HTML markup from the DOM. */
    removeMarkup() {
        if (this._rowElem) {
            delete this._rowElem._wb_node;
            this._rowElem.remove();
            this._rowElem = undefined;
        }
    }
    _getRenderInfo() {
        const allColInfosById = {};
        const renderColInfosById = {};
        const isColspan = this.isColspan();
        const colElems = this._rowElem
            ? (this._rowElem.querySelectorAll("span.wb-col"))
            : null;
        let idx = 0;
        for (let col of this.tree.columns) {
            allColInfosById[col.id] = {
                id: col.id,
                idx: idx,
                elem: colElems ? colElems[idx] : null,
                info: col,
            };
            // renderColInfosById only contains columns that need rendering:
            if (!isColspan && col.id !== "*") {
                renderColInfosById[col.id] = allColInfosById[col.id];
            }
            idx++;
        }
        return {
            allColInfosById: allColInfosById,
            renderColInfosById: renderColInfosById,
        };
    }
    _createIcon(parentElem, replaceChild, showLoading) {
        let iconSpan;
        let icon = this.getOption("icon");
        if (this._errorInfo) {
            icon = iconMap.error;
        }
        else if (this._isLoading && showLoading) {
            // Status nodes, or nodes without expander (< minExpandLevel) should
            // display the 'loading' status with the i.wb-icon span
            icon = iconMap.loading;
        }
        if (icon === false) {
            return null; // explicitly disabled: don't try default icons
        }
        if (typeof icon === "string") ;
        else if (this.statusNodeType) {
            icon = iconMap[this.statusNodeType];
        }
        else if (this.expanded) {
            icon = iconMap.folderOpen;
        }
        else if (this.children) {
            icon = iconMap.folder;
        }
        else if (this.lazy) {
            icon = iconMap.folderLazy;
        }
        else {
            icon = iconMap.doc;
        }
        // this.log("_createIcon: " + icon);
        if (!icon) {
            iconSpan = document.createElement("i");
            iconSpan.className = "wb-icon";
        }
        else if (icon.indexOf("<") >= 0) {
            // HTML
            iconSpan = elemFromHtml(icon);
        }
        else if (TEST_IMG.test(icon)) {
            // Image URL
            iconSpan = elemFromHtml(`<img src="${icon}" class="wb-icon">`);
        }
        else {
            // Class name
            iconSpan = document.createElement("i");
            iconSpan.className = "wb-icon " + icon;
        }
        if (replaceChild) {
            parentElem.replaceChild(iconSpan, replaceChild);
        }
        else {
            parentElem.appendChild(iconSpan);
        }
        // this.log("_createIcon: ", iconSpan);
        return iconSpan;
    }
    /**
     * Create a whole new `<div class="wb-row">` element.
     * @see {@link WunderbaumNode.render}
     */
    _render_markup(opts) {
        const tree = this.tree;
        const treeOptions = tree.options;
        const checkbox = this.getOption("checkbox") !== false;
        const columns = tree.columns;
        const level = this.getLevel();
        let elem;
        let nodeElem;
        let rowDiv = this._rowElem;
        let titleSpan;
        let checkboxSpan = null;
        let iconSpan;
        let expanderSpan = null;
        const activeColIdx = tree.isRowNav() ? null : tree.activeColIdx;
        const isNew = !rowDiv;
        assert(isNew);
        assert(!isNew || (opts && opts.after), "opts.after expected, unless updating");
        assert(!this.isRootNode());
        rowDiv = document.createElement("div");
        rowDiv.classList.add("wb-row");
        rowDiv.style.top = this._rowIdx * ROW_HEIGHT + "px";
        this._rowElem = rowDiv;
        // Attach a node reference to the DOM Element:
        rowDiv._wb_node = this;
        nodeElem = document.createElement("span");
        nodeElem.classList.add("wb-node", "wb-col");
        rowDiv.appendChild(nodeElem);
        let ofsTitlePx = 0;
        if (checkbox) {
            checkboxSpan = document.createElement("i");
            checkboxSpan.classList.add("wb-checkbox");
            nodeElem.appendChild(checkboxSpan);
            ofsTitlePx += ICON_WIDTH;
        }
        for (let i = level - 1; i > 0; i--) {
            elem = document.createElement("i");
            elem.classList.add("wb-indent");
            nodeElem.appendChild(elem);
            ofsTitlePx += ICON_WIDTH;
        }
        if (!treeOptions.minExpandLevel || level > treeOptions.minExpandLevel) {
            expanderSpan = document.createElement("i");
            expanderSpan.classList.add("wb-expander");
            nodeElem.appendChild(expanderSpan);
            ofsTitlePx += ICON_WIDTH;
        }
        // Render the icon (show a 'loading' icon if we do not have an expander that
        // we would prefer).
        iconSpan = this._createIcon(nodeElem, null, !expanderSpan);
        if (iconSpan) {
            ofsTitlePx += ICON_WIDTH;
        }
        titleSpan = document.createElement("span");
        titleSpan.classList.add("wb-title");
        nodeElem.appendChild(titleSpan);
        this._callEvent("enhanceTitle", { titleSpan: titleSpan });
        // Store the width of leading icons with the node, so we can calculate
        // the width of the embedded title span later
        nodeElem._ofsTitlePx = ofsTitlePx;
        // Support HTML5 drag-n-drop
        if (tree.options.dnd.dragStart) {
            nodeElem.draggable = true;
        }
        // Render columns
        const isColspan = this.isColspan();
        if (!isColspan && columns.length > 1) {
            let colIdx = 0;
            for (let col of columns) {
                colIdx++;
                let colElem;
                if (col.id === "*") {
                    colElem = nodeElem;
                }
                else {
                    colElem = document.createElement("span");
                    colElem.classList.add("wb-col");
                    rowDiv.appendChild(colElem);
                }
                if (colIdx === activeColIdx) {
                    colElem.classList.add("wb-active");
                }
                // Add classes from `columns` definition to `<div.wb-col>` cells
                col.classes ? colElem.classList.add(...col.classes.split(" ")) : 0;
                colElem.style.left = col._ofsPx + "px";
                colElem.style.width = col._widthPx + "px";
                if (isNew && col.html) {
                    if (typeof col.html === "string") {
                        colElem.innerHTML = col.html;
                    }
                }
            }
        }
        // Attach to DOM as late as possible
        const after = opts ? opts.after : "last";
        switch (after) {
            case "first":
                tree.nodeListElement.prepend(rowDiv);
                break;
            case "last":
                tree.nodeListElement.appendChild(rowDiv);
                break;
            default:
                opts.after.after(rowDiv);
        }
        // Now go on and fill in data and update classes
        opts.isNew = true;
        this._render_data(opts);
    }
    /**
     * Render `node.title`, `.icon` into an existing row.
     *
     * @see {@link WunderbaumNode.render}
     */
    _render_data(opts) {
        assert(this._rowElem);
        const tree = this.tree;
        const treeOptions = tree.options;
        const rowDiv = this._rowElem;
        const isNew = !!opts.isNew; // Called by _render_markup()?
        const preventScroll = !!opts.preventScroll;
        const columns = tree.columns;
        const isColspan = this.isColspan();
        // Row markup already exists
        const nodeElem = rowDiv.querySelector("span.wb-node");
        const titleSpan = nodeElem.querySelector("span.wb-title");
        const scrollTop = tree.element.scrollTop;
        if (this.titleWithHighlight) {
            titleSpan.innerHTML = this.titleWithHighlight;
        }
        else {
            titleSpan.textContent = this.title; // TODO: this triggers scroll events
        }
        // NOTE: At least on Safari, this render call triggers a scroll event
        // probably when a focused input is replaced.
        if (preventScroll) {
            tree.element.scrollTop = scrollTop;
        }
        // Set the width of the title span, so overflow ellipsis work
        if (!treeOptions.skeleton) {
            if (isColspan) {
                let vpWidth = tree.element.clientWidth;
                titleSpan.style.width =
                    vpWidth - nodeElem._ofsTitlePx - TITLE_SPAN_PAD_Y + "px";
            }
            else {
                titleSpan.style.width =
                    columns[0]._widthPx -
                        nodeElem._ofsTitlePx -
                        TITLE_SPAN_PAD_Y +
                        "px";
            }
        }
        // Update row classes
        opts.isDataChange = true;
        this._render_status(opts);
        // Let user modify the result
        if (this.statusNodeType) {
            this._callEvent("renderStatusNode", {
                isNew: isNew,
                nodeElem: nodeElem,
                isColspan: isColspan,
            });
        }
        else if (this.parent) {
            // Skip root node
            const renderInfo = this._getRenderInfo();
            this._callEvent("render", {
                isNew: isNew,
                nodeElem: nodeElem,
                isColspan: isColspan,
                allColInfosById: renderInfo.allColInfosById,
                renderColInfosById: renderInfo.renderColInfosById,
            });
        }
    }
    /**
     * Update row classes to reflect active, focuses, etc.
     * @see {@link WunderbaumNode.render}
     */
    _render_status(opts) {
        // this.log("_render_status", opts);
        const tree = this.tree;
        const treeOptions = tree.options;
        const typeInfo = this.type ? tree.types[this.type] : null;
        const rowDiv = this._rowElem;
        // Row markup already exists
        const nodeElem = rowDiv.querySelector("span.wb-node");
        const expanderSpan = nodeElem.querySelector("i.wb-expander");
        const checkboxSpan = nodeElem.querySelector("i.wb-checkbox");
        let rowClasses = ["wb-row"];
        this.expanded ? rowClasses.push("wb-expanded") : 0;
        this.lazy ? rowClasses.push("wb-lazy") : 0;
        this.selected ? rowClasses.push("wb-selected") : 0;
        this === tree.activeNode ? rowClasses.push("wb-active") : 0;
        this === tree.focusNode ? rowClasses.push("wb-focus") : 0;
        this._errorInfo ? rowClasses.push("wb-error") : 0;
        this._isLoading ? rowClasses.push("wb-loading") : 0;
        this.isColspan() ? rowClasses.push("wb-colspan") : 0;
        this.statusNodeType
            ? rowClasses.push("wb-status-" + this.statusNodeType)
            : 0;
        this.match ? rowClasses.push("wb-match") : 0;
        this.subMatchCount ? rowClasses.push("wb-submatch") : 0;
        treeOptions.skeleton ? rowClasses.push("wb-skeleton") : 0;
        // Replace previous classes:
        rowDiv.className = rowClasses.join(" ");
        // Add classes from `node.classes`
        this.classes ? rowDiv.classList.add(...this.classes) : 0;
        // Add classes from `tree.types[node.type]`
        if (typeInfo && typeInfo.classes) {
            rowDiv.classList.add(...typeInfo.classes);
        }
        if (expanderSpan) {
            if (this._isLoading) {
                expanderSpan.className = "wb-expander " + iconMap.loading;
            }
            else if (this.isExpandable(false)) {
                if (this.expanded) {
                    expanderSpan.className = "wb-expander " + iconMap.expanderExpanded;
                }
                else {
                    expanderSpan.className = "wb-expander " + iconMap.expanderCollapsed;
                }
            }
            else if (this.lazy && this.children == null) {
                expanderSpan.className = "wb-expander " + iconMap.expanderLazy;
            }
            else {
                expanderSpan.classList.add("wb-indent");
            }
        }
        if (checkboxSpan) {
            if (this.selected) {
                checkboxSpan.className = "wb-checkbox " + iconMap.checkChecked;
            }
            else {
                checkboxSpan.className = "wb-checkbox " + iconMap.checkUnchecked;
            }
        }
        // Fix active cell in cell-nav mode
        if (!opts.isNew) {
            let i = 0;
            for (let colSpan of rowDiv.children) {
                colSpan.classList.toggle("wb-active", i++ === tree.activeColIdx);
            }
            // Update icon (if not opts.isNew, which would rebuild markup anyway)
            const iconSpan = nodeElem.querySelector("i.wb-icon");
            if (iconSpan) {
                this._createIcon(nodeElem, iconSpan, !expanderSpan);
            }
        }
        // Adjust column width
        if (opts.resizeCols !== false && !this.isColspan()) {
            const colElems = rowDiv.querySelectorAll("span.wb-col");
            let idx = 0;
            let ofs = 0;
            for (let colDef of this.tree.columns) {
                const colElem = colElems[idx];
                colElem.style.left = `${ofs}px`;
                colElem.style.width = `${colDef._widthPx}px`;
                idx++;
                ofs += colDef._widthPx;
            }
        }
    }
    /**
     * Create or update node's markup.
     *
     * `options.change` defaults to ChangeType.data, which updates the title,
     * icon, and status. It also triggers the `render` event, that lets the user
     * create or update the content of embeded cell elements.
     *
     * If only the status or other class-only modifications have changed,
     * `options.change` should be set to ChangeType.status instead for best
     * efficiency.
     *
     * Calling `setModified` instead may be a better alternative.
     * @see {@link WunderbaumNode.setModified}
     */
    render(options) {
        // this.log("render", options);
        const opts = Object.assign({ change: ChangeType.data }, options);
        if (!this._rowElem) {
            opts.change = ChangeType.row;
        }
        switch (opts.change) {
            case "status":
                this._render_status(opts);
                break;
            case "data":
                this._render_data(opts);
                break;
            case "row":
                // _rowElem is not yet created (asserted in _render_markup)
                this._render_markup(opts);
                break;
            default:
                error(`Invalid change type '${opts.change}'.`);
        }
    }
    /**
     * Remove all children, collapse, and set the lazy-flag, so that the lazyLoad
     * event is triggered on next expand.
     */
    resetLazy() {
        this.removeChildren();
        this.expanded = false;
        this.lazy = true;
        this.children = null;
        this.tree.setModified(ChangeType.structure);
    }
    /** Convert node (or whole branch) into a plain object.
     *
     * The result is compatible with node.addChildren().
     *
     * @param include child nodes
     * @param callback(dict, node) is called for every node, in order to allow
     *     modifications.
     *     Return `false` to ignore this node or `"skip"` to include this node
     *     without its children.
     * @see {@link Wunderbaum.toDictArray}.
     */
    toDict(recursive = false, callback) {
        const dict = {};
        NODE_ATTRS.forEach((propName) => {
            const val = this[propName];
            if (val instanceof Set) {
                // Convert Set to string (or skip if set is empty)
                val.size
                    ? (dict[propName] = Array.prototype.join.call(val.keys(), " "))
                    : 0;
            }
            else if (val || val === false || val === 0) {
                dict[propName] = val;
            }
        });
        if (!isEmptyObject(this.data)) {
            dict.data = extend({}, this.data);
            if (isEmptyObject(dict.data)) {
                delete dict.data;
            }
        }
        if (callback) {
            const res = callback(dict, this);
            if (res === false) {
                // Note: a return value of `false` is only used internally
                return false; // Don't include this node nor its children
            }
            if (res === "skip") {
                recursive = false; // Include this node, but not the children
            }
        }
        if (recursive) {
            if (isArray(this.children)) {
                dict.children = [];
                for (let i = 0, l = this.children.length; i < l; i++) {
                    const node = this.children[i];
                    if (!node.isStatusNode()) {
                        // Note: a return value of `false` is only used internally
                        const res = node.toDict(true, callback);
                        if (res !== false) {
                            dict.children.push(res);
                        }
                    }
                }
            }
        }
        return dict;
    }
    /** Return an option value that has a default, but may be overridden by a
     * callback or a node instance attribute.
     *
     * Evaluation sequence:
     *
     * - If `tree.options.<name>` is a callback that returns something, use that.
     * - Else if `node.<name>` is defined, use that.
     * - Else if `tree.types[<node.type>]` is a value, use that.
     * - Else if `tree.options.<name>` is a value, use that.
     * - Else use `defaultValue`.
     *
     * @param name name of the option property (on node and tree)
     * @param defaultValue return this if nothing else matched
     * {@link Wunderbaum.getOption|Wunderbaum.getOption()}
     */
    getOption(name, defaultValue) {
        let tree = this.tree;
        let opts = tree.options;
        // Lookup `name` in options dict
        if (name.indexOf(".") >= 0) {
            [opts, name] = name.split(".");
        }
        let value = opts[name]; // ?? defaultValue;
        // A callback resolver always takes precedence
        if (typeof value === "function") {
            let res = value.call(tree, {
                type: "resolve",
                tree: tree,
                node: this,
                // typeInfo: this.type ? tree.types[this.type] : {},
            });
            if (res !== undefined) {
                return res;
            }
        }
        // If this node has an explicit local setting, use it:
        if (this[name] !== undefined) {
            return this[name];
        }
        // Use value from type definition if defined
        let typeInfo = this.type ? tree.types[this.type] : undefined;
        let res = typeInfo ? typeInfo[name] : undefined;
        if (res !== undefined) {
            return res;
        }
        // Use value from value options dict, fallback do default
        return value !== null && value !== void 0 ? value : defaultValue;
    }
    /** Make sure that this node is visible in the viewport.
     * @see {@link Wunderbaum.scrollTo|Wunderbaum.scrollTo()}
     */
    async scrollIntoView(options) {
        const opts = Object.assign({ node: this }, options);
        return this.tree.scrollTo(opts);
    }
    /**
     * Activate this node, deactivate previous, send events, activate column and scroll int viewport.
     */
    async setActive(flag = true, options) {
        const tree = this.tree;
        const prev = tree.activeNode;
        const retrigger = options === null || options === void 0 ? void 0 : options.retrigger; // Default: false
        const focusTree = options === null || options === void 0 ? void 0 : options.focusTree; // Default: false
        const focusNode = (options === null || options === void 0 ? void 0 : options.focusNode) !== false; // Default: true
        const noEvents = options === null || options === void 0 ? void 0 : options.noEvents; // Default: false
        const orgEvent = options === null || options === void 0 ? void 0 : options.event; // Default: false
        if (!noEvents) {
            if (flag) {
                if (prev !== this || retrigger) {
                    if ((prev === null || prev === void 0 ? void 0 : prev._callEvent("deactivate", {
                        nextNode: this,
                        event: orgEvent,
                    })) === false ||
                        this._callEvent("beforeActivate", {
                            prevNode: prev,
                            event: orgEvent,
                        }) === false) {
                        return;
                    }
                    tree.activeNode = null;
                    prev === null || prev === void 0 ? void 0 : prev.setModified(ChangeType.status);
                }
            }
            else if (prev === this || retrigger) {
                this._callEvent("deactivate", { nextNode: null, event: orgEvent });
            }
        }
        if (prev !== this) {
            if (flag) {
                tree.activeNode = this;
                if (focusNode || focusTree)
                    tree.focusNode = this;
                if (focusTree)
                    tree.setFocus();
            }
            prev === null || prev === void 0 ? void 0 : prev.setModified(ChangeType.status);
            this.setModified(ChangeType.status);
        }
        if (options &&
            options.colIdx != null &&
            options.colIdx !== tree.activeColIdx &&
            tree.isCellNav()) {
            tree.setColumn(options.colIdx);
        }
        if (flag && !noEvents) {
            this._callEvent("activate", { prevNode: prev, event: orgEvent });
        }
        return this.makeVisible();
    }
    /**
     * Expand or collapse this node.
     */
    async setExpanded(flag = true, options) {
        const { force, scrollIntoView, immediate } = options !== null && options !== void 0 ? options : {};
        if (!flag &&
            this.isExpanded() &&
            this.getLevel() <= this.tree.getOption("minExpandLevel") &&
            !force) {
            this.logDebug("Ignored collapse request below expandLevel.");
            return;
        }
        if (!flag === !this.expanded) {
            return; // Nothing to do
        }
        // this.log("setExpanded()");
        if (flag && this.lazy && this.children == null) {
            await this.loadLazy();
        }
        this.expanded = flag;
        const updateOpts = { immediate: immediate };
        // const updateOpts = { immediate: !!util.getOption(options, "immediate") };
        this.tree.setModified(ChangeType.structure, updateOpts);
        if (flag && scrollIntoView !== false) {
            const lastChild = this.getLastChild();
            if (lastChild) {
                this.tree.updatePendingModifications();
                lastChild.scrollIntoView({ topNode: this });
            }
        }
    }
    /**
     * Set keyboard focus here.
     * @see {@link setActive}
     */
    setFocus(flag = true) {
        assert(!!flag, "blur is not yet implemented");
        const prev = this.tree.focusNode;
        this.tree.focusNode = this;
        prev === null || prev === void 0 ? void 0 : prev.setModified();
        this.setModified();
    }
    /** Set a new icon path or class. */
    setIcon(icon) {
        this.icon = icon;
        this.setModified();
    }
    /** Change node's {@link key} and/or {@link refKey}.  */
    setKey(key, refKey) {
        throw new Error("Not yet implemented");
    }
    /**
     * Trigger a repaint, typically after a status or data change.
     *
     * `change` defaults to 'data', which handles modifcations of title, icon,
     * and column content. It can be reduced to 'ChangeType.status' if only
     * active/focus/selected state has changed.
     *
     * This method will eventually call  {@link WunderbaumNode.render()} with
     * default options, but may be more consistent with the tree's
     * {@link Wunderbaum.setModified()} API.
     */
    setModified(change = ChangeType.data) {
        assert(change === ChangeType.status || change === ChangeType.data);
        this.tree.setModified(change, this);
    }
    /** Modify the check/uncheck state. */
    setSelected(flag = true, options) {
        const prev = this.selected;
        if (!!flag !== prev) {
            this._callEvent("select", { flag: flag });
        }
        this.selected = !!flag;
        this.setModified();
    }
    /** Display node status (ok, loading, error, noData) using styles and a dummy child node. */
    setStatus(status, options) {
        const tree = this.tree;
        const message = options === null || options === void 0 ? void 0 : options.message;
        const details = options === null || options === void 0 ? void 0 : options.details;
        let statusNode = null;
        const _clearStatusNode = () => {
            // Remove dedicated dummy node, if any
            let children = this.children;
            if (children && children.length && children[0].isStatusNode()) {
                children[0].remove();
            }
        };
        const _setStatusNode = (data) => {
            // Create/modify the dedicated dummy node for 'loading...' or
            // 'error!' status. (only called for direct child of the invisible
            // system root)
            let children = this.children;
            let firstChild = children ? children[0] : null;
            assert(data.statusNodeType);
            assert(!firstChild || !firstChild.isStatusNode());
            statusNode = this.addNode(data, "prependChild");
            statusNode.match = true;
            tree.setModified(ChangeType.structure);
            return statusNode;
        };
        _clearStatusNode();
        switch (status) {
            case "ok":
                this._isLoading = false;
                this._errorInfo = null;
                break;
            case "loading":
                this._isLoading = true;
                this._errorInfo = null;
                if (this.parent) {
                    this.setModified(ChangeType.status);
                }
                else {
                    // If this is the invisible root, add a visible top-level node
                    _setStatusNode({
                        statusNodeType: status,
                        title: tree.options.strings.loading +
                            (message ? " (" + message + ")" : ""),
                        checkbox: false,
                        colspan: true,
                        tooltip: details,
                    });
                }
                // this.render();
                break;
            case "error":
                _setStatusNode({
                    statusNodeType: status,
                    title: tree.options.strings.loadError +
                        (message ? " (" + message + ")" : ""),
                    checkbox: false,
                    colspan: true,
                    // classes: "wb-center",
                    tooltip: details,
                });
                this._isLoading = false;
                this._errorInfo = { message: message, details: details };
                break;
            case "noData":
                _setStatusNode({
                    statusNodeType: status,
                    title: message || tree.options.strings.noData,
                    checkbox: false,
                    colspan: true,
                    tooltip: details,
                });
                this._isLoading = false;
                this._errorInfo = null;
                break;
            default:
                error("invalid node status " + status);
        }
        tree.setModified(ChangeType.structure);
        return statusNode;
    }
    /** Rename this node. */
    setTitle(title) {
        this.title = title;
        this.setModified();
        // this.triggerModify("rename"); // TODO
    }
    _sortChildren(cmp, deep) {
        const cl = this.children;
        if (!cl) {
            return;
        }
        cl.sort(cmp);
        if (deep) {
            for (let i = 0, l = cl.length; i < l; i++) {
                if (cl[i].children) {
                    cl[i]._sortChildren(cmp, deep);
                }
            }
        }
    }
    /**
     * Sort child list by title or custom criteria.
     * @param {function} cmp custom compare function(a, b) that returns -1, 0, or 1
     *    (defaults to sorting by title).
     * @param {boolean} deep pass true to sort all descendant nodes recursively
     */
    sortChildren(cmp = nodeTitleSorter, deep = false) {
        this._sortChildren(cmp || nodeTitleSorter, deep);
        this.tree.setModified(ChangeType.structure);
        // this.triggerModify("sort"); // TODO
    }
    /**
     * Trigger `modifyChild` event on a parent to signal that a child was modified.
     * @param {string} operation Type of change: 'add', 'remove', 'rename', 'move', 'data', ...
     */
    triggerModifyChild(operation, child, extra) {
        this.logDebug(`modifyChild(${operation})`, extra, child);
        if (!this.tree.options.modifyChild)
            return;
        if (child && child.parent !== this) {
            error("child " + child + " is not a child of " + this);
        }
        this._callEvent("modifyChild", extend({ operation: operation, child: child }, extra));
    }
    /**
     * Trigger `modifyChild` event on node.parent(!).
     * @param {string} operation Type of change: 'add', 'remove', 'rename', 'move', 'data', ...
     * @param {object} [extra]
     */
    triggerModify(operation, extra) {
        // if (!this.parent) {
        //   return;
        // }
        this.parent.triggerModifyChild(operation, this, extra);
    }
    /**
     * Call `callback(node)` for all child nodes in hierarchical order (depth-first, pre-order).
     *
     * Stop iteration, if fn() returns false. Skip current branch, if fn()
     * returns "skip".<br>
     * Return false if iteration was stopped.
     *
     * @param {function} callback the callback function.
     *     Return false to stop iteration, return "skip" to skip this node and
     *     its children only.
     * @see {@link IterableIterator<WunderbaumNode>}, {@link Wunderbaum.visit}.
     */
    visit(callback, includeSelf = false) {
        let i, l, res = true, children = this.children;
        if (includeSelf === true) {
            res = callback(this);
            if (res === false || res === "skip") {
                return res;
            }
        }
        if (children) {
            for (i = 0, l = children.length; i < l; i++) {
                res = children[i].visit(callback, true);
                if (res === false) {
                    break;
                }
            }
        }
        return res;
    }
    /** Call fn(node) for all parent nodes, bottom-up, including invisible system root.<br>
     * Stop iteration, if callback() returns false.<br>
     * Return false if iteration was stopped.
     *
     * @param callback the callback function. Return false to stop iteration
     */
    visitParents(callback, includeSelf = false) {
        if (includeSelf && callback(this) === false) {
            return false;
        }
        let p = this.parent;
        while (p) {
            if (callback(p) === false) {
                return false;
            }
            p = p.parent;
        }
        return true;
    }
    /**
     * Call fn(node) for all sibling nodes.<br>
     * Stop iteration, if fn() returns false.<br>
     * Return false if iteration was stopped.
     *
     * @param {function} fn the callback function.
     *     Return false to stop iteration.
     */
    visitSiblings(callback, includeSelf = false) {
        let i, l, n, ac = this.parent.children;
        for (i = 0, l = ac.length; i < l; i++) {
            n = ac[i];
            if (includeSelf || n !== this) {
                if (callback(n) === false) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * [ext-filter] Return true if this node is matched by current filter (or no filter is active).
     */
    isMatched() {
        return !(this.tree.filterMode && !this.match);
    }
}
WunderbaumNode.sequence = 0;

/*!
 * Wunderbaum - ext-edit
 * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.
 * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)
 */
// const START_MARKER = "\uFFF7";
class EditExtension extends WunderbaumExtension {
    constructor(tree) {
        super(tree, "edit", {
            debounce: 100,
            minlength: 1,
            maxlength: null,
            trigger: [],
            trim: true,
            select: true,
            slowClickDelay: 1000,
            validity: true,
            // --- Events ---
            // (note: there is also the `tree.change` event.)
            beforeEdit: null,
            edit: null,
            apply: null,
        });
        this.curEditNode = null;
        this.relatedNode = null;
        this.debouncedOnChange = debounce(this._onChange.bind(this), this.getPluginOption("debounce"));
    }
    /*
     * Call an event handler, while marking the current node cell 'dirty'.
     */
    _applyChange(eventName, node, colElem, extra) {
        let res;
        node.log(`_applyChange(${eventName})`, extra);
        colElem.classList.add("wb-busy");
        colElem.classList.remove("wb-error");
        try {
            res = node._callEvent(eventName, extra);
        }
        catch (err) {
            node.logError(`Error in ${eventName} event handler`, err);
            colElem.classList.add("wb-error");
            colElem.classList.remove("wb-busy");
        }
        // Convert scalar return value to a resolved promise
        if (!(res instanceof Promise)) {
            res = Promise.resolve(res);
        }
        res
            .catch((err) => {
            node.logError(`Error in ${eventName} event promise`, err);
            colElem.classList.add("wb-error");
        })
            .finally(() => {
            colElem.classList.remove("wb-busy");
        });
        return res;
    }
    /*
     * Called for when a control that is embedded in a cell fires a `change` event.
     */
    _onChange(e) {
        // let res;
        const info = Wunderbaum.getEventInfo(e);
        const node = info.node;
        const colElem = info.colElem;
        if (!node || info.colIdx === 0) {
            this.tree.log("Ignored change event for removed element or node title");
            return;
        }
        this._applyChange("change", node, colElem, {
            info: info,
            event: e,
            inputElem: e.target,
            inputValue: Wunderbaum.util.getValueFromElem(e.target),
        });
    }
    // handleKey(e:KeyboardEvent):boolean {
    //   if(this.tree.cellNavMode )
    // }
    init() {
        super.init();
        onEvent(this.tree.element, "change", //"change input",
        ".contenteditable,input,textarea,select", (e) => {
            this.debouncedOnChange(e);
        });
    }
    /* Called by ext_keynav to pre-process input. */
    _preprocessKeyEvent(data) {
        const event = data.event;
        const eventName = eventToString(event);
        const tree = this.tree;
        const trigger = this.getPluginOption("trigger");
        // const inputElem =
        //   event.target && event.target.closest("input,[contenteditable]");
        // tree.logDebug(`_preprocessKeyEvent: ${eventName}, editing:${this.isEditingTitle()}`);
        // --- Title editing: apply/discard ---
        // if (inputElem) {
        if (this.isEditingTitle()) {
            switch (eventName) {
                case "Enter":
                    this._stopEditTitle(true, { event: event });
                    return false;
                case "Escape":
                    this._stopEditTitle(false, { event: event });
                    return false;
            }
            // If the event target is an input element or `contenteditable="true"`,
            // we ignore it as navigation command
            return false;
        }
        // --- Trigger title editing
        if (tree.isRowNav() || tree.activeColIdx === 0) {
            switch (eventName) {
                case "Enter":
                    if (trigger.indexOf("macEnter") >= 0 && isMac) {
                        this.startEditTitle();
                        return false;
                    }
                    break;
                case "F2":
                    if (trigger.indexOf("F2") >= 0) {
                        // tree.setNavigationMode(NavigationMode.cellEdit);
                        this.startEditTitle();
                        return false;
                    }
                    break;
            }
            return true;
        }
        return true;
    }
    /** Return true if a title is currently being edited. */
    isEditingTitle(node) {
        return node ? this.curEditNode === node : !!this.curEditNode;
    }
    /** Start renaming, i.e. replace the title with an embedded `<input>`. */
    startEditTitle(node) {
        node = node !== null && node !== void 0 ? node : this.tree.getActiveNode();
        const validity = this.getPluginOption("validity");
        const select = this.getPluginOption("select");
        if (!node) {
            return;
        }
        this.tree.logDebug(`startEditTitle(node=${node})`);
        let inputHtml = node._callEvent("edit.beforeEdit");
        if (inputHtml === false) {
            node.logInfo("beforeEdit canceled operation.");
            return;
        }
        // `beforeEdit(e)` may return an input HTML string. Otherwise use a default.
        // (we also treat a `true` return value as 'use default'):
        if (inputHtml === true || !inputHtml) {
            const title = escapeHtml(node.title);
            inputHtml = `<input type=text class="wb-input-edit" tabindex=-1 value="${title}" required autocorrect=off>`;
        }
        const titleSpan = node
            .getColElem(0)
            .querySelector(".wb-title");
        titleSpan.innerHTML = inputHtml;
        const inputElem = titleSpan.firstElementChild;
        if (validity) {
            // Permanently apply input validations (CSS and tooltip)
            inputElem.addEventListener("keydown", (e) => {
                inputElem.setCustomValidity("");
                if (!inputElem.reportValidity()) ;
            });
        }
        inputElem.focus();
        if (select) {
            inputElem.select();
        }
        this.curEditNode = node;
        node._callEvent("edit.edit", {
            inputElem: inputElem,
        });
    }
    /**
     *
     * @param apply
     * @returns
     */
    stopEditTitle(apply) {
        return this._stopEditTitle(apply, {});
    }
    /*
     *
     * @param apply
     * @param opts.canKeepOpen
     */
    _stopEditTitle(apply, options) {
        options !== null && options !== void 0 ? options : (options = {});
        const focusElem = document.activeElement;
        let newValue = focusElem ? getValueFromElem(focusElem) : null;
        const node = this.curEditNode;
        const forceClose = !!options.forceClose;
        const validity = this.getPluginOption("validity");
        if (newValue && this.getPluginOption("trim")) {
            newValue = newValue.trim();
        }
        if (!node) {
            this.tree.logDebug("stopEditTitle: not in edit mode.");
            return;
        }
        node.logDebug(`stopEditTitle(${apply})`, options, focusElem, newValue);
        if (apply && newValue !== null && newValue !== node.title) {
            const errMsg = focusElem.validationMessage;
            if (errMsg) {
                // input element's native validation failed
                throw new Error(`Input validation failed for "${newValue}": ${errMsg}.`);
            }
            const colElem = node.getColElem(0);
            this._applyChange("edit.apply", node, colElem, {
                oldValue: node.title,
                newValue: newValue,
                inputElem: focusElem,
            })
                .then((value) => {
                const errMsg = focusElem.validationMessage;
                if (validity && errMsg && value !== false) {
                    // Handler called 'inputElem.setCustomValidity()' to signal error
                    throw new Error(`Edit apply validation failed for "${newValue}": ${errMsg}.`);
                }
                // Discard the embedded `<input>`
                // node.logDebug("applyChange:", value, forceClose)
                if (!forceClose && value === false) {
                    // Keep open
                    return;
                }
                node === null || node === void 0 ? void 0 : node.setTitle(newValue);
                // NOTE: At least on Safari, this render call triggers a scroll event
                // probably because the focused input is replaced.
                if (this.curEditNode){
                    this.curEditNode.render({ preventScroll: true });
                    this.curEditNode = null;
                }
                this.relatedNode = null;
                this.tree.setFocus(); // restore focus that was in the input element
            })
                .catch((err) => {
                node.logError(err);
            });
            // Trigger 'change' event for embedded `<input>`
            // focusElem.blur();
        }
        else {
            // Discard the embedded `<input>`
            // NOTE: At least on Safari, this render call triggers a scroll event
            // probably because the focused input is replaced.
            this.curEditNode.render({ preventScroll: true });
            this.curEditNode = null;
            this.relatedNode = null;
            // We discarded the <input>, so we have to acquire keyboard focus again
            this.tree.setFocus();
        }
    }
    /**
     * Create a new child or sibling node and start edit mode.
     */
    createNode(mode = "after", node, init) {
        const tree = this.tree;
        node = node !== null && node !== void 0 ? node : tree.getActiveNode();
        assert(node, "No node was passed, or no node is currently active.");
        // const validity = this.getPluginOption("validity");
        mode = mode || "prependChild";
        if (init == null) {
            init = { title: "" };
        }
        else if (typeof init === "string") {
            init = { title: init };
        }
        else {
            assert(isPlainObject(init));
        }
        // Make sure node is expanded (and loaded) in 'child' mode
        if ((mode === "prependChild" || mode === "appendChild") &&
            (node === null || node === void 0 ? void 0 : node.isExpandable(true))) {
            node.setExpanded().then(() => {
                this.createNode(mode, node, init);
            });
            return;
        }
        const newNode = node.addNode(init, mode);
        newNode.setClass("wb-edit-new");
        this.relatedNode = node;
        // Don't filter new nodes:
        newNode.match = true;
        newNode.makeVisible({ noAnimation: true }).then(() => {
            this.startEditTitle(newNode);
        });
    }
}

/*!
 * wunderbaum.ts
 *
 * A treegrid control.
 *
 * Copyright (c) 2021-2023, Martin Wendt (https://wwWendt.de).
 * https://github.com/mar10/wunderbaum
 *
 * Released under the MIT license.
 * @version v0.3.5
 * @date Mon, 19 Jun 2023 06:20:59 GMT
 */
class WbSystemRoot extends WunderbaumNode {
    constructor(tree) {
        super(tree, null, {
            key: "__root__",
            title: tree.id,
        });
    }
    toString() {
        return `WbSystemRoot@${this.key}<'${this.tree.id}'>`;
    }
}
/**
 * A persistent plain object or array.
 *
 * See also [[WunderbaumOptions]].
 */
class Wunderbaum {
    constructor(options) {
        this.enabled = true;
        /** Contains additional data that was sent as response to an Ajax source load request. */
        this.data = {};
        this.extensionList = [];
        this.extensions = {};
        this.keyMap = new Map();
        this.refKeyMap = new Map();
        this.treeRowCount = 0;
        this._disableUpdateCount = 0;
        this._disableUpdateIgnoreCount = 0;
        /** Currently active node if any. */
        this.activeNode = null;
        /** Current node hat has keyboard focus if any. */
        this.focusNode = null;
        /** Shared properties, referenced by `node.type`. */
        this.types = {};
        /** List of column definitions. */
        this.columns = []; // any[] = [];
        this._columnsById = {};
        // Modification Status
        this.pendingChangeTypes = new Set();
        /** Expose some useful methods of the util.ts module as `tree._util`. */
        this._util = util;
        // --- FILTER ---
        this.filterMode = null;
        // --- KEYNAV ---
        /** @internal Use `setColumn()`/`getActiveColElem()`*/
        this.activeColIdx = 0;
        /** @internal */
        this._cellNavMode = false;
        /** @internal */
        this.lastQuicksearchTime = 0;
        /** @internal */
        this.lastQuicksearchTerm = "";
        // --- EDIT ---
        this.lastClickTime = 0;
        /** Alias for {@link Wunderbaum.logDebug}.
         * @alias Wunderbaum.logDebug
         */
        this.log = this.logDebug;
        let opts = (this.options = extend({
            id: null,
            source: null,
            element: null,
            debugLevel: DEFAULT_DEBUGLEVEL,
            header: null,
            // headerHeightPx: ROW_HEIGHT,
            rowHeightPx: ROW_HEIGHT,
            columns: null,
            types: null,
            // escapeTitles: true,
            enabled: true,
            fixedCol: false,
            showSpinner: false,
            checkbox: false,
            minExpandLevel: 0,
            emptyChildListExpandable: false,
            updateThrottleWait: 200,
            skeleton: false,
            connectTopBreadcrumb: null,
            // --- KeyNav ---
            navigationModeOption: null,
            quicksearch: true,
            // --- Events ---
            change: noop,
            enhanceTitle: noop,
            error: noop,
            receive: noop,
            // --- Strings ---
            strings: {
                loadError: "Error",
                loading: "Loading...",
                // loading: "Loading&hellip;",
                noData: "No data",
            },
        }, options));
        const readyDeferred = new Deferred();
        this.ready = readyDeferred.promise();
        let readyOk = false;
        this.ready
            .then(() => {
            readyOk = true;
            try {
                this._callEvent("init");
            }
            catch (error) {
                // We re-raise in the reject handler, but Chrome resets the stack
                // frame then, so we log it here:
                console.error("Exception inside `init(e)` event:", error);
            }
        })
            .catch((err) => {
            if (readyOk) {
                // Error occurred in `init` handler. We can re-raise, but Chrome
                // resets the stack frame.
                throw err;
            }
            else {
                // Error in load process
                this._callEvent("init", { error: err });
            }
        });
        this.id = opts.id || "wb_" + ++Wunderbaum.sequence;
        this.root = new WbSystemRoot(this);
        this._registerExtension(new KeynavExtension(this));
        this._registerExtension(new EditExtension(this));
        this._registerExtension(new FilterExtension(this));
        this._registerExtension(new DndExtension(this));
        this._registerExtension(new GridExtension(this));
        this._registerExtension(new LoggerExtension(this));
        this._updateViewportThrottled = adaptiveThrottle(this._updateViewportImmediately.bind(this), {});
        // --- Evaluate options
        this.columns = opts.columns;
        delete opts.columns;
        if (!this.columns || !this.columns.length) {
            const title = typeof opts.header === "string" ? opts.header : this.id;
            this.columns = [{ id: "*", title: title, width: "*" }];
        }
        if (opts.types) {
            this.setTypes(opts.types, true);
        }
        delete opts.types;
        // --- Create Markup
        this.element = elemFromSelector(opts.element);
        assert(!!this.element, `Invalid 'element' option: ${opts.element}`);
        this.element.classList.add("wunderbaum");
        if (!this.element.getAttribute("tabindex")) {
            this.element.tabIndex = 0;
        }
        // Attach tree instance to <div>
        this.element._wb_tree = this;
        // Create header markup, or take it from the existing html
        this.headerElement = this.element.querySelector("div.wb-header");
        const wantHeader = opts.header == null ? this.columns.length > 1 : !!opts.header;
        if (this.headerElement) {
            // User existing header markup to define `this.columns`
            assert(!this.columns, "`opts.columns` must not be set if markup already contains a header");
            this.columns = [];
            const rowElement = this.headerElement.querySelector("div.wb-row");
            for (const colDiv of rowElement.querySelectorAll("div")) {
                this.columns.push({
                    id: colDiv.dataset.id || `col_${this.columns.length}`,
                    // id: colDiv.dataset.id || null,
                    title: "" + colDiv.textContent,
                    // text: "" + colDiv.textContent,
                    width: "*", // TODO: read from header span
                });
            }
        }
        else {
            // We need a row div, the rest will be computed from `this.columns`
            const coldivs = "<span class='wb-col'></span>".repeat(this.columns.length);
            this.element.innerHTML = `
        <div class='wb-header'>
          <div class='wb-row'>
            ${coldivs}
          </div>
        </div>`;
            if (!wantHeader) {
                const he = this.element.querySelector("div.wb-header");
                he.style.display = "none";
            }
        }
        //
        this.element.innerHTML += `
      <div class="wb-list-container">
        <div class="wb-node-list"></div>
      </div>`;
        this.listContainerElement = this.element.querySelector("div.wb-list-container");
        this.nodeListElement = this.listContainerElement.querySelector("div.wb-node-list");
        this.headerElement = this.element.querySelector("div.wb-header");
        this.element.classList.toggle("wb-grid", this.columns.length > 1);
        this._initExtensions();
        // --- apply initial options
        ["enabled", "fixedCol"].forEach((optName) => {
            if (opts[optName] != null) {
                this.setOption(optName, opts[optName]);
            }
        });
        // --- Load initial data
        if (opts.source) {
            if (opts.showSpinner) {
                this.nodeListElement.innerHTML =
                    "<progress class='spinner'>loading...</progress>";
            }
            this.load(opts.source)
                .then(() => {
                // The source may have defined columns, so we may adjust the nav mode
                if (opts.navigationModeOption == null) {
                    if (this.isGrid()) {
                        this.setNavigationOption(NavModeEnum.cell);
                    }
                    else {
                        this.setNavigationOption(NavModeEnum.row);
                    }
                }
                else {
                    this.setNavigationOption(opts.navigationModeOption);
                }
                readyDeferred.resolve();
            })
                .catch((error) => {
                readyDeferred.reject(error);
            })
                .finally(() => {
                var _a;
                (_a = this.element.querySelector("progress.spinner")) === null || _a === void 0 ? void 0 : _a.remove();
                this.element.classList.remove("wb-initializing");
            });
        }
        else {
            readyDeferred.resolve();
        }
        // Async mode is sometimes required, because this.element.clientWidth
        // has a wrong value at start???
        this.setModified(ChangeType.any);
        // --- Bind listeners
        this.element.addEventListener("scroll", (e) => {
            // this.log(`scroll, scrollTop:${e.target.scrollTop}`, e);
            this.setModified(ChangeType.scroll);
        });
        this.resizeObserver = new ResizeObserver((entries) => {
            // this.log("ResizeObserver: Size changed", entries);
            this.setModified(ChangeType.resize);
        });
        this.resizeObserver.observe(this.element);
        onEvent(this.nodeListElement, "click", "div.wb-row", (e) => {
            const info = Wunderbaum.getEventInfo(e);
            const node = info.node;
            // this.log("click", info, e);
            if (this._callEvent("click", { event: e, node: node, info: info }) === false) {
                this.lastClickTime = Date.now();
                return false;
            }
            if (node) {
                // Edit title if 'clickActive' is triggered:
                const trigger = this.getOption("edit.trigger");
                const slowClickDelay = this.getOption("edit.slowClickDelay");
                if (trigger.indexOf("clickActive") >= 0 &&
                    info.region === "title" &&
                    node.isActive() &&
                    (!slowClickDelay || Date.now() - this.lastClickTime < slowClickDelay)) {
                    this._callMethod("edit.startEditTitle", node);
                }
                if (info.colIdx >= 0) {
                    node.setActive(true, { colIdx: info.colIdx, event: e });
                }
                else {
                    node.setActive(true, { event: e });
                }
                if (info.region === NodeRegion.expander) {
                    node.setExpanded(!node.isExpanded());
                }
                else if (info.region === NodeRegion.checkbox) {
                    node.setSelected(!node.isSelected());
                }
            }
            this.lastClickTime = Date.now();
        });
        onEvent(this.nodeListElement, "dblclick", "div.wb-row", (e) => {
            const info = Wunderbaum.getEventInfo(e);
            const node = info.node;
            // this.log("dblclick", info, e);
            if (this._callEvent("dblclick", { event: e, node: node, info: info }) ===
                false) {
                return false;
            }
            if (node && info.colIdx === 0 && node.isExpandable()) {
                this._callMethod("edit._stopEditTitle");
                node.setExpanded(!node.isExpanded());
            }
        });
        onEvent(this.element, "keydown", (e) => {
            const info = Wunderbaum.getEventInfo(e);
            const eventName = eventToString(e);
            const node = info.node || this.getFocusNode();
            this._callHook("onKeyEvent", {
                event: e,
                node: node,
                info: info,
                eventName: eventName,
            });
        });
        onEvent(this.element, "focusin focusout", (e) => {
            const flag = e.type === "focusin";
            const targetNode = Wunderbaum.getNode(e);
            this._callEvent("focus", { flag: flag, event: e });
            if (flag && this.isRowNav() && !this.isEditing()) {
                if (opts.navigationModeOption === NavModeEnum.row) {
                    targetNode === null || targetNode === void 0 ? void 0 : targetNode.setActive();
                }
                else {
                    this.setCellNav();
                }
            }
            if (!flag) {
                this._callMethod("edit._stopEditTitle", true, {
                    event: e,
                    forceClose: true,
                });
            }
        });
    }
    /**
     * Return a Wunderbaum instance, from element, id, index, or event.
     *
     * ```js
     * getTree();         // Get first Wunderbaum instance on page
     * getTree(1);        // Get second Wunderbaum instance on page
     * getTree(event);    // Get tree for this mouse- or keyboard event
     * getTree("foo");    // Get tree for this `tree.options.id`
     * getTree("#tree");  // Get tree for this matching element
     * ```
     */
    static getTree(el) {
        if (el instanceof Wunderbaum) {
            return el;
        }
        else if (el instanceof WunderbaumNode) {
            return el.tree;
        }
        if (el === undefined) {
            el = 0; // get first tree
        }
        if (typeof el === "number") {
            el = document.querySelectorAll(".wunderbaum")[el]; // el was an integer: return nth element
        }
        else if (typeof el === "string") {
            // Search all trees for matching ID
            for (let treeElem of document.querySelectorAll(".wunderbaum")) {
                const tree = treeElem._wb_tree;
                if (tree && tree.id === el) {
                    return tree;
                }
            }
            // Search by selector
            el = document.querySelector(el);
            if (!el) {
                return null;
            }
        }
        else if (el.target) {
            el = el.target;
        }
        assert(el instanceof Element);
        if (!el.matches(".wunderbaum")) {
            el = el.closest(".wunderbaum");
        }
        if (el && el._wb_tree) {
            return el._wb_tree;
        }
        return null;
    }
    /**
     * Return a WunderbaumNode instance from element or event.
     */
    static getNode(el) {
        if (!el) {
            return null;
        }
        else if (el instanceof WunderbaumNode) {
            return el;
        }
        else if (el.target !== undefined) {
            el = el.target; // el was an Event
        }
        // `el` is a DOM element
        // let nodeElem = obj.closest("div.wb-row");
        while (el) {
            if (el._wb_node) {
                return el._wb_node;
            }
            el = el.parentElement; //.parentNode;
        }
        return null;
    }
    /**
     * Iterate all descendant nodes depth-first, pre-order using `for ... of ...` syntax.
     * More concise, but slightly slower than {@link Wunderbaum.visit}.
     *
     * Example:
     * ```js
     * for(const node of tree) {
     *   ...
     * }
     * ```
     */
    *[Symbol.iterator]() {
        yield* this.root;
    }
    /** @internal */
    _registerExtension(extension) {
        this.extensionList.push(extension);
        this.extensions[extension.id] = extension;
        // this.extensionMap.set(extension.id, extension);
    }
    /** Called on tree (re)init after markup is created, before loading. */
    _initExtensions() {
        for (let ext of this.extensionList) {
            ext.init();
        }
    }
    /** Add node to tree's bookkeeping data structures. */
    _registerNode(node) {
        const key = node.key;
        assert(key != null && !this.keyMap.has(key), `Missing or duplicate key: '${key}'.`);
        this.keyMap.set(key, node);
        let rk = node.refKey;
        if (rk) {
            let rks = this.refKeyMap.get(rk); // Set of nodes with this refKey
            if (rks) {
                rks.add(node);
            }
            else {
                this.refKeyMap.set(rk, new Set());
            }
        }
    }
    /** Remove node from tree's bookkeeping data structures. */
    _unregisterNode(node) {
        const rk = node.refKey;
        if (rk) {
            const rks = this.refKeyMap.get(rk);
            if (rks && rks.delete(node) && !rks.size) {
                // We just removed the last element
                this.refKeyMap.delete(rk);
            }
        }
        // mark as disposed
        node.tree = null;
        node.parent = null;
        // node.title = "DISPOSED: " + node.title
        // this.viewNodes.delete(node);
        node.removeMarkup();
    }
    /** Call all hook methods of all registered extensions.*/
    _callHook(hook, data = {}) {
        let res;
        let d = extend({}, { tree: this, options: this.options, result: undefined }, data);
        for (let ext of this.extensionList) {
            res = ext[hook].call(ext, d);
            if (res === false) {
                break;
            }
            if (d.result !== undefined) {
                res = d.result;
            }
        }
        return res;
    }
    /**
     * Call tree method or extension method if defined.
     *
     * Example:
     * ```js
     * tree._callMethod("edit.startEdit", "arg1", "arg2")
     * ```
     */
    _callMethod(name, ...args) {
        const [p, n] = name.split(".");
        const obj = n ? this.extensions[p] : this;
        const func = obj[n];
        if (func) {
            return func.apply(obj, args);
        }
        else {
            this.logError(`Calling undefined method '${name}()'.`);
        }
    }
    /**
     * Call event handler if defined in tree or tree.EXTENSION options.
     *
     * Example:
     * ```js
     * tree._callEvent("edit.beforeEdit", {foo: 42})
     * ```
     */
    _callEvent(type, extra) {
        const [p, n] = type.split(".");
        const opts = this.options;
        const func = n ? opts[p][n] : opts[p];
        if (func) {
            return func.call(this, extend({ type: type, tree: this, util: this._util }, extra));
            // } else {
            //   this.logError(`Triggering undefined event '${type}'.`)
        }
    }
    /** Return the node for  given row index. */
    _getNodeByRowIdx(idx) {
        // TODO: start searching from active node (reverse)
        let node = null;
        this.visitRows((n) => {
            if (n._rowIdx === idx) {
                node = n;
                return false;
            }
        });
        return node;
    }
    /** Return the topmost visible node in the viewport. */
    getTopmostVpNode(complete = true) {
        const gracePx = 1; // ignore subpixel scrolling
        const scrollParent = this.element;
        // const headerHeight = this.headerElement.clientHeight;  // May be 0
        const scrollTop = scrollParent.scrollTop; // + headerHeight;
        let topIdx;
        if (complete) {
            topIdx = Math.ceil((scrollTop - gracePx) / ROW_HEIGHT);
        }
        else {
            topIdx = Math.floor(scrollTop / ROW_HEIGHT);
        }
        return this._getNodeByRowIdx(topIdx);
    }
    /** Return the lowest visible node in the viewport. */
    getLowestVpNode(complete = true) {
        const scrollParent = this.element;
        const headerHeight = this.headerElement.clientHeight; // May be 0
        const scrollTop = scrollParent.scrollTop;
        const clientHeight = scrollParent.clientHeight - headerHeight;
        let bottomIdx;
        if (complete) {
            bottomIdx = Math.floor((scrollTop + clientHeight) / ROW_HEIGHT) - 1;
        }
        else {
            bottomIdx = Math.ceil((scrollTop + clientHeight) / ROW_HEIGHT) - 1;
        }
        bottomIdx = Math.min(bottomIdx, this.count(true) - 1);
        return this._getNodeByRowIdx(bottomIdx);
    }
    /** Return preceeding visible node in the viewport. */
    _getPrevNodeInView(node, ofs = 1) {
        this.visitRows((n) => {
            node = n;
            if (ofs-- <= 0) {
                return false;
            }
        }, { reverse: true, start: node || this.getActiveNode() });
        return node;
    }
    /** Return following visible node in the viewport. */
    _getNextNodeInView(node, ofs = 1) {
        this.visitRows((n) => {
            node = n;
            if (ofs-- <= 0) {
                return false;
            }
        }, { reverse: false, start: node || this.getActiveNode() });
        return node;
    }
    /**
     * Append (or insert) a list of toplevel nodes.
     *
     * @see {@link WunderbaumNode.addChildren}
     */
    addChildren(nodeData, options) {
        return this.root.addChildren(nodeData, options);
    }
    /**
     * Apply a modification or navigation operation.
     *
     * Most of these commands simply map to a node or tree method.
     * This method is especially useful when implementing keyboard mapping,
     * context menus, or external buttons.
     *
     * Valid commands:
     *   - 'moveUp', 'moveDown'
     *   - 'indent', 'outdent'
     *   - 'remove'
     *   - 'edit', 'addChild', 'addSibling': (reqires ext-edit extension)
     *   - 'cut', 'copy', 'paste': (use an internal singleton 'clipboard')
     *   - 'down', 'first', 'last', 'left', 'parent', 'right', 'up': navigate
     *
     */
    applyCommand(cmd, nodeOrOpts, options) {
        let // clipboard,
        node, refNode;
        // options = $.extend(
        // 	{ setActive: true, clipboard: CLIPBOARD },
        // 	options_
        // );
        if (nodeOrOpts instanceof WunderbaumNode) {
            node = nodeOrOpts;
        }
        else {
            node = this.getActiveNode();
            assert(options === undefined);
            options = nodeOrOpts;
        }
        // clipboard = options.clipboard;
        switch (cmd) {
            // Sorting and indentation:
            case "moveUp":
                refNode = node.getPrevSibling();
                if (refNode) {
                    node.moveTo(refNode, "before");
                    node.setActive();
                }
                break;
            case "moveDown":
                refNode = node.getNextSibling();
                if (refNode) {
                    node.moveTo(refNode, "after");
                    node.setActive();
                }
                break;
            case "indent":
                refNode = node.getPrevSibling();
                if (refNode) {
                    node.moveTo(refNode, "appendChild");
                    refNode.setExpanded();
                    node.setActive();
                }
                break;
            case "outdent":
                if (!node.isTopLevel()) {
                    node.moveTo(node.getParent(), "after");
                    node.setActive();
                }
                break;
            // Remove:
            case "remove":
                refNode = node.getPrevSibling() || node.getParent();
                node.remove();
                if (refNode) {
                    refNode.setActive();
                }
                break;
            // Add, edit (requires ext-edit):
            case "addChild":
                this._callMethod("edit.createNode", "prependChild");
                break;
            case "addSibling":
                this._callMethod("edit.createNode", "after");
                break;
            case "rename":
                this._callMethod("edit.startEditTitle");
                break;
            // Simple clipboard simulation:
            // case "cut":
            // 	clipboard = { mode: cmd, data: node };
            // 	break;
            // case "copy":
            // 	clipboard = {
            // 		mode: cmd,
            // 		data: node.toDict(function(d, n) {
            // 			delete d.key;
            // 		}),
            // 	};
            // 	break;
            // case "clear":
            // 	clipboard = null;
            // 	break;
            // case "paste":
            // 	if (clipboard.mode === "cut") {
            // 		// refNode = node.getPrevSibling();
            // 		clipboard.data.moveTo(node, "child");
            // 		clipboard.data.setActive();
            // 	} else if (clipboard.mode === "copy") {
            // 		node.addChildren(clipboard.data).setActive();
            // 	}
            // 	break;
            // Navigation commands:
            case "down":
            case "first":
            case "last":
            case "left":
            case "pageDown":
            case "pageUp":
            case "parent":
            case "right":
            case "up":
                return node.navigate(cmd);
            default:
                error(`Unhandled command: '${cmd}'`);
        }
    }
    /** Delete all nodes. */
    clear() {
        this.root.removeChildren();
        this.root.children = null;
        this.keyMap.clear();
        this.refKeyMap.clear();
        // this.viewNodes.clear();
        this.treeRowCount = 0;
        this.activeNode = null;
        this.focusNode = null;
        // this.types = {};
        // this. columns =[];
        // this._columnsById = {};
        // Modification Status
        // this.changedSince = 0;
        // this.changes.clear();
        // this.changedNodes.clear();
        // // --- FILTER ---
        // public filterMode: FilterModeType = null;
        // // --- KEYNAV ---
        // public activeColIdx = 0;
        // public cellNavMode = false;
        // public lastQuicksearchTime = 0;
        // public lastQuicksearchTerm = "";
        this.setModified(ChangeType.structure);
    }
    /**
     * Clear nodes and markup and detach events and observers.
     *
     * This method may be useful to free up resources before re-creating a tree
     * on an existing div, for example in unittest suites.
     * Note that this Wunderbaum instance becomes unusable afterwards.
     */
    destroy() {
        this.logInfo("destroy()...");
        this.clear();
        this.resizeObserver.disconnect();
        this.element.innerHTML = "";
        // Remove all event handlers
        this.element.outerHTML = this.element.outerHTML;
    }
    /**
     * Return `tree.option.NAME` (also resolving if this is a callback).
     *
     * See also {@link WunderbaumNode.getOption|WunderbaumNode.getOption()}
     * to evaluate `node.NAME` setting and `tree.types[node.type].NAME`.
     *
     * @param name option name (use dot notation to access extension option, e.g.
     * `filter.mode`)
     */
    getOption(name, defaultValue) {
        let ext;
        let opts = this.options;
        // Lookup `name` in options dict
        if (name.indexOf(".") >= 0) {
            [ext, name] = name.split(".");
            opts = opts[ext];
        }
        let value = opts[name];
        // A callback resolver always takes precedence
        if (typeof value === "function") {
            value = value({ type: "resolve", tree: this });
        }
        // Use value from value options dict, fallback do default
        // console.info(name, value, opts)
        return value !== null && value !== void 0 ? value : defaultValue;
    }
    /**
     * Set tree option.
     * Use dot notation to set plugin option, e.g. "filter.mode".
     */
    setOption(name, value) {
        // this.log(`setOption(${name}, ${value})`);
        if (name.indexOf(".") >= 0) {
            const parts = name.split(".");
            const ext = this.extensions[parts[0]];
            ext.setPluginOption(parts[1], value);
            return;
        }
        this.options[name] = value;
        switch (name) {
            case "checkbox":
                this.setModified(ChangeType.any);
                break;
            case "enabled":
                this.setEnabled(!!value);
                break;
            case "fixedCol":
                this.element.classList.toggle("wb-fixed-col", !!value);
                break;
        }
    }
    /** Return true if the tree (or one of its nodes) has the input focus. */
    hasFocus() {
        return this.element.contains(document.activeElement);
    }
    /**
     * Return true if the tree displays a header. Grids have a header unless the
     * `header` option is set to `false`. Plain trees have a header if the `header`
     * option is a string or `true`.
     */
    hasHeader() {
        const header = this.options.header;
        return this.isGrid() ? header !== false : !!header;
    }
    /** Run code, but defer rendering of viewport until done. */
    runWithoutUpdate(func, hint = null) {
        try {
            this.enableUpdate(false);
            const res = func();
            assert(!(res instanceof Promise));
            return res;
        }
        finally {
            this.enableUpdate(true);
        }
    }
    /** Recursively expand all expandable nodes (triggers lazy load id needed). */
    async expandAll(flag = true, options) {
        await this.root.expandAll(flag, options);
    }
    /** Recursively select all nodes. */
    selectAll(flag = true) {
        try {
            this.enableUpdate(false);
            this.visit((node) => {
                node.setSelected(flag);
            });
        }
        finally {
            this.enableUpdate(true);
        }
    }
    /** Return the number of nodes in the data model.*/
    count(visible = false) {
        if (visible) {
            return this.treeRowCount;
            // return this.viewNodes.size;
        }
        return this.keyMap.size;
    }
    /** @internal sanity check. */
    _check() {
        let i = 0;
        this.visit((n) => {
            i++;
        });
        if (this.keyMap.size !== i) {
            this.logWarn(`_check failed: ${this.keyMap.size} !== ${i}`);
        }
        // util.assert(this.keyMap.size === i);
    }
    /**
     * Find all nodes that match condition.
     *
     * @see {@link WunderbaumNode.findAll}
     */
    findAll(match) {
        return this.root.findAll(match);
    }
    /**
     * Find first node that matches condition.
     *
     * @see {@link WunderbaumNode.findFirst}
     */
    findFirst(match) {
        return this.root.findFirst(match);
    }
    /**
     * Find first node that matches condition.
     *
     * @param match title string to search for, or a
     *     callback function that returns `true` if a node is matched.
     * @see {@link WunderbaumNode.findFirst}
     *
     */
    findKey(key) {
        return this.keyMap.get(key) || null;
    }
    /**
     * Find the next visible node that starts with `match`, starting at `startNode`
     * and wrap-around at the end.
     */
    findNextNode(match, startNode) {
        //, visibleOnly) {
        let res = null, firstNode = this.getFirstChild();
        let matcher = typeof match === "string" ? makeNodeTitleStartMatcher(match) : match;
        startNode = startNode || firstNode;
        function _checkNode(n) {
            // console.log("_check " + n)
            if (matcher(n)) {
                res = n;
            }
            if (res || n === startNode) {
                return false;
            }
        }
        this.visitRows(_checkNode, {
            start: startNode,
            includeSelf: false,
        });
        // Wrap around search
        if (!res && startNode !== firstNode) {
            this.visitRows(_checkNode, {
                start: firstNode,
                includeSelf: true,
            });
        }
        return res;
    }
    /**
     * Find a node relative to another node.
     *
     * @param node
     * @param where 'down', 'first', 'last', 'left', 'parent', 'right', or 'up'.
     *   (Alternatively the keyCode that would normally trigger this move,
     *   e.g. `$.ui.keyCode.LEFT` = 'left'.
     * @param includeHidden Not yet implemented
     */
    findRelatedNode(node, where, includeHidden = false) {
        let res = null;
        const pageSize = Math.floor(this.listContainerElement.clientHeight / ROW_HEIGHT);
        switch (where) {
            case "parent":
                if (node.parent && node.parent.parent) {
                    res = node.parent;
                }
                break;
            case "first":
                // First visible node
                this.visit(function (n) {
                    if (n.isVisible()) {
                        res = n;
                        return false;
                    }
                });
                break;
            case "last":
                this.visit(function (n) {
                    // last visible node
                    if (n.isVisible()) {
                        res = n;
                    }
                });
                break;
            case "left":
                if (node.parent && node.parent.parent) {
                    res = node.parent;
                }
                // if (node.expanded) {
                //   node.setExpanded(false);
                // } else if (node.parent && node.parent.parent) {
                //   res = node.parent;
                // }
                break;
            case "right":
                if (node.children && node.children.length) {
                    res = node.children[0];
                }
                // if (this.cellNavMode) {
                //   throw new Error("Not implemented");
                // } else {
                //   if (!node.expanded && (node.children || node.lazy)) {
                //     node.setExpanded();
                //     res = node;
                //   } else if (node.children && node.children.length) {
                //     res = node.children[0];
                //   }
                // }
                break;
            case "up":
                res = this._getPrevNodeInView(node);
                break;
            case "down":
                res = this._getNextNodeInView(node);
                break;
            case "pageDown":
                const bottomNode = this.getLowestVpNode();
                // this.logDebug(`${where}(${node}) -> ${bottomNode}`);
                if (node._rowIdx < bottomNode._rowIdx) {
                    res = bottomNode;
                }
                else {
                    res = this._getNextNodeInView(node, pageSize);
                }
                break;
            case "pageUp":
                if (node._rowIdx === 0) {
                    res = node;
                }
                else {
                    const topNode = this.getTopmostVpNode();
                    // this.logDebug(`${where}(${node}) -> ${topNode}`);
                    if (node._rowIdx > topNode._rowIdx) {
                        res = topNode;
                    }
                    else {
                        res = this._getPrevNodeInView(node, pageSize);
                    }
                }
                break;
            default:
                this.logWarn("Unknown relation '" + where + "'.");
        }
        return res;
    }
    /**
     * Iterator version of {@link Wunderbaum.format}.
     */
    *format_iter(name_cb, connectors) {
        return this.root.format_iter(name_cb, connectors);
    }
    /**
     * Return multiline string representation of the node hierarchy.
     * Mostly useful for debugging.
     *
     * Example:
     * ```js
     * console.info(tree.format((n)=>n.title));
     * ```
     * logs
     * ```
     * Playground
     *  Books
     * |    Art of War
     * |    Don Quixote
     *  Music
     * ...
     * ```
     *
     * @see {@link Wunderbaum.format_iter} and {@link WunderbaumNode.format}.
     */
    format(name_cb, connectors) {
        return this.root.format(name_cb, connectors);
    }
    /**
     * Return the active cell (`span.wb-col`) of the currently active node or null.
     */
    getActiveColElem() {
        if (this.activeNode && this.activeColIdx >= 0) {
            return this.activeNode.getColElem(this.activeColIdx);
        }
        return null;
    }
    /**
     * Return the currently active node or null.
     */
    getActiveNode() {
        return this.activeNode;
    }
    /**
     * Return the first top level node if any (not the invisible root node).
     */
    getFirstChild() {
        return this.root.getFirstChild();
    }
    /**
     * Return the currently active node or null.
     */
    getFocusNode() {
        return this.focusNode;
    }
    /** Return a {node: WunderbaumNode, region: TYPE} object for a mouse event.
     *
     * @param {Event} event Mouse event, e.g. click, ...
     * @returns {object} Return a {node: WunderbaumNode, region: TYPE} object
     *     TYPE: 'title' | 'prefix' | 'expander' | 'checkbox' | 'icon' | undefined
     */
    static getEventInfo(event) {
        let target = event.target, cl = target.classList, parentCol = target.closest("span.wb-col"), node = Wunderbaum.getNode(target), tree = node ? node.tree : Wunderbaum.getTree(event), res = {
            tree: tree,
            node: node,
            region: NodeRegion.unknown,
            colDef: undefined,
            colIdx: -1,
            colId: undefined,
            colElem: parentCol,
        };
        if (cl.contains("wb-title")) {
            res.region = NodeRegion.title;
        }
        else if (cl.contains("wb-expander")) {
            res.region = node.isExpandable()
                ? NodeRegion.expander
                : NodeRegion.prefix;
        }
        else if (cl.contains("wb-checkbox")) {
            res.region = NodeRegion.checkbox;
        }
        else if (cl.contains("wb-icon")) {
            //|| cl.contains("wb-custom-icon")) {
            res.region = NodeRegion.icon;
        }
        else if (cl.contains("wb-node")) {
            res.region = NodeRegion.title;
        }
        else if (parentCol) {
            res.region = NodeRegion.column;
            const idx = Array.prototype.indexOf.call(parentCol.parentNode.children, parentCol);
            res.colIdx = idx;
        }
        else if (cl.contains("wb-row")) {
            // Plain tree
            res.region = NodeRegion.title;
        }
        else {
            // Somewhere near the title
            if (event.type !== "mousemove" && !(event instanceof KeyboardEvent)) {
                console.warn("getEventInfo(): not found", event, res);
            }
            return res;
        }
        if (res.colIdx === -1) {
            res.colIdx = 0;
        }
        res.colDef = tree === null || tree === void 0 ? void 0 : tree.columns[res.colIdx];
        res.colDef != null ? (res.colId = res.colDef.id) : 0;
        // this.log("Event", event, res);
        return res;
    }
    /**
     * Return readable string representation for this instance.
     * @internal
     */
    toString() {
        return `Wunderbaum<'${this.id}'>`;
    }
    /** Return true if any node is currently in edit-title mode. */
    isEditing() {
        return this._callMethod("edit.isEditingTitle");
    }
    /**
     * Return true if any node is currently beeing loaded, i.e. a Ajax request is pending.
     */
    isLoading() {
        var res = false;
        this.root.visit((n) => {
            // also visit rootNode
            if (n._isLoading || n._requestId) {
                res = true;
                return false;
            }
        }, true);
        return res;
    }
    /** Log to console if opts.debugLevel >= 4 */
    logDebug(...args) {
        if (this.options.debugLevel >= 4) {
            Array.prototype.unshift.call(args, this.toString());
            console.log.apply(console, args);
        }
    }
    /** Log error to console. */
    logError(...args) {
        if (this.options.debugLevel >= 1) {
            Array.prototype.unshift.call(args, this.toString());
            console.error.apply(console, args);
        }
    }
    /** Log to console if opts.debugLevel >= 3 */
    logInfo(...args) {
        if (this.options.debugLevel >= 3) {
            Array.prototype.unshift.call(args, this.toString());
            console.info.apply(console, args);
        }
    }
    /** @internal */
    logTime(label) {
        if (this.options.debugLevel >= 4) {
            console.time(this + ": " + label);
        }
        return label;
    }
    /** @internal */
    logTimeEnd(label) {
        if (this.options.debugLevel >= 4) {
            console.timeEnd(this + ": " + label);
        }
    }
    /** Log to console if opts.debugLevel >= 2 */
    logWarn(...args) {
        if (this.options.debugLevel >= 2) {
            Array.prototype.unshift.call(args, this.toString());
            console.warn.apply(console, args);
        }
    }
    /**
     * Make sure that this node is vertically scrolled into the viewport.
     *
     * Nodes that are above the visible area become the top row, nodes that are
     * below the viewport become the bottom row.
     */
    scrollTo(nodeOrOpts) {
        const PADDING = 2; // leave some pixels between viewport bounds
        let node;
        let options;
        if (nodeOrOpts instanceof WunderbaumNode) {
            node = nodeOrOpts;
        }
        else {
            options = nodeOrOpts;
            node = options.node;
        }
        assert(node && node._rowIdx != null);
        const scrollParent = this.element;
        const headerHeight = this.headerElement.clientHeight; // May be 0
        const scrollTop = scrollParent.scrollTop;
        const vpHeight = scrollParent.clientHeight;
        const rowTop = node._rowIdx * ROW_HEIGHT + headerHeight;
        const vpTop = headerHeight;
        const vpRowTop = rowTop - scrollTop;
        const vpRowBottom = vpRowTop + ROW_HEIGHT;
        const topNode = options === null || options === void 0 ? void 0 : options.topNode;
        // this.log( `scrollTo(${node.title}), vpTop:${vpTop}px, scrollTop:${scrollTop}, vpHeight:${vpHeight}, rowTop:${rowTop}, vpRowTop:${vpRowTop}`, nodeOrOpts , options);
        let newScrollTop = null;
        if (vpRowTop >= vpTop) {
            if (vpRowBottom <= vpHeight) ;
            else {
                // Node is below viewport
                // this.log("Below viewport");
                newScrollTop = rowTop + ROW_HEIGHT - vpHeight + PADDING; // leave some pixels between viewport bounds
            }
        }
        else {
            // Node is above viewport
            // this.log("Above viewport");
            newScrollTop = rowTop - vpTop - PADDING; // leave some pixels between viewport bounds
        }
        if (newScrollTop != null) {
            this.log(`scrollTo(${rowTop}): ${scrollTop} => ${newScrollTop}`);
            scrollParent.scrollTop = newScrollTop;
            if (topNode) {
                // Make sure the topNode is always visible
                this.scrollTo(topNode);
            }
            // this.setModified(ChangeType.scroll);
        }
    }
    /**
     * Make sure that this node is horizontally scrolled into the viewport.
     * Called by {@link setColumn}.
     */
    scrollToHorz() {
        // const PADDING = 1;
        const fixedWidth = this.columns[0]._widthPx;
        const vpWidth = this.element.clientWidth;
        const scrollLeft = this.element.scrollLeft;
        const colElem = this.getActiveColElem();
        const colLeft = Number.parseInt(colElem === null || colElem === void 0 ? void 0 : colElem.style.left, 10);
        const colRight = colLeft + Number.parseInt(colElem === null || colElem === void 0 ? void 0 : colElem.style.width, 10);
        let newLeft = scrollLeft;
        if (colLeft - scrollLeft < fixedWidth) {
            // The current column is scrolled behind the left fixed column
            newLeft = colLeft - fixedWidth;
        }
        else if (colRight - scrollLeft > vpWidth) {
            // The current column is scrolled outside the right side
            newLeft = colRight - vpWidth;
        }
        newLeft = Math.max(0, newLeft);
        // util.assert(node._rowIdx != null);
        this.log(`scrollToHorz(${this.activeColIdx}): ${colLeft}..${colRight}, fixedOfs=${fixedWidth}, vpWidth=${vpWidth}, curLeft=${scrollLeft} -> ${newLeft}`);
        this.element.scrollLeft = newLeft;
        // this.setModified(ChangeType.scroll);
    }
    /**
     * Set column #colIdx to 'active'.
     *
     * This higlights the column header and -cells by adding the `wb-active` class.
     * Available in cell-nav mode only.
     */
    setColumn(colIdx) {
        var _a;
        assert(this.isCellNav());
        assert(0 <= colIdx && colIdx < this.columns.length);
        this.activeColIdx = colIdx;
        // Update `wb-active` class for all headers
        if (this.hasHeader()) {
            for (let rowDiv of this.headerElement.children) {
                let i = 0;
                for (let colDiv of rowDiv.children) {
                    colDiv.classList.toggle("wb-active", i++ === colIdx);
                }
            }
        }
        (_a = this.activeNode) === null || _a === void 0 ? void 0 : _a.setModified(ChangeType.status);
        // Update `wb-active` class for all cell spans
        for (let rowDiv of this.nodeListElement.children) {
            let i = 0;
            for (let colDiv of rowDiv.children) {
                colDiv.classList.toggle("wb-active", i++ === colIdx);
            }
        }
        // Vertical scroll into view
        // if (this.options.fixedCol) {
        this.scrollToHorz();
        // }
    }
    /** Set or remove keybaord focus to the tree container. */
    setActiveNode(key, flag = true, options) {
        var _a;
        (_a = this.findKey(key)) === null || _a === void 0 ? void 0 : _a.setActive(flag, options);
    }
    /** Set or remove keybaord focus to the tree container. */
    setFocus(flag = true) {
        if (flag) {
            this.element.focus();
        }
        else {
            this.element.blur();
        }
    }
    setModified(change, node, options) {
        if (this._disableUpdateCount) {
            // Assuming that we redraw all when enableUpdate() is re-enabled.
            // this.log(
            //   `IGNORED setModified(${change}) node=${node} (disable level ${this._disableUpdateCount})`
            // );
            this._disableUpdateIgnoreCount++;
            return;
        }
        // this.log(`setModified(${change}) node=${node}`);
        if (!(node instanceof WunderbaumNode)) {
            options = node;
            node = null;
        }
        const immediate = !!getOption(options, "immediate");
        const RF = RenderFlag;
        const pending = this.pendingChangeTypes;
        switch (change) {
            case ChangeType.any:
            case ChangeType.colStructure:
                pending.add(RF.header);
                pending.add(RF.clearMarkup);
                pending.add(RF.redraw);
                pending.add(RF.scroll);
                break;
            case ChangeType.resize:
                // case ChangeType.colWidth:
                pending.add(RF.header);
                pending.add(RF.redraw);
                break;
            case ChangeType.structure:
                pending.add(RF.redraw);
                break;
            case ChangeType.scroll:
                pending.add(RF.scroll);
                break;
            case ChangeType.row:
            case ChangeType.data:
            case ChangeType.status:
                assert(node, `Option '${change}' requires a node.`);
                // Single nodes are immediately updated if already inside the viewport
                // (otherwise we can ignore)
                if (node._rowElem) {
                    node.render({ change: change });
                }
                break;
            default:
                error(`Invalid change type '${change}'.`);
        }
        if (change === ChangeType.colStructure) {
            const isGrid = this.isGrid();
            this.element.classList.toggle("wb-grid", isGrid);
            if (!isGrid && this.isCellNav()) {
                this.setCellNav(false);
            }
        }
        if (pending.size > 0) {
            if (immediate) {
                this._updateViewportImmediately();
            }
            else {
                this._updateViewportThrottled();
            }
        }
    }
    /** Disable mouse and keyboard interaction (return prev. state). */
    setEnabled(flag = true) {
        const prev = this.enabled;
        this.enabled = !!flag;
        this.element.classList.toggle("wb-disabled", !flag);
        return prev;
    }
    /** Return false if tree is disabled. */
    isEnabled() {
        return this.enabled;
    }
    /** Return true if tree has more than one column, i.e. has additional data columns. */
    isGrid() {
        return this.columns && this.columns.length > 1;
    }
    /** Return true if cell-navigation mode is acive. */
    isCellNav() {
        return !!this._cellNavMode;
    }
    /** Return true if row-navigation mode is acive. */
    isRowNav() {
        return !this._cellNavMode;
    }
    /** Set the tree's navigation mode. */
    setCellNav(flag = true) {
        var _a;
        const prev = this._cellNavMode;
        // if (flag === prev) {
        //   return;
        // }
        this._cellNavMode = !!flag;
        if (flag && !prev) {
            // switch from row to cell mode
            this.setColumn(0);
        }
        this.element.classList.toggle("wb-cell-mode", flag);
        (_a = this.activeNode) === null || _a === void 0 ? void 0 : _a.setModified(ChangeType.status);
    }
    /** Set the tree's navigation mode option. */
    setNavigationOption(mode, reset = false) {
        if (!this.isGrid() && mode !== NavModeEnum.row) {
            this.logWarn("Plain trees only support row navigation mode.");
            return;
        }
        this.options.navigationModeOption = mode;
        switch (mode) {
            case NavModeEnum.cell:
                this.setCellNav(true);
                break;
            case NavModeEnum.row:
                this.setCellNav(false);
                break;
            case NavModeEnum.startCell:
                if (reset) {
                    this.setCellNav(true);
                }
                break;
            case NavModeEnum.startRow:
                if (reset) {
                    this.setCellNav(false);
                }
                break;
            default:
                error(`Invalid mode '${mode}'.`);
        }
    }
    /** Display tree status (ok, loading, error, noData) using styles and a dummy root node. */
    setStatus(status, options) {
        return this.root.setStatus(status, options);
    }
    /** Add or redefine node type definitions. */
    setTypes(types, replace = true) {
        assert(isPlainObject(types));
        if (replace) {
            this.types = types;
        }
        else {
            extend(this.types, types);
        }
        // Convert `TYPE.classes` to a Set
        for (let t of Object.values(this.types)) {
            if (t.classes) {
                t.classes = toSet(t.classes);
            }
        }
    }
    /**
     * Sort nodes list by title or custom criteria.
     * @param {function} cmp custom compare function(a, b) that returns -1, 0, or 1
     *    (defaults to sorting by title).
     * @param {boolean} deep pass true to sort all descendant nodes recursively
     */
    sortChildren(cmp = nodeTitleSorter, deep = false) {
        this.root.sortChildren(cmp, deep);
    }
    /** Convert tree to an array of plain objects.
     *
     * @param callback(dict, node) is called for every node, in order to allow
     *     modifications.
     *     Return `false` to ignore this node or `"skip"` to include this node
     *     without its children.
     * @see {@link WunderbaumNode.toDict}.
     */
    toDictArray(callback) {
        var _a;
        const res = this.root.toDict(true, callback);
        return (_a = res.children) !== null && _a !== void 0 ? _a : [];
    }
    /**
     * Update column headers and column width.
     * Return true if at least one column width changed.
     */
    // _updateColumnWidths(options?: UpdateColumnsOptions): boolean {
    _updateColumnWidths() {
        // options = Object.assign({ updateRows: true, renderMarkup: false }, options);
        const defaultMinWidth = 4;
        const vpWidth = this.element.clientWidth;
        // Shorten last column width to avoid h-scrollbar
        const FIX_ADJUST_LAST_COL = 2;
        const columns = this.columns;
        const col0 = columns[0];
        let totalWidth = 0;
        let totalWeight = 0;
        let fixedWidth = 0;
        let modified = false;
        // this.element.classList.toggle("wb-grid", isGrid);
        // if (!isGrid && this.isCellNav()) {
        //   this.setCellNav(false);
        // }
        // if (options.calculateCols) {
        if (col0.id !== "*") {
            throw new Error(`First column must have  id '*': got '${col0.id}'.`);
        }
        // Gather width definitions
        this._columnsById = {};
        for (let col of columns) {
            this._columnsById[col.id] = col;
            let cw = col.width;
            if (col.id === "*" && col !== col0) {
                throw new Error(`Column id '*' must be defined only once: '${col.title}'.`);
            }
            if (!cw || cw === "*") {
                col._weight = 1.0;
                totalWeight += 1.0;
            }
            else if (typeof cw === "number") {
                col._weight = cw;
                totalWeight += cw;
            }
            else if (typeof cw === "string" && cw.endsWith("px")) {
                col._weight = 0;
                let px = parseFloat(cw.slice(0, -2));
                if (col._widthPx != px) {
                    modified = true;
                    col._widthPx = px;
                }
                fixedWidth += px;
            }
            else {
                error(`Invalid column width: ${cw} (expected string ending with 'px' or number, e.g. "<num>px" or <int>).`);
            }
        }
        // Share remaining space between non-fixed columns
        const restPx = Math.max(0, vpWidth - fixedWidth);
        let ofsPx = 0;
        for (let col of columns) {
            let minWidth;
            if (col._weight) {
                const cmw = col.minWidth;
                if (typeof cmw === "number") {
                    minWidth = cmw;
                }
                else if (typeof cmw === "string" && cmw.endsWith("px")) {
                    minWidth = parseFloat(cmw.slice(0, -2));
                }
                else {
                    minWidth = defaultMinWidth;
                }
                const px = Math.max(minWidth, (restPx * col._weight) / totalWeight);
                if (col._widthPx != px) {
                    modified = true;
                    col._widthPx = px;
                }
            }
            col._ofsPx = ofsPx;
            ofsPx += col._widthPx;
        }
        columns[columns.length - 1]._widthPx -= FIX_ADJUST_LAST_COL;
        totalWidth = ofsPx - FIX_ADJUST_LAST_COL;
        const tw = `${totalWidth}px`;
        this.headerElement.style.width = tw;
        this.listContainerElement.style.width = tw;
        // }
        // Every column has now a calculated `_ofsPx` and `_widthPx`
        // this.logInfo("UC", this.columns, vpWidth, this.element.clientWidth, this.element);
        // console.trace();
        // util.error("BREAK");
        // if (modified) {
        //   this._renderHeaderMarkup();
        //   if (options.renderMarkup) {
        //     this.setModified(ChangeType.header, { removeMarkup: true });
        //   } else if (options.updateRows) {
        //     this._updateRows();
        //   }
        // }
        return modified;
    }
    /** Create/update header markup from `this.columns` definition.
     * @internal
     */
    _renderHeaderMarkup() {
        assert(this.headerElement);
        const wantHeader = this.hasHeader();
        setElemDisplay(this.headerElement, wantHeader);
        if (!wantHeader) {
            return;
        }
        const colCount = this.columns.length;
        const headerRow = this.headerElement.querySelector(".wb-row");
        assert(headerRow);
        headerRow.innerHTML = "<span class='wb-col'></span>".repeat(colCount);
        for (let i = 0; i < colCount; i++) {
            const col = this.columns[i];
            const colElem = headerRow.children[i];
            colElem.style.left = col._ofsPx + "px";
            colElem.style.width = col._widthPx + "px";
            // Add classes from `columns` definition to `<div.wb-col>` cells
            if (typeof col.headerClasses === "string") {
                col.headerClasses
                    ? colElem.classList.add(...col.headerClasses.split(" "))
                    : 0;
            }
            else {
                col.classes ? colElem.classList.add(...col.classes.split(" ")) : 0;
            }
            const title = escapeHtml(col.title || col.id);
            let tooltip = "";
            if (col.tooltip) {
                tooltip = escapeTooltip(col.tooltip);
                tooltip = ` title="${tooltip}"`;
            }
            let resizer = "";
            if (i < colCount - 1) {
                resizer = '<span class="wb-col-resizer"></span>';
            }
            colElem.innerHTML = `<span class="wb-col-title"${tooltip}>${title}</span>${resizer}`;
            if (this.isCellNav()) {
                colElem.classList.toggle("wb-active", i === this.activeColIdx);
            }
        }
    }
    /**
     * Render pending changes that were scheduled using {@link WunderbaumNode.setModified} if any.
     *
     * This is hardly ever neccessary, since we normally either
     * - call `setModified(ChangeType.TYPE)` (async, throttled), or
     * - call `setModified(ChangeType.TYPE, {immediate: true})` (synchronous)
     *
     * `updatePendingModifications()` will only force immediate execution of
     * pending async changes if any.
     */
    updatePendingModifications() {
        if (this.pendingChangeTypes.size > 0) {
            this._updateViewportImmediately();
        }
    }
    /**
     * This is the actual update method, which is wrapped inside a throttle method.
     * It calls `updateColumns()` and `_updateRows()`.
     *
     * This protected method should not be called directly but via
     * {@link WunderbaumNode.setModified}`, {@link Wunderbaum.setModified},
     * or {@link Wunderbaum.updatePendingModifications}.
     * @internal
     */
    _updateViewportImmediately() {
        var _a;
        if (this._disableUpdateCount) {
            this.log(`_updateViewportImmediately() IGNORED (disable level: ${this._disableUpdateCount})`);
            this._disableUpdateIgnoreCount++;
            return;
        }
        // Shorten container height to avoid v-scrollbar
        const FIX_ADJUST_HEIGHT = 1;
        const RF = RenderFlag;
        const pending = new Set(this.pendingChangeTypes);
        this.pendingChangeTypes.clear();
        const scrollOnly = pending.has(RF.scroll) && pending.size === 1;
        if (scrollOnly) {
            this._updateRows({ newNodesOnly: true });
            // this.log("_updateViewportImmediately(): scroll only.");
        }
        else {
            this.log("_updateViewportImmediately():", pending);
            let height = this.listContainerElement.clientHeight;
            // We cannot get the height for absolute positioned parent, so look at first col
            // let headerHeight = this.headerElement.clientHeight
            // let headerHeight = this.headerElement.children[0].children[0].clientHeight;
            // const headerHeight = this.options.headerHeightPx;
            const headerHeight = this.headerElement.clientHeight; // May be 0
            const wantHeight = this.element.clientHeight - headerHeight - FIX_ADJUST_HEIGHT;
            if (Math.abs(height - wantHeight) > 1.0) {
                // this.log("resize", height, wantHeight);
                this.listContainerElement.style.height = wantHeight + "px";
                height = wantHeight;
            }
            // console.profile(`_updateViewportImmediately()`)
            if (pending.has(RF.clearMarkup)) {
                this.visit((n) => {
                    n.removeMarkup();
                });
            }
            // let widthModified = false;
            if (pending.has(RF.header)) {
                // widthModified = this._updateColumnWidths();
                this._updateColumnWidths();
                this._renderHeaderMarkup();
            }
            this._updateRows();
            // console.profileEnd(`_updateViewportImmediately()`)
        }
        if (this.options.connectTopBreadcrumb) {
            let path = (_a = this.getTopmostVpNode(true)) === null || _a === void 0 ? void 0 : _a.getPath(false, "title", " > ");
            path = path ? path + " >" : "";
            this.options.connectTopBreadcrumb.textContent = path;
        }
        this._callEvent("update");
    }
    // /**
    //  * Assert that TR order matches the natural node order
    //  * @internal
    //  */
    // protected _validateRows(): boolean {
    //   let trs = this.nodeListElement.childNodes;
    //   let i = 0;
    //   let prev = -1;
    //   let ok = true;
    //   trs.forEach((element) => {
    //     const tr = element as HTMLTableRowElement;
    //     const top = Number.parseInt(tr.style.top);
    //     const n = (<any>tr)._wb_node;
    //     // if (i < 4) {
    //     //   console.info(
    //     //     `TR#${i}, rowIdx=${n._rowIdx} , top=${top}px: '${n.title}'`
    //     //   );
    //     // }
    //     if (prev >= 0 && top !== prev + ROW_HEIGHT) {
    //       n.logWarn(
    //         `TR order mismatch at index ${i}: top=${top}px != ${
    //           prev + ROW_HEIGHT
    //         }`
    //       );
    //       // throw new Error("fault");
    //       ok = false;
    //     }
    //     prev = top;
    //     i++;
    //   });
    //   return ok;
    // }
    /*
     * - Traverse all *visible* nodes of the whole tree, i.e. skip collapsed nodes.
     * - Store count of rows to `tree.treeRowCount`.
     * - Renumber `node._rowIdx` for all visible nodes.
     * - Calculate the index range that must be rendered to fill the viewport
     *   (including upper and lower prefetch)
     * -
     */
    _updateRows(options) {
        // const label = this.logTime("_updateRows");
        // this.log("_updateRows", opts)
        options = Object.assign({ newNodesOnly: false }, options);
        const newNodesOnly = !!options.newNodesOnly;
        const row_height = ROW_HEIGHT;
        const vp_height = this.element.clientHeight;
        const prefetch = RENDER_MAX_PREFETCH;
        // const grace_prefetch = RENDER_MAX_PREFETCH - RENDER_MIN_PREFETCH;
        const ofs = this.element.scrollTop;
        let startIdx = Math.max(0, ofs / row_height - prefetch);
        startIdx = Math.floor(startIdx);
        // Make sure start is always even, so the alternating row colors don't
        // change when scrolling:
        if (startIdx % 2) {
            startIdx--;
        }
        let endIdx = Math.max(0, (ofs + vp_height) / row_height + prefetch);
        endIdx = Math.ceil(endIdx);
        // const obsoleteViewNodes = this.viewNodes;
        // this.viewNodes = new Set();
        // const viewNodes = this.viewNodes;
        // this.debug("render", opts);
        const obsoleteNodes = new Set();
        this.nodeListElement.childNodes.forEach((elem) => {
            const tr = elem;
            obsoleteNodes.add(tr._wb_node);
        });
        let idx = 0;
        let top = 0;
        let modified = false;
        let prevElem = "first";
        this.visitRows(function (node) {
            // node.log("visit")
            const rowDiv = node._rowElem;
            // Renumber all expanded nodes
            if (node._rowIdx !== idx) {
                node._rowIdx = idx;
                modified = true;
            }
            if (idx < startIdx || idx > endIdx) {
                // row is outside viewport bounds
                if (rowDiv) {
                    prevElem = rowDiv;
                }
            }
            else if (rowDiv && newNodesOnly) {
                obsoleteNodes.delete(node);
                // no need to update existing node markup
                rowDiv.style.top = idx * ROW_HEIGHT + "px";
                prevElem = rowDiv;
            }
            else {
                obsoleteNodes.delete(node);
                // Create new markup
                if (rowDiv) {
                    rowDiv.style.top = idx * ROW_HEIGHT + "px";
                }
                node.render({ top: top, after: prevElem });
                // node.log("render", top, prevElem, "=>", node._rowElem);
                prevElem = node._rowElem;
            }
            idx++;
            top += row_height;
        });
        this.treeRowCount = idx;
        for (const n of obsoleteNodes) {
            n._callEvent("discard");
            n.removeMarkup();
        }
        // Resize tree container
        this.nodeListElement.style.height = `${top}px`;
        // this.log(
        //   `_updateRows(scrollOfs:${ofs}, ${startIdx}..${endIdx})`,
        //   this.nodeListElement.style.height
        // );
        // this.logTimeEnd(label);
        // this._validateRows();
        return modified;
    }
    /**
     * Call `callback(node)` for all nodes in hierarchical order (depth-first, pre-order).
     * @see {@link IterableIterator<WunderbaumNode>}, {@link WunderbaumNode.visit}.
     *
     * @param {function} callback the callback function.
     *     Return false to stop iteration, return "skip" to skip this node and
     *     children only.
     * @returns {boolean} false, if the iterator was stopped.
     */
    visit(callback) {
        return this.root.visit(callback, false);
    }
    /**
     * Call callback(node) for all nodes in vertical order, top down (or bottom up).
     *
     * Note that this considers expansion state, i.e. filtered nodes and children
     * of collapsed nodes are skipped, unless `includeHidden` is set.
     *
     * Stop iteration if callback() returns false.<br>
     * Return false if iteration was stopped.
     *
     * @returns {boolean} false if iteration was canceled
     */
    visitRows(callback, options) {
        if (!this.root.hasChildren()) {
            return false;
        }
        if (options && options.reverse) {
            delete options.reverse;
            return this._visitRowsUp(callback, options);
        }
        options = options || {};
        let i, nextIdx, parent, res, siblings, stopNode, siblingOfs = 0, skipFirstNode = options.includeSelf === false, includeHidden = !!options.includeHidden, checkFilter = !includeHidden && this.filterMode === "hide", node = options.start || this.root.children[0];
        parent = node.parent;
        while (parent) {
            // visit siblings
            siblings = parent.children;
            nextIdx = siblings.indexOf(node) + siblingOfs;
            assert(nextIdx >= 0, `Could not find ${node} in parent's children: ${parent}`);
            for (i = nextIdx; i < siblings.length; i++) {
                node = siblings[i];
                if (node === stopNode) {
                    return false;
                }
                if (checkFilter &&
                    !node.statusNodeType &&
                    !node.match &&
                    !node.subMatchCount) {
                    continue;
                }
                if (!skipFirstNode && callback(node) === false) {
                    return false;
                }
                skipFirstNode = false;
                // Dive into node's child nodes
                if (node.children &&
                    node.children.length &&
                    (includeHidden || node.expanded)) {
                    res = node.visit(function (n) {
                        if (n === stopNode) {
                            return false;
                        }
                        if (checkFilter && !n.match && !n.subMatchCount) {
                            return "skip";
                        }
                        if (callback(n) === false) {
                            return false;
                        }
                        if (!includeHidden && n.children && !n.expanded) {
                            return "skip";
                        }
                    }, false);
                    if (res === false) {
                        return false;
                    }
                }
            }
            // Visit parent nodes (bottom up)
            node = parent;
            parent = parent.parent;
            siblingOfs = 1; //
            if (!parent && options.wrap) {
                this.logDebug("visitRows(): wrap around");
                assert(options.start, "`wrap` option requires `start`");
                stopNode = options.start;
                options.wrap = false;
                parent = this.root;
                siblingOfs = 0;
            }
        }
        return true;
    }
    /**
     * Call fn(node) for all nodes in vertical order, bottom up.
     * @internal
     */
    _visitRowsUp(callback, options) {
        let children, idx, parent, includeHidden = !!options.includeHidden, node = options.start || this.root.children[0];
        if (options.includeSelf !== false) {
            if (callback(node) === false) {
                return false;
            }
        }
        while (true) {
            parent = node.parent;
            children = parent.children;
            if (children[0] === node) {
                // If this is already the first sibling, goto parent
                node = parent;
                if (!node.parent) {
                    break; // first node of the tree
                }
                children = parent.children;
            }
            else {
                // Otherwise, goto prev. sibling
                idx = children.indexOf(node);
                node = children[idx - 1];
                // If the prev. sibling has children, follow down to last descendant
                while ((includeHidden || node.expanded) &&
                    node.children &&
                    node.children.length) {
                    children = node.children;
                    parent = node;
                    node = children[children.length - 1];
                }
            }
            // Skip invisible
            if (!includeHidden && !node.isVisible()) {
                continue;
            }
            if (callback(node) === false) {
                return false;
            }
        }
        return true;
    }
    /**
     * Reload the tree with a new source.
     *
     * Previous data is cleared. Note that also column- and type defintions may
     * be passed with the `source` object.
     */
    load(source) {
        this.clear();
        return this.root.load(source);
    }
    /**
     * Disable render requests during operations that would trigger many updates.
     *
     * ```js
     * try {
     *   tree.enableUpdate(false);
     *   // ... (long running operation that would trigger many updates)
     *   foo();
     *   // ... NOTE: make sure that async operations have finished, e.g.
     *   await foo();
     * } finally {
     *   tree.enableUpdate(true);
     * }
     * ```
     */
    enableUpdate(flag) {
        /*
            5  7  9                20       25   30
        1   >-------------------------------------<
        2      >--------------------<
        3         >--------------------------<
        */
        if (flag) {
            assert(this._disableUpdateCount > 0, "enableUpdate(true) was called too often");
            this._disableUpdateCount--;
            // this.logDebug(
            //   `enableUpdate(${flag}): count -> ${this._disableUpdateCount}...`
            // );
            if (this._disableUpdateCount === 0) {
                this.logDebug(`enableUpdate(): active again. Re-painting to catch up with ${this._disableUpdateIgnoreCount} ignored update requests...`);
                this._disableUpdateIgnoreCount = 0;
                this.setModified(ChangeType.any, { immediate: true });
            }
        }
        else {
            this._disableUpdateCount++;
            // this.logDebug(
            //   `enableUpdate(${flag}): count -> ${this._disableUpdateCount}...`
            // );
            // this._disableUpdate = Date.now();
        }
        // return !flag; // return previous value
    }
    /* ---------------------------------------------------------------------------
     * FILTER
     * -------------------------------------------------------------------------*/
    /**
     * [ext-filter] Dim or hide nodes.
     */
    filterNodes(filter, options) {
        return this.extensions.filter.filterNodes(filter, options);
    }
    /**
     * [ext-filter] Dim or hide whole branches.
     */
    filterBranches(filter, options) {
        return this.extensions.filter.filterBranches(filter, options);
    }
    /**
     * [ext-filter] Reset the filter.
     *
     * @requires [[FilterExtension]]
     */
    clearFilter() {
        return this.extensions.filter.clearFilter();
    }
    /**
     * [ext-filter] Return true if a filter is currently applied.
     *
     * @requires [[FilterExtension]]
     */
    isFilterActive() {
        return !!this.filterMode;
    }
    /**
     * [ext-filter] Re-apply current filter.
     *
     * @requires [[FilterExtension]]
     */
    updateFilter() {
        return this.extensions.filter.updateFilter();
    }
}
Wunderbaum.sequence = 0;
/** Wunderbaum release version number "MAJOR.MINOR.PATCH". */
Wunderbaum.version = "v0.3.5"; // Set to semver by 'grunt release'
/** Expose some useful methods of the util.ts module as `Wunderbaum.util`. */
Wunderbaum.util = util;




/***/ }),

/***/ "./node_modules/.pnpm/crypto-hash@2.0.1/node_modules/crypto-hash/browser.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/crypto-hash@2.0.1/node_modules/crypto-hash/browser.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sha256": () => (/* binding */ sha256)
/* harmony export */ });
/* unused harmony exports sha1, sha384, sha512 */
/* eslint-env browser */

const bufferToHex = buffer => {
	const view = new DataView(buffer);

	let hexCodes = '';
	for (let index = 0; index < view.byteLength; index += 4) {
		hexCodes += view.getUint32(index).toString(16).padStart(8, '0');
	}

	return hexCodes;
};

const create = algorithm => async (buffer, {outputFormat = 'hex'} = {}) => {
	if (typeof buffer === 'string') {
		buffer = new globalThis.TextEncoder().encode(buffer);
	}

	const hash = await globalThis.crypto.subtle.digest(algorithm, buffer);

	return outputFormat === 'hex' ? bufferToHex(hash) : hash;
};

const sha1 = create('SHA-1');
const sha256 = create('SHA-256');
const sha384 = create('SHA-384');
const sha512 = create('SHA-512');


/***/ }),

/***/ "./node_modules/.pnpm/svelte@3.50.1/node_modules/svelte/index.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/svelte@3.50.1/node_modules/svelte/index.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createEventDispatcher": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.createEventDispatcher),
/* harmony export */   "onDestroy": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.onDestroy),
/* harmony export */   "onMount": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.onMount)
/* harmony export */ });
/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/index.mjs */ "./node_modules/.pnpm/svelte@3.50.1/node_modules/svelte/internal/index.mjs");



/***/ }),

/***/ "./node_modules/.pnpm/svelte@3.50.1/node_modules/svelte/internal/index.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/svelte@3.50.1/node_modules/svelte/internal/index.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SvelteComponentDev": () => (/* binding */ SvelteComponentDev),
/* harmony export */   "add_location": () => (/* binding */ add_location),
/* harmony export */   "append_dev": () => (/* binding */ append_dev),
/* harmony export */   "assign": () => (/* binding */ assign),
/* harmony export */   "attr_dev": () => (/* binding */ attr_dev),
/* harmony export */   "binding_callbacks": () => (/* binding */ binding_callbacks),
/* harmony export */   "check_outros": () => (/* binding */ check_outros),
/* harmony export */   "component_subscribe": () => (/* binding */ component_subscribe),
/* harmony export */   "createEventDispatcher": () => (/* binding */ createEventDispatcher),
/* harmony export */   "create_component": () => (/* binding */ create_component),
/* harmony export */   "create_slot": () => (/* binding */ create_slot),
/* harmony export */   "current_component": () => (/* binding */ current_component),
/* harmony export */   "destroy_component": () => (/* binding */ destroy_component),
/* harmony export */   "detach_dev": () => (/* binding */ detach_dev),
/* harmony export */   "dispatch_dev": () => (/* binding */ dispatch_dev),
/* harmony export */   "element": () => (/* binding */ element),
/* harmony export */   "empty": () => (/* binding */ empty),
/* harmony export */   "exclude_internal_props": () => (/* binding */ exclude_internal_props),
/* harmony export */   "get_all_dirty_from_scope": () => (/* binding */ get_all_dirty_from_scope),
/* harmony export */   "get_current_component": () => (/* binding */ get_current_component),
/* harmony export */   "get_slot_changes": () => (/* binding */ get_slot_changes),
/* harmony export */   "get_spread_update": () => (/* binding */ get_spread_update),
/* harmony export */   "get_store_value": () => (/* binding */ get_store_value),
/* harmony export */   "globals": () => (/* binding */ globals),
/* harmony export */   "group_outros": () => (/* binding */ group_outros),
/* harmony export */   "handle_promise": () => (/* binding */ handle_promise),
/* harmony export */   "init": () => (/* binding */ init),
/* harmony export */   "insert": () => (/* binding */ insert),
/* harmony export */   "insert_dev": () => (/* binding */ insert_dev),
/* harmony export */   "insert_hydration": () => (/* binding */ insert_hydration),
/* harmony export */   "is_function": () => (/* binding */ is_function),
/* harmony export */   "listen_dev": () => (/* binding */ listen_dev),
/* harmony export */   "mount_component": () => (/* binding */ mount_component),
/* harmony export */   "noop": () => (/* binding */ noop),
/* harmony export */   "onDestroy": () => (/* binding */ onDestroy),
/* harmony export */   "onMount": () => (/* binding */ onMount),
/* harmony export */   "run_all": () => (/* binding */ run_all),
/* harmony export */   "safe_not_equal": () => (/* binding */ safe_not_equal),
/* harmony export */   "set_attributes": () => (/* binding */ set_attributes),
/* harmony export */   "set_current_component": () => (/* binding */ set_current_component),
/* harmony export */   "set_data_dev": () => (/* binding */ set_data_dev),
/* harmony export */   "set_style": () => (/* binding */ set_style),
/* harmony export */   "set_svg_attributes": () => (/* binding */ set_svg_attributes),
/* harmony export */   "space": () => (/* binding */ space),
/* harmony export */   "subscribe": () => (/* binding */ subscribe),
/* harmony export */   "svg_element": () => (/* binding */ svg_element),
/* harmony export */   "text": () => (/* binding */ text),
/* harmony export */   "transition_in": () => (/* binding */ transition_in),
/* harmony export */   "transition_out": () => (/* binding */ transition_out),
/* harmony export */   "update_await_block_branch": () => (/* binding */ update_await_block_branch),
/* harmony export */   "update_slot_base": () => (/* binding */ update_slot_base),
/* harmony export */   "validate_slots": () => (/* binding */ validate_slots),
/* harmony export */   "validate_store": () => (/* binding */ validate_store)
/* harmony export */ });
/* unused harmony exports HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_render_callback, add_resize_listener, add_styles, add_transform, afterUpdate, append, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, attr, attribute_to_object, beforeUpdate, bind, blank_object, bubble, children, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, compute_rest_props, compute_slots, create_animation, create_bidirectional_transition, create_in_transition, create_out_transition, create_ssr_component, custom_event, dataset_dev, debug, destroy_block, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, dirty_components, each, element_is, end_hydrating, escape, escape_attribute_value, escape_object, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getAllContexts, getContext, get_binding_group_value, get_custom_elements_slots, get_root_for_style, get_spread_object, hasContext, has_prop, identity, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_promise, is_void, listen, loop, loop_guard, merge_ssr_styles, missing_component, not_equal, now, null_to_empty, object_without_properties, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_custom_element_data, set_data, set_input_type, set_input_value, set_now, set_raf, set_store_value, spread, src_url_equal, start_hydrating, stop_propagation, tick, time_ranges_to_array, to_number, toggle_class, trusted, update_keyed_each, update_slot, validate_component, validate_dynamic_element, validate_each_argument, validate_each_keys, validate_void_dynamic_element, xlink_attr */
function noop() { }
const identity = x => x;
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function is_promise(value) {
    return value && typeof value === 'object' && typeof value.then === 'function';
}
function add_location(element, file, line, column, char) {
    element.__svelte_meta = {
        loc: { file, line, column, char }
    };
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
let src_url_equal_anchor;
function src_url_equal(element_src, url) {
    if (!src_url_equal_anchor) {
        src_url_equal_anchor = document.createElement('a');
    }
    src_url_equal_anchor.href = url;
    return element_src === src_url_equal_anchor.href;
}
function not_equal(a, b) {
    return a != a ? b == b : a !== b;
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function validate_store(store, name) {
    if (store != null && typeof store.subscribe !== 'function') {
        throw new Error(`'${name}' is not a store with a 'subscribe' method`);
    }
}
function subscribe(store, ...callbacks) {
    if (store == null) {
        return noop;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
    let value;
    subscribe(store, _ => value = _)();
    return value;
}
function component_subscribe(component, store, callback) {
    component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
    }
}
function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn
        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
        : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
            return lets;
        }
        if (typeof lets === 'object') {
            const merged = [];
            const len = Math.max($$scope.dirty.length, lets.length);
            for (let i = 0; i < len; i += 1) {
                merged[i] = $$scope.dirty[i] | lets[i];
            }
            return merged;
        }
        return $$scope.dirty | lets;
    }
    return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
    if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
    }
}
function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);
}
function get_all_dirty_from_scope($$scope) {
    if ($$scope.ctx.length > 32) {
        const dirty = [];
        const length = $$scope.ctx.length / 32;
        for (let i = 0; i < length; i++) {
            dirty[i] = -1;
        }
        return dirty;
    }
    return -1;
}
function exclude_internal_props(props) {
    const result = {};
    for (const k in props)
        if (k[0] !== '$')
            result[k] = props[k];
    return result;
}
function compute_rest_props(props, keys) {
    const rest = {};
    keys = new Set(keys);
    for (const k in props)
        if (!keys.has(k) && k[0] !== '$')
            rest[k] = props[k];
    return rest;
}
function compute_slots(slots) {
    const result = {};
    for (const key in slots) {
        result[key] = true;
    }
    return result;
}
function once(fn) {
    let ran = false;
    return function (...args) {
        if (ran)
            return;
        ran = true;
        fn.call(this, ...args);
    };
}
function null_to_empty(value) {
    return value == null ? '' : value;
}
function set_store_value(store, ret, value) {
    store.set(value);
    return ret;
}
const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
function action_destroyer(action_result) {
    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

const is_client = typeof window !== 'undefined';
let now = is_client
    ? () => window.performance.now()
    : () => Date.now();
let raf = is_client ? cb => requestAnimationFrame(cb) : noop;
// used internally for testing
function set_now(fn) {
    now = fn;
}
function set_raf(fn) {
    raf = fn;
}

const tasks = new Set();
function run_tasks(now) {
    tasks.forEach(task => {
        if (!task.c(now)) {
            tasks.delete(task);
            task.f();
        }
    });
    if (tasks.size !== 0)
        raf(run_tasks);
}
/**
 * For testing purposes only!
 */
function clear_loops() {
    tasks.clear();
}
/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 */
function loop(callback) {
    let task;
    if (tasks.size === 0)
        raf(run_tasks);
    return {
        promise: new Promise(fulfill => {
            tasks.add(task = { c: callback, f: fulfill });
        }),
        abort() {
            tasks.delete(task);
        }
    };
}

// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM
// at the end of hydration without touching the remaining nodes.
let is_hydrating = false;
function start_hydrating() {
    is_hydrating = true;
}
function end_hydrating() {
    is_hydrating = false;
}
function upper_bound(low, high, key, value) {
    // Return first index of value larger than input value in the range [low, high)
    while (low < high) {
        const mid = low + ((high - low) >> 1);
        if (key(mid) <= value) {
            low = mid + 1;
        }
        else {
            high = mid;
        }
    }
    return low;
}
function init_hydrate(target) {
    if (target.hydrate_init)
        return;
    target.hydrate_init = true;
    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>
    let children = target.childNodes;
    // If target is <head>, there may be children without claim_order
    if (target.nodeName === 'HEAD') {
        const myChildren = [];
        for (let i = 0; i < children.length; i++) {
            const node = children[i];
            if (node.claim_order !== undefined) {
                myChildren.push(node);
            }
        }
        children = myChildren;
    }
    /*
    * Reorder claimed children optimally.
    * We can reorder claimed children optimally by finding the longest subsequence of
    * nodes that are already claimed in order and only moving the rest. The longest
    * subsequence subsequence of nodes that are claimed in order can be found by
    * computing the longest increasing subsequence of .claim_order values.
    *
    * This algorithm is optimal in generating the least amount of reorder operations
    * possible.
    *
    * Proof:
    * We know that, given a set of reordering operations, the nodes that do not move
    * always form an increasing subsequence, since they do not move among each other
    * meaning that they must be already ordered among each other. Thus, the maximal
    * set of nodes that do not move form a longest increasing subsequence.
    */
    // Compute longest increasing subsequence
    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j
    const m = new Int32Array(children.length + 1);
    // Predecessor indices + 1
    const p = new Int32Array(children.length);
    m[0] = -1;
    let longest = 0;
    for (let i = 0; i < children.length; i++) {
        const current = children[i].claim_order;
        // Find the largest subsequence length such that it ends in a value less than our current value
        // upper_bound returns first greater value, so we subtract one
        // with fast path for when we are on the current longest subsequence
        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;
        p[i] = m[seqLen] + 1;
        const newLen = seqLen + 1;
        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.
        m[newLen] = i;
        longest = Math.max(newLen, longest);
    }
    // The longest increasing subsequence of nodes (initially reversed)
    const lis = [];
    // The rest of the nodes, nodes that will be moved
    const toMove = [];
    let last = children.length - 1;
    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {
        lis.push(children[cur - 1]);
        for (; last >= cur; last--) {
            toMove.push(children[last]);
        }
        last--;
    }
    for (; last >= 0; last--) {
        toMove.push(children[last]);
    }
    lis.reverse();
    // We sort the nodes being moved to guarantee that their insertion order matches the claim order
    toMove.sort((a, b) => a.claim_order - b.claim_order);
    // Finally, we move the nodes
    for (let i = 0, j = 0; i < toMove.length; i++) {
        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {
            j++;
        }
        const anchor = j < lis.length ? lis[j] : null;
        target.insertBefore(toMove[i], anchor);
    }
}
function append(target, node) {
    target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
    const append_styles_to = get_root_for_style(target);
    if (!append_styles_to.getElementById(style_sheet_id)) {
        const style = element('style');
        style.id = style_sheet_id;
        style.textContent = styles;
        append_stylesheet(append_styles_to, style);
    }
}
function get_root_for_style(node) {
    if (!node)
        return document;
    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
    if (root && root.host) {
        return root;
    }
    return node.ownerDocument;
}
function append_empty_stylesheet(node) {
    const style_element = element('style');
    append_stylesheet(get_root_for_style(node), style_element);
    return style_element.sheet;
}
function append_stylesheet(node, style) {
    append(node.head || node, style);
    return style.sheet;
}
function append_hydration(target, node) {
    if (is_hydrating) {
        init_hydrate(target);
        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentNode !== target))) {
            target.actual_end_child = target.firstChild;
        }
        // Skip nodes of undefined ordering
        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {
            target.actual_end_child = target.actual_end_child.nextSibling;
        }
        if (node !== target.actual_end_child) {
            // We only insert if the ordering of this node should be modified or the parent node is not target
            if (node.claim_order !== undefined || node.parentNode !== target) {
                target.insertBefore(node, target.actual_end_child);
            }
        }
        else {
            target.actual_end_child = node.nextSibling;
        }
    }
    else if (node.parentNode !== target || node.nextSibling !== null) {
        target.appendChild(node);
    }
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function insert_hydration(target, node, anchor) {
    if (is_hydrating && !anchor) {
        append_hydration(target, node);
    }
    else if (node.parentNode !== target || node.nextSibling != anchor) {
        target.insertBefore(node, anchor || null);
    }
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}
function element(name) {
    return document.createElement(name);
}
function element_is(name, is) {
    return document.createElement(name, { is });
}
function object_without_properties(obj, exclude) {
    const target = {};
    for (const k in obj) {
        if (has_prop(obj, k)
            // @ts-ignore
            && exclude.indexOf(k) === -1) {
            // @ts-ignore
            target[k] = obj[k];
        }
    }
    return target;
}
function svg_element(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
}
function text(data) {
    return document.createTextNode(data);
}
function space() {
    return text(' ');
}
function empty() {
    return text('');
}
function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
    return function (event) {
        event.preventDefault();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function stop_propagation(fn) {
    return function (event) {
        event.stopPropagation();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function self(fn) {
    return function (event) {
        // @ts-ignore
        if (event.target === this)
            fn.call(this, event);
    };
}
function trusted(fn) {
    return function (event) {
        // @ts-ignore
        if (event.isTrusted)
            fn.call(this, event);
    };
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function set_attributes(node, attributes) {
    // @ts-ignore
    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
    for (const key in attributes) {
        if (attributes[key] == null) {
            node.removeAttribute(key);
        }
        else if (key === 'style') {
            node.style.cssText = attributes[key];
        }
        else if (key === '__value') {
            node.value = node[key] = attributes[key];
        }
        else if (descriptors[key] && descriptors[key].set) {
            node[key] = attributes[key];
        }
        else {
            attr(node, key, attributes[key]);
        }
    }
}
function set_svg_attributes(node, attributes) {
    for (const key in attributes) {
        attr(node, key, attributes[key]);
    }
}
function set_custom_element_data(node, prop, value) {
    if (prop in node) {
        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
    }
    else {
        attr(node, prop, value);
    }
}
function xlink_attr(node, attribute, value) {
    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
}
function get_binding_group_value(group, __value, checked) {
    const value = new Set();
    for (let i = 0; i < group.length; i += 1) {
        if (group[i].checked)
            value.add(group[i].__value);
    }
    if (!checked) {
        value.delete(__value);
    }
    return Array.from(value);
}
function to_number(value) {
    return value === '' ? null : +value;
}
function time_ranges_to_array(ranges) {
    const array = [];
    for (let i = 0; i < ranges.length; i += 1) {
        array.push({ start: ranges.start(i), end: ranges.end(i) });
    }
    return array;
}
function children(element) {
    return Array.from(element.childNodes);
}
function init_claim_info(nodes) {
    if (nodes.claim_info === undefined) {
        nodes.claim_info = { last_index: 0, total_claimed: 0 };
    }
}
function claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {
    // Try to find nodes in an order such that we lengthen the longest increasing subsequence
    init_claim_info(nodes);
    const resultNode = (() => {
        // We first try to find an element after the previous one
        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {
            const node = nodes[i];
            if (predicate(node)) {
                const replacement = processNode(node);
                if (replacement === undefined) {
                    nodes.splice(i, 1);
                }
                else {
                    nodes[i] = replacement;
                }
                if (!dontUpdateLastIndex) {
                    nodes.claim_info.last_index = i;
                }
                return node;
            }
        }
        // Otherwise, we try to find one before
        // We iterate in reverse so that we don't go too far back
        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {
            const node = nodes[i];
            if (predicate(node)) {
                const replacement = processNode(node);
                if (replacement === undefined) {
                    nodes.splice(i, 1);
                }
                else {
                    nodes[i] = replacement;
                }
                if (!dontUpdateLastIndex) {
                    nodes.claim_info.last_index = i;
                }
                else if (replacement === undefined) {
                    // Since we spliced before the last_index, we decrease it
                    nodes.claim_info.last_index--;
                }
                return node;
            }
        }
        // If we can't find any matching node, we create a new one
        return createNode();
    })();
    resultNode.claim_order = nodes.claim_info.total_claimed;
    nodes.claim_info.total_claimed += 1;
    return resultNode;
}
function claim_element_base(nodes, name, attributes, create_element) {
    return claim_node(nodes, (node) => node.nodeName === name, (node) => {
        const remove = [];
        for (let j = 0; j < node.attributes.length; j++) {
            const attribute = node.attributes[j];
            if (!attributes[attribute.name]) {
                remove.push(attribute.name);
            }
        }
        remove.forEach(v => node.removeAttribute(v));
        return undefined;
    }, () => create_element(name));
}
function claim_element(nodes, name, attributes) {
    return claim_element_base(nodes, name, attributes, element);
}
function claim_svg_element(nodes, name, attributes) {
    return claim_element_base(nodes, name, attributes, svg_element);
}
function claim_text(nodes, data) {
    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {
        const dataStr = '' + data;
        if (node.data.startsWith(dataStr)) {
            if (node.data.length !== dataStr.length) {
                return node.splitText(dataStr.length);
            }
        }
        else {
            node.data = dataStr;
        }
    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements
    );
}
function claim_space(nodes) {
    return claim_text(nodes, ' ');
}
function find_comment(nodes, text, start) {
    for (let i = start; i < nodes.length; i += 1) {
        const node = nodes[i];
        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {
            return i;
        }
    }
    return nodes.length;
}
function claim_html_tag(nodes, is_svg) {
    // find html opening tag
    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);
    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);
    if (start_index === end_index) {
        return new HtmlTagHydration(undefined, is_svg);
    }
    init_claim_info(nodes);
    const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);
    detach(html_tag_nodes[0]);
    detach(html_tag_nodes[html_tag_nodes.length - 1]);
    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);
    for (const n of claimed_nodes) {
        n.claim_order = nodes.claim_info.total_claimed;
        nodes.claim_info.total_claimed += 1;
    }
    return new HtmlTagHydration(claimed_nodes, is_svg);
}
function set_data(text, data) {
    data = '' + data;
    if (text.wholeText !== data)
        text.data = data;
}
function set_input_value(input, value) {
    input.value = value == null ? '' : value;
}
function set_input_type(input, type) {
    try {
        input.type = type;
    }
    catch (e) {
        // do nothing
    }
}
function set_style(node, key, value, important) {
    if (value === null) {
        node.style.removeProperty(key);
    }
    else {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
}
function select_option(select, value) {
    for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        if (option.__value === value) {
            option.selected = true;
            return;
        }
    }
    select.selectedIndex = -1; // no option should be selected
}
function select_options(select, value) {
    for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        option.selected = ~value.indexOf(option.__value);
    }
}
function select_value(select) {
    const selected_option = select.querySelector(':checked') || select.options[0];
    return selected_option && selected_option.__value;
}
function select_multiple_value(select) {
    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);
}
// unfortunately this can't be a constant as that wouldn't be tree-shakeable
// so we cache the result instead
let crossorigin;
function is_crossorigin() {
    if (crossorigin === undefined) {
        crossorigin = false;
        try {
            if (typeof window !== 'undefined' && window.parent) {
                void window.parent.document;
            }
        }
        catch (error) {
            crossorigin = true;
        }
    }
    return crossorigin;
}
function add_resize_listener(node, fn) {
    const computed_style = getComputedStyle(node);
    if (computed_style.position === 'static') {
        node.style.position = 'relative';
    }
    const iframe = element('iframe');
    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
    iframe.setAttribute('aria-hidden', 'true');
    iframe.tabIndex = -1;
    const crossorigin = is_crossorigin();
    let unsubscribe;
    if (crossorigin) {
        iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
        unsubscribe = listen(window, 'message', (event) => {
            if (event.source === iframe.contentWindow)
                fn();
        });
    }
    else {
        iframe.src = 'about:blank';
        iframe.onload = () => {
            unsubscribe = listen(iframe.contentWindow, 'resize', fn);
        };
    }
    append(node, iframe);
    return () => {
        if (crossorigin) {
            unsubscribe();
        }
        else if (unsubscribe && iframe.contentWindow) {
            unsubscribe();
        }
        detach(iframe);
    };
}
function toggle_class(element, name, toggle) {
    element.classList[toggle ? 'add' : 'remove'](name);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, bubbles, cancelable, detail);
    return e;
}
function query_selector_all(selector, parent = document.body) {
    return Array.from(parent.querySelectorAll(selector));
}
class HtmlTag {
    constructor(is_svg = false) {
        this.is_svg = false;
        this.is_svg = is_svg;
        this.e = this.n = null;
    }
    c(html) {
        this.h(html);
    }
    m(html, target, anchor = null) {
        if (!this.e) {
            if (this.is_svg)
                this.e = svg_element(target.nodeName);
            else
                this.e = element(target.nodeName);
            this.t = target;
            this.c(html);
        }
        this.i(anchor);
    }
    h(html) {
        this.e.innerHTML = html;
        this.n = Array.from(this.e.childNodes);
    }
    i(anchor) {
        for (let i = 0; i < this.n.length; i += 1) {
            insert(this.t, this.n[i], anchor);
        }
    }
    p(html) {
        this.d();
        this.h(html);
        this.i(this.a);
    }
    d() {
        this.n.forEach(detach);
    }
}
class HtmlTagHydration extends HtmlTag {
    constructor(claimed_nodes, is_svg = false) {
        super(is_svg);
        this.e = this.n = null;
        this.l = claimed_nodes;
    }
    c(html) {
        if (this.l) {
            this.n = this.l;
        }
        else {
            super.c(html);
        }
    }
    i(anchor) {
        for (let i = 0; i < this.n.length; i += 1) {
            insert_hydration(this.t, this.n[i], anchor);
        }
    }
}
function attribute_to_object(attributes) {
    const result = {};
    for (const attribute of attributes) {
        result[attribute.name] = attribute.value;
    }
    return result;
}
function get_custom_elements_slots(element) {
    const result = {};
    element.childNodes.forEach((node) => {
        result[node.slot || 'default'] = true;
    });
    return result;
}

// we need to store the information for multiple documents because a Svelte application could also contain iframes
// https://github.com/sveltejs/svelte/issues/3624
const managed_styles = new Map();
let active = 0;
// https://github.com/darkskyapp/string-hash/blob/master/index.js
function hash(str) {
    let hash = 5381;
    let i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return hash >>> 0;
}
function create_style_information(doc, node) {
    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
    managed_styles.set(doc, info);
    return info;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
    const step = 16.666 / duration;
    let keyframes = '{\n';
    for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
    }
    const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
    const name = `__svelte_${hash(rule)}_${uid}`;
    const doc = get_root_for_style(node);
    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
    if (!rules[name]) {
        rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
    }
    const animation = node.style.animation || '';
    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
    active += 1;
    return name;
}
function delete_rule(node, name) {
    const previous = (node.style.animation || '').split(', ');
    const next = previous.filter(name
        ? anim => anim.indexOf(name) < 0 // remove specific animation
        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
    );
    const deleted = previous.length - next.length;
    if (deleted) {
        node.style.animation = next.join(', ');
        active -= deleted;
        if (!active)
            clear_rules();
    }
}
function clear_rules() {
    raf(() => {
        if (active)
            return;
        managed_styles.forEach(info => {
            const { ownerNode } = info.stylesheet;
            // there is no ownerNode if it runs on jsdom.
            if (ownerNode)
                detach(ownerNode);
        });
        managed_styles.clear();
    });
}

function create_animation(node, from, fn, params) {
    if (!from)
        return noop;
    const to = node.getBoundingClientRect();
    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
        return noop;
    const { delay = 0, duration = 300, easing = identity, 
    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
    start: start_time = now() + delay, 
    // @ts-ignore todo:
    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);
    let running = true;
    let started = false;
    let name;
    function start() {
        if (css) {
            name = create_rule(node, 0, 1, duration, delay, easing, css);
        }
        if (!delay) {
            started = true;
        }
    }
    function stop() {
        if (css)
            delete_rule(node, name);
        running = false;
    }
    loop(now => {
        if (!started && now >= start_time) {
            started = true;
        }
        if (started && now >= end) {
            tick(1, 0);
            stop();
        }
        if (!running) {
            return false;
        }
        if (started) {
            const p = now - start_time;
            const t = 0 + 1 * easing(p / duration);
            tick(t, 1 - t);
        }
        return true;
    });
    start();
    tick(0, 1);
    return stop;
}
function fix_position(node) {
    const style = getComputedStyle(node);
    if (style.position !== 'absolute' && style.position !== 'fixed') {
        const { width, height } = style;
        const a = node.getBoundingClientRect();
        node.style.position = 'absolute';
        node.style.width = width;
        node.style.height = height;
        add_transform(node, a);
    }
}
function add_transform(node, a) {
    const b = node.getBoundingClientRect();
    if (a.left !== b.left || a.top !== b.top) {
        const style = getComputedStyle(node);
        const transform = style.transform === 'none' ? '' : style.transform;
        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
    }
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error('Function called outside component initialization');
    return current_component;
}
function beforeUpdate(fn) {
    get_current_component().$$.before_update.push(fn);
}
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
    get_current_component().$$.after_update.push(fn);
}
function onDestroy(fn) {
    get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail, { cancelable = false } = {}) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
            // TODO are there situations where events could be dispatched
            // in a server (non-DOM) environment?
            const event = custom_event(type, detail, { cancelable });
            callbacks.slice().forEach(fn => {
                fn.call(component, event);
            });
            return !event.defaultPrevented;
        }
        return true;
    };
}
function setContext(key, context) {
    get_current_component().$$.context.set(key, context);
    return context;
}
function getContext(key) {
    return get_current_component().$$.context.get(key);
}
function getAllContexts() {
    return get_current_component().$$.context;
}
function hasContext(key) {
    return get_current_component().$$.context.has(key);
}
// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
function bubble(component, event) {
    const callbacks = component.$$.callbacks[event.type];
    if (callbacks) {
        // @ts-ignore
        callbacks.slice().forEach(fn => fn.call(this, event));
    }
}

const dirty_components = [];
const intros = { enabled: false };
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function tick() {
    schedule_update();
    return resolved_promise;
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
function add_flush_callback(fn) {
    flush_callbacks.push(fn);
}
// flush() calls callbacks in this order:
// 1. All beforeUpdate callbacks, in order: parents before children
// 2. All bind:this callbacks, in reverse order: children before parents.
// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
//    for afterUpdates called during the initial onMount, which are called in
//    reverse order: children before parents.
// Since callbacks might update component values, which could trigger another
// call to flush(), the following steps guard against this:
// 1. During beforeUpdate, any updated components will be added to the
//    dirty_components array and will cause a reentrant call to flush(). Because
//    the flush index is kept outside the function, the reentrant call will pick
//    up where the earlier call left off and go through all dirty components. The
//    current_component value is saved and restored so that the reentrant call will
//    not interfere with the "parent" flush() call.
// 2. bind:this callbacks cannot trigger new flush() calls.
// 3. During afterUpdate, any updated components will NOT have their afterUpdate
//    callback called a second time; the seen_callbacks set, outside the flush()
//    function, guarantees this behavior.
const seen_callbacks = new Set();
let flushidx = 0; // Do *not* move this inside the flush() function
function flush() {
    const saved_component = current_component;
    do {
        // first, call beforeUpdate functions
        // and update components
        while (flushidx < dirty_components.length) {
            const component = dirty_components[flushidx];
            flushidx++;
            set_current_component(component);
            update(component.$$);
        }
        set_current_component(null);
        dirty_components.length = 0;
        flushidx = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    seen_callbacks.clear();
    set_current_component(saved_component);
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}

let promise;
function wait() {
    if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
            promise = null;
        });
    }
    return promise;
}
function dispatch(node, direction, kind) {
    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
    else if (callback) {
        callback();
    }
}
const null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
    let config = fn(node, params);
    let running = false;
    let animation_name;
    let task;
    let uid = 0;
    function cleanup() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
        tick(0, 1);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        if (task)
            task.abort();
        running = true;
        add_render_callback(() => dispatch(node, true, 'start'));
        task = loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(1, 0);
                    dispatch(node, true, 'end');
                    cleanup();
                    return running = false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(t, 1 - t);
                }
            }
            return running;
        });
    }
    let started = false;
    return {
        start() {
            if (started)
                return;
            started = true;
            delete_rule(node);
            if (is_function(config)) {
                config = config();
                wait().then(go);
            }
            else {
                go();
            }
        },
        invalidate() {
            started = false;
        },
        end() {
            if (running) {
                cleanup();
                running = false;
            }
        }
    };
}
function create_out_transition(node, fn, params) {
    let config = fn(node, params);
    let running = true;
    let animation_name;
    const group = outros;
    group.r += 1;
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        add_render_callback(() => dispatch(node, false, 'start'));
        loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(0, 1);
                    dispatch(node, false, 'end');
                    if (!--group.r) {
                        // this will result in `end()` being called,
                        // so we don't need to clean up here
                        run_all(group.c);
                    }
                    return false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(1 - t, t);
                }
            }
            return running;
        });
    }
    if (is_function(config)) {
        wait().then(() => {
            // @ts-ignore
            config = config();
            go();
        });
    }
    else {
        go();
    }
    return {
        end(reset) {
            if (reset && config.tick) {
                config.tick(1, 0);
            }
            if (running) {
                if (animation_name)
                    delete_rule(node, animation_name);
                running = false;
            }
        }
    };
}
function create_bidirectional_transition(node, fn, params, intro) {
    let config = fn(node, params);
    let t = intro ? 0 : 1;
    let running_program = null;
    let pending_program = null;
    let animation_name = null;
    function clear_animation() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function init(program, duration) {
        const d = (program.b - t);
        duration *= Math.abs(d);
        return {
            a: t,
            b: program.b,
            d,
            duration,
            start: program.start,
            end: program.start + duration,
            group: program.group
        };
    }
    function go(b) {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        const program = {
            start: now() + delay,
            b
        };
        if (!b) {
            // @ts-ignore todo: improve typings
            program.group = outros;
            outros.r += 1;
        }
        if (running_program || pending_program) {
            pending_program = program;
        }
        else {
            // if this is an intro, and there's a delay, we need to do
            // an initial tick and/or apply CSS animation immediately
            if (css) {
                clear_animation();
                animation_name = create_rule(node, t, b, duration, delay, easing, css);
            }
            if (b)
                tick(0, 1);
            running_program = init(program, duration);
            add_render_callback(() => dispatch(node, b, 'start'));
            loop(now => {
                if (pending_program && now > pending_program.start) {
                    running_program = init(pending_program, duration);
                    pending_program = null;
                    dispatch(node, running_program.b, 'start');
                    if (css) {
                        clear_animation();
                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                    }
                }
                if (running_program) {
                    if (now >= running_program.end) {
                        tick(t = running_program.b, 1 - t);
                        dispatch(node, running_program.b, 'end');
                        if (!pending_program) {
                            // we're done
                            if (running_program.b) {
                                // intro  we can tidy up immediately
                                clear_animation();
                            }
                            else {
                                // outro  needs to be coordinated
                                if (!--running_program.group.r)
                                    run_all(running_program.group.c);
                            }
                        }
                        running_program = null;
                    }
                    else if (now >= running_program.start) {
                        const p = now - running_program.start;
                        t = running_program.a + running_program.d * easing(p / running_program.duration);
                        tick(t, 1 - t);
                    }
                }
                return !!(running_program || pending_program);
            });
        }
    }
    return {
        run(b) {
            if (is_function(config)) {
                wait().then(() => {
                    // @ts-ignore
                    config = config();
                    go(b);
                });
            }
            else {
                go(b);
            }
        },
        end() {
            clear_animation();
            running_program = pending_program = null;
        }
    };
}

function handle_promise(promise, info) {
    const token = info.token = {};
    function update(type, index, key, value) {
        if (info.token !== token)
            return;
        info.resolved = value;
        let child_ctx = info.ctx;
        if (key !== undefined) {
            child_ctx = child_ctx.slice();
            child_ctx[key] = value;
        }
        const block = type && (info.current = type)(child_ctx);
        let needs_flush = false;
        if (info.block) {
            if (info.blocks) {
                info.blocks.forEach((block, i) => {
                    if (i !== index && block) {
                        group_outros();
                        transition_out(block, 1, 1, () => {
                            if (info.blocks[i] === block) {
                                info.blocks[i] = null;
                            }
                        });
                        check_outros();
                    }
                });
            }
            else {
                info.block.d(1);
            }
            block.c();
            transition_in(block, 1);
            block.m(info.mount(), info.anchor);
            needs_flush = true;
        }
        info.block = block;
        if (info.blocks)
            info.blocks[index] = block;
        if (needs_flush) {
            flush();
        }
    }
    if (is_promise(promise)) {
        const current_component = get_current_component();
        promise.then(value => {
            set_current_component(current_component);
            update(info.then, 1, info.value, value);
            set_current_component(null);
        }, error => {
            set_current_component(current_component);
            update(info.catch, 2, info.error, error);
            set_current_component(null);
            if (!info.hasCatch) {
                throw error;
            }
        });
        // if we previously had a then/catch block, destroy it
        if (info.current !== info.pending) {
            update(info.pending, 0);
            return true;
        }
    }
    else {
        if (info.current !== info.then) {
            update(info.then, 1, info.value, promise);
            return true;
        }
        info.resolved = promise;
    }
}
function update_await_block_branch(info, ctx, dirty) {
    const child_ctx = ctx.slice();
    const { resolved } = info;
    if (info.current === info.then) {
        child_ctx[info.value] = resolved;
    }
    if (info.current === info.catch) {
        child_ctx[info.error] = resolved;
    }
    info.block.p(child_ctx, dirty);
}

const globals = (typeof window !== 'undefined'
    ? window
    : typeof globalThis !== 'undefined'
        ? globalThis
        : global);

function destroy_block(block, lookup) {
    block.d(1);
    lookup.delete(block.key);
}
function outro_and_destroy_block(block, lookup) {
    transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
    });
}
function fix_and_destroy_block(block, lookup) {
    block.f();
    destroy_block(block, lookup);
}
function fix_and_outro_and_destroy_block(block, lookup) {
    block.f();
    outro_and_destroy_block(block, lookup);
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
    let o = old_blocks.length;
    let n = list.length;
    let i = o;
    const old_indexes = {};
    while (i--)
        old_indexes[old_blocks[i].key] = i;
    const new_blocks = [];
    const new_lookup = new Map();
    const deltas = new Map();
    i = n;
    while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);
        if (!block) {
            block = create_each_block(key, child_ctx);
            block.c();
        }
        else if (dynamic) {
            block.p(child_ctx, dirty);
        }
        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes)
            deltas.set(key, Math.abs(i - old_indexes[key]));
    }
    const will_move = new Set();
    const did_move = new Set();
    function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
    }
    while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
            // do nothing
            next = new_block.first;
            o--;
            n--;
        }
        else if (!new_lookup.has(old_key)) {
            // remove old block
            destroy(old_block, lookup);
            o--;
        }
        else if (!lookup.has(new_key) || will_move.has(new_key)) {
            insert(new_block);
        }
        else if (did_move.has(old_key)) {
            o--;
        }
        else if (deltas.get(new_key) > deltas.get(old_key)) {
            did_move.add(new_key);
            insert(new_block);
        }
        else {
            will_move.add(old_key);
            o--;
        }
    }
    while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key))
            destroy(old_block, lookup);
    }
    while (n)
        insert(new_blocks[n - 1]);
    return new_blocks;
}
function validate_each_keys(ctx, list, get_context, get_key) {
    const keys = new Set();
    for (let i = 0; i < list.length; i++) {
        const key = get_key(get_context(ctx, list, i));
        if (keys.has(key)) {
            throw new Error('Cannot have duplicate keys in a keyed each');
        }
        keys.add(key);
    }
}

function get_spread_update(levels, updates) {
    const update = {};
    const to_null_out = {};
    const accounted_for = { $$scope: 1 };
    let i = levels.length;
    while (i--) {
        const o = levels[i];
        const n = updates[i];
        if (n) {
            for (const key in o) {
                if (!(key in n))
                    to_null_out[key] = 1;
            }
            for (const key in n) {
                if (!accounted_for[key]) {
                    update[key] = n[key];
                    accounted_for[key] = 1;
                }
            }
            levels[i] = n;
        }
        else {
            for (const key in o) {
                accounted_for[key] = 1;
            }
        }
    }
    for (const key in to_null_out) {
        if (!(key in update))
            update[key] = undefined;
    }
    return update;
}
function get_spread_object(spread_props) {
    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
}

// source: https://html.spec.whatwg.org/multipage/indices.html
const boolean_attributes = new Set([
    'allowfullscreen',
    'allowpaymentrequest',
    'async',
    'autofocus',
    'autoplay',
    'checked',
    'controls',
    'default',
    'defer',
    'disabled',
    'formnovalidate',
    'hidden',
    'ismap',
    'loop',
    'multiple',
    'muted',
    'nomodule',
    'novalidate',
    'open',
    'playsinline',
    'readonly',
    'required',
    'reversed',
    'selected'
]);

/** regex of all html void element names */
const void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;
function is_void(name) {
    return void_element_names.test(name) || name.toLowerCase() === '!doctype';
}

const invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
// https://infra.spec.whatwg.org/#noncharacter
function spread(args, attrs_to_add) {
    const attributes = Object.assign({}, ...args);
    if (attrs_to_add) {
        const classes_to_add = attrs_to_add.classes;
        const styles_to_add = attrs_to_add.styles;
        if (classes_to_add) {
            if (attributes.class == null) {
                attributes.class = classes_to_add;
            }
            else {
                attributes.class += ' ' + classes_to_add;
            }
        }
        if (styles_to_add) {
            if (attributes.style == null) {
                attributes.style = style_object_to_string(styles_to_add);
            }
            else {
                attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));
            }
        }
    }
    let str = '';
    Object.keys(attributes).forEach(name => {
        if (invalid_attribute_name_character.test(name))
            return;
        const value = attributes[name];
        if (value === true)
            str += ' ' + name;
        else if (boolean_attributes.has(name.toLowerCase())) {
            if (value)
                str += ' ' + name;
        }
        else if (value != null) {
            str += ` ${name}="${value}"`;
        }
    });
    return str;
}
function merge_ssr_styles(style_attribute, style_directive) {
    const style_object = {};
    for (const individual_style of style_attribute.split(';')) {
        const colon_index = individual_style.indexOf(':');
        const name = individual_style.slice(0, colon_index).trim();
        const value = individual_style.slice(colon_index + 1).trim();
        if (!name)
            continue;
        style_object[name] = value;
    }
    for (const name in style_directive) {
        const value = style_directive[name];
        if (value) {
            style_object[name] = value;
        }
        else {
            delete style_object[name];
        }
    }
    return style_object;
}
const ATTR_REGEX = /[&"]/g;
const CONTENT_REGEX = /[&<]/g;
/**
 * Note: this method is performance sensitive and has been optimized
 * https://github.com/sveltejs/svelte/pull/5701
 */
function escape(value, is_attr = false) {
    const str = String(value);
    const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;
    pattern.lastIndex = 0;
    let escaped = '';
    let last = 0;
    while (pattern.test(str)) {
        const i = pattern.lastIndex - 1;
        const ch = str[i];
        escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : (ch === '"' ? '&quot;' : '&lt;'));
        last = i + 1;
    }
    return escaped + str.substring(last);
}
function escape_attribute_value(value) {
    // keep booleans, null, and undefined for the sake of `spread`
    const should_escape = typeof value === 'string' || (value && typeof value === 'object');
    return should_escape ? escape(value, true) : value;
}
function escape_object(obj) {
    const result = {};
    for (const key in obj) {
        result[key] = escape_attribute_value(obj[key]);
    }
    return result;
}
function each(items, fn) {
    let str = '';
    for (let i = 0; i < items.length; i += 1) {
        str += fn(items[i], i);
    }
    return str;
}
const missing_component = {
    $$render: () => ''
};
function validate_component(component, name) {
    if (!component || !component.$$render) {
        if (name === 'svelte:component')
            name += ' this={...}';
        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
    }
    return component;
}
function debug(file, line, column, values) {
    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console
    console.log(values); // eslint-disable-line no-console
    return '';
}
let on_destroy;
function create_ssr_component(fn) {
    function $$render(result, props, bindings, slots, context) {
        const parent_component = current_component;
        const $$ = {
            on_destroy,
            context: new Map(context || (parent_component ? parent_component.$$.context : [])),
            // these will be immediately discarded
            on_mount: [],
            before_update: [],
            after_update: [],
            callbacks: blank_object()
        };
        set_current_component({ $$ });
        const html = fn(result, props, bindings, slots);
        set_current_component(parent_component);
        return html;
    }
    return {
        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
            on_destroy = [];
            const result = { title: '', head: '', css: new Set() };
            const html = $$render(result, props, {}, $$slots, context);
            run_all(on_destroy);
            return {
                html,
                css: {
                    code: Array.from(result.css).map(css => css.code).join('\n'),
                    map: null // TODO
                },
                head: result.title + result.head
            };
        },
        $$render
    };
}
function add_attribute(name, value, boolean) {
    if (value == null || (boolean && !value))
        return '';
    const assignment = (boolean && value === true) ? '' : `="${escape(value, true)}"`;
    return ` ${name}${assignment}`;
}
function add_classes(classes) {
    return classes ? ` class="${classes}"` : '';
}
function style_object_to_string(style_object) {
    return Object.keys(style_object)
        .filter(key => style_object[key])
        .map(key => `${key}: ${style_object[key]};`)
        .join(' ');
}
function add_styles(style_object) {
    const styles = style_object_to_string(style_object);
    return styles ? ` style="${styles}"` : '';
}

function bind(component, name, callback) {
    const index = component.$$.props[name];
    if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
    }
}
function create_component(block) {
    block && block.c();
}
function claim_component(block, parent_nodes) {
    block && block.l(parent_nodes);
}
function mount_component(component, target, anchor, customElement) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
    }
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false,
        root: options.target || parent_component.$$.root
    };
    append_styles && append_styles($$.root);
    let ready = false;
    $$.ctx = instance
        ? instance(component, options.props || {}, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            start_hydrating();
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor, options.customElement);
        end_hydrating();
        flush();
    }
    set_current_component(parent_component);
}
let SvelteElement;
if (typeof HTMLElement === 'function') {
    SvelteElement = class extends HTMLElement {
        constructor() {
            super();
            this.attachShadow({ mode: 'open' });
        }
        connectedCallback() {
            const { on_mount } = this.$$;
            this.$$.on_disconnect = on_mount.map(run).filter(is_function);
            // @ts-ignore todo: improve typings
            for (const key in this.$$.slotted) {
                // @ts-ignore todo: improve typings
                this.appendChild(this.$$.slotted[key]);
            }
        }
        attributeChangedCallback(attr, _oldValue, newValue) {
            this[attr] = newValue;
        }
        disconnectedCallback() {
            run_all(this.$$.on_disconnect);
        }
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            // TODO should this delegate to addEventListener?
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    };
}
/**
 * Base class for Svelte components. Used when dev=false.
 */
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

function dispatch_dev(type, detail) {
    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.50.1' }, detail), { bubbles: true }));
}
function append_dev(target, node) {
    dispatch_dev('SvelteDOMInsert', { target, node });
    append(target, node);
}
function append_hydration_dev(target, node) {
    dispatch_dev('SvelteDOMInsert', { target, node });
    append_hydration(target, node);
}
function insert_dev(target, node, anchor) {
    dispatch_dev('SvelteDOMInsert', { target, node, anchor });
    insert(target, node, anchor);
}
function insert_hydration_dev(target, node, anchor) {
    dispatch_dev('SvelteDOMInsert', { target, node, anchor });
    insert_hydration(target, node, anchor);
}
function detach_dev(node) {
    dispatch_dev('SvelteDOMRemove', { node });
    detach(node);
}
function detach_between_dev(before, after) {
    while (before.nextSibling && before.nextSibling !== after) {
        detach_dev(before.nextSibling);
    }
}
function detach_before_dev(after) {
    while (after.previousSibling) {
        detach_dev(after.previousSibling);
    }
}
function detach_after_dev(before) {
    while (before.nextSibling) {
        detach_dev(before.nextSibling);
    }
}
function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
    if (has_prevent_default)
        modifiers.push('preventDefault');
    if (has_stop_propagation)
        modifiers.push('stopPropagation');
    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
    const dispose = listen(node, event, handler, options);
    return () => {
        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
        dispose();
    };
}
function attr_dev(node, attribute, value) {
    attr(node, attribute, value);
    if (value == null)
        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
    else
        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
}
function prop_dev(node, property, value) {
    node[property] = value;
    dispatch_dev('SvelteDOMSetProperty', { node, property, value });
}
function dataset_dev(node, property, value) {
    node.dataset[property] = value;
    dispatch_dev('SvelteDOMSetDataset', { node, property, value });
}
function set_data_dev(text, data) {
    data = '' + data;
    if (text.wholeText === data)
        return;
    dispatch_dev('SvelteDOMSetData', { node: text, data });
    text.data = data;
}
function validate_each_argument(arg) {
    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
        let msg = '{#each} only iterates over array-like objects.';
        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
            msg += ' You can use a spread to convert this iterable into an array.';
        }
        throw new Error(msg);
    }
}
function validate_slots(name, slot, keys) {
    for (const slot_key of Object.keys(slot)) {
        if (!~keys.indexOf(slot_key)) {
            console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
        }
    }
}
function validate_dynamic_element(tag) {
    const is_string = typeof tag === 'string';
    if (tag && !is_string) {
        throw new Error('<svelte:element> expects "this" attribute to be a string.');
    }
}
function validate_void_dynamic_element(tag) {
    if (tag && is_void(tag)) {
        throw new Error(`<svelte:element this="${tag}"> is self-closing and cannot have content.`);
    }
}
/**
 * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
 */
class SvelteComponentDev extends SvelteComponent {
    constructor(options) {
        if (!options || (!options.target && !options.$$inline)) {
            throw new Error("'target' is a required option");
        }
        super();
    }
    $destroy() {
        super.$destroy();
        this.$destroy = () => {
            console.warn('Component was already destroyed'); // eslint-disable-line no-console
        };
    }
    $capture_state() { }
    $inject_state() { }
}
/**
 * Base class to create strongly typed Svelte components.
 * This only exists for typing purposes and should be used in `.d.ts` files.
 *
 * ### Example:
 *
 * You have component library on npm called `component-library`, from which
 * you export a component called `MyComponent`. For Svelte+TypeScript users,
 * you want to provide typings. Therefore you create a `index.d.ts`:
 * ```ts
 * import { SvelteComponentTyped } from "svelte";
 * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}
 * ```
 * Typing this makes it possible for IDEs like VS Code with the Svelte extension
 * to provide intellisense and to use the component like this in a Svelte file
 * with TypeScript:
 * ```svelte
 * <script lang="ts">
 * 	import { MyComponent } from "component-library";
 * </script>
 * <MyComponent foo={'bar'} />
 * ```
 *
 * #### Why not make this part of `SvelteComponent(Dev)`?
 * Because
 * ```ts
 * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}
 * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;
 * ```
 * will throw a type error, so we need to separate the more strictly typed class.
 */
class SvelteComponentTyped extends SvelteComponentDev {
    constructor(options) {
        super(options);
    }
}
function loop_guard(timeout) {
    const start = Date.now();
    return () => {
        if (Date.now() - start > timeout) {
            throw new Error('Infinite loop detected');
        }
    };
}




/***/ }),

/***/ "./node_modules/.pnpm/svelte@3.50.1/node_modules/svelte/store/index.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/svelte@3.50.1/node_modules/svelte/store/index.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "get": () => (/* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.get_store_value),
/* harmony export */   "writable": () => (/* binding */ writable)
/* harmony export */ });
/* unused harmony exports derived, readable */
/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/index.mjs */ "./node_modules/.pnpm/svelte@3.50.1/node_modules/svelte/internal/index.mjs");



const subscriber_queue = [];
/**
 * Creates a `Readable` store that allows reading by subscription.
 * @param value initial value
 * @param {StartStopNotifier}start start and stop notifications for subscriptions
 */
function readable(value, start) {
    return {
        subscribe: writable(value, start).subscribe
    };
}
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */
function writable(value, start = _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop) {
    let stop;
    const subscribers = new Set();
    function set(new_value) {
        if ((0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal)(value, new_value)) {
            value = new_value;
            if (stop) { // store is ready
                const run_queue = !subscriber_queue.length;
                for (const subscriber of subscribers) {
                    subscriber[1]();
                    subscriber_queue.push(subscriber, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop) {
        const subscriber = [run, invalidate];
        subscribers.add(subscriber);
        if (subscribers.size === 1) {
            stop = start(set) || _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop;
        }
        run(value);
        return () => {
            subscribers.delete(subscriber);
            if (subscribers.size === 0) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}
function derived(stores, fn, initial_value) {
    const single = !Array.isArray(stores);
    const stores_array = single
        ? [stores]
        : stores;
    const auto = fn.length < 2;
    return readable(initial_value, (set) => {
        let inited = false;
        const values = [];
        let pending = 0;
        let cleanup = _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop;
        const sync = () => {
            if (pending) {
                return;
            }
            cleanup();
            const result = fn(single ? values[0] : values, set);
            if (auto) {
                set(result);
            }
            else {
                cleanup = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.is_function)(result) ? result : _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop;
            }
        };
        const unsubscribers = stores_array.map((store, i) => (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.subscribe)(store, (value) => {
            values[i] = value;
            pending &= ~(1 << i);
            if (inited) {
                sync();
            }
        }, () => {
            pending |= (1 << i);
        }));
        inited = true;
        sync();
        return function stop() {
            (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.run_all)(unsubscribers);
            cleanup();
        };
    });
}




/***/ })

}]);
//# sourceMappingURL=vendors.js.map
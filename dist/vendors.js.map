{"version":3,"file":"vendors.js","mappings":";;;;;;;;;AAAA;AACA;AACA;AACA,kRAAkR,wIAAwI,wKAAwK,gLAAgL,kIAAkI,sOAAsO,uIAAuI,4EAA4E,2EAA2E,yHAAyH,4EAA4E,2EAA2E,gNAAgN;AACx1D;AACA,yBAAkB;AAClB,kBAAe;;;;;;;;;;;;ACNf;AACA;AACA;AACA,kTAAkT,4DAA4D,4GAA4G,4DAA4D,8GAA8G,oCAAoC,8DAA8D,+gBAA+gB,4DAA4D,4GAA4G,4DAA4D,8GAA8G,oCAAoC,8DAA8D,uhBAAuhB,4DAA4D,sIAAsI,8GAA8G,8DAA8D,8rBAA8rB,oGAAoG;AACh1G;AACA,yBAAkB;AAClB,kBAAe;;;;;;;;;;;;;;;;;;ACNf;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA,OAAO;AACP;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;;AAEA;AACA,sBAAsB,SAAS;AAC/B;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8CAAe,YAAY;;;ACpI3B;AACiD;AACjD;AACA;AACA,gCAAgC;AAChC;AACA,qBAAqB,yBAA+B,IAAI,eAAqB;AAC7E;AACA;AACA;AACA;AACA;;AAEuC;;AAEvC,MAAM,+BAAa;;AAEZ;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B,OAAY;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,+BAAa;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wDAAe,OAAO;;;;;;;;;;;;;;;;;;;;;;;ACxGtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sIAAsI;AACtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA,0CAA0C;AAC1C;AACA,sBAAsB;AACtB;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,iBAAiB,IAAI;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA,0EAA0E;AAC1E,gCAAgC;AAChC;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyN;;;;;;;;;;;;;AC51DpM;;AAqB+C;AACR;;;;;;;;eAmEtD,GAAI,IAAC,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6BAKF,GAAI,IAAC,UAAU;;;;;;;;;;;;;;GAAzB,uBAA4B;;;6HAAlB,GAAI,IAAC,UAAU;;;;;;;;;;;;;;;;;;;;;0BAHjB,GAAI,IAAC,IAAI;4BADR,GAAI,IAAC,UAAU;;;;;;;;;;;;;;GAAxB,uBAEK;;;;iEADG,GAAI,IAAC,IAAI;8HADR,GAAI,IAAC,UAAU;;;;;;;;;;;;;;;;;;;;yBAFrB,GAAI;;;;;;;;;;;;;;;gBAAJ,GAAI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OA/DF,KAAK;;EAEV,IAAI,EAAE,EAAE;;EAGR,OAAO,EAAE,IAAI;;EAGb,SAAS,EAAE,KAAK;;;;KAIb,OAAO,GAAG,KAAK;;;KAGf,OAAO,GAAG,CAAC;;;KAGX,IAAI;;OAEF,MAAM,GAAI,IAAI;;aAER,OAAO,CAAC,MAAM,KAAK,UAAU;GACvC,OAAO,CAAC,MAAM,CAAC,IAAI;;;;QAGd,QAAQ,GAAG,gCAAqB;;EACtC,QAAQ,CAAC,MAAM,IACd;;;;UAgBO,MAAM;kBACd,OAAO;;;;CAIR,kBAAO;kBACN,OAAO,GAAG,IAAI;;;;CAIf,oBAAS;kBACR,KAAK,CAAC,SAAS,GAAG,IAAI;;MAClB,KAAK,CAAC,OAAO;GAChB,KAAK,CAAC,OAAO,CAAC,KAAK;mBACnB,KAAK,CAAC,OAAO,GAAG,IAAI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAzBtB,CAAC;GACA,OAAO;SACD,QAAQ,GAAG,cAAc,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE,MAAM;mBAC5E,IAAI,GAAG,QAAQ,GAAG,YAAY,CAAC,QAAQ,CAAC,IAAI,EAAE,OAAO,IAAI,IAAI;;OACzD,IAAI,IAAI,QAAQ,CAAC,OAAO;;;;KAE3B,IAAI,CAAC,UAAU,CAAC,OAAO,YAAY,OAAO,CAAC,OAAO,MAAM,QAAQ;OAAG,OAAO,CAAC,OAAO,IAAI,GAAG;OAAG,EAAE,IAAI,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnF9H;AACA;AACA;AACA;AACA;AACA;AAKwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,8BAA8B;AACxC,IAAI;;AAEJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kCAAqB;AAChC,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0BAAiB;AAC9B,MAAM;AACN;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA,MAAM,mCAAqB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,0BAAiB;AACvB;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AC1VA;AACA;AACA;AACA;AACA;AACA;;AAE0D;;AAE1D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,+BAA+B,oBAAoB;;AAEnD,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA,KAAK;AACL,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,qDAAqD,UAAU;AAC/D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,YAAY,uBAAuB;;AAEnC;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAM,sBAAsB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,MAAM;AACN,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEO;;AAEP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,UAAU;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ;AACR,uCAAuC,UAAU;AACjD;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,WAAW;AACX;;;AC1aA;;AAEuD;;AAEvD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEO;AACP,kCAAkC,yBAAyB;AAC3D;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;;AAEA;;AAEA;AACA;AACA,IAAI,WAAW;AACf;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,cAAc,UAAU;;AAExB;AACA;AACA,cAAc,iCAAiC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,UAAU,aAAa;AACvB;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,GAAG;AAC1E;;AAEA;AACA;;;AC3K2C;;;ACAO;AAClD;AACA;AACA,mDAAmD,qBAAM;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,gBAAQ,GAAG,YAAY;AACpC,SAAS,sCAAsC;AAC/C,SAAS,YAAY;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,CAAC;;;;;;;;;;;ACtGD,uBAAuB,2DAA2D,+CAA+C,kCAAkC,0DAA0D,aAAa,mEAAmE,0DAA0D,IAAI,IAAI,aAAa,mEAAmE,uCAAuC,oDAAoD,eAAe,sCAAsC,wEAAwE,0BAA0B,uDAAuD,iCAAiC,KAAK,mEAAmE,8CAA8C,KAAK,mEAAmE,8CAA8C,mEAAmE,yDAAyD,EAAE,EAAE,GAAG,oBAAoB,+CAA+C,gCAAgC,qEAAqE,0DAA0D,4EAA4E,UAAU,gEAAgE,uDAAuD,EAAE,yCAAyC,4DAA4D,KAAK,wDAAwD,yCAAyC,6DAA6D,IAAI,gEAAgE,uCAAuC,wFAAwF,kFAAkF,gEAAgE,uDAAuD,EAAE,sCAAsC,qDAAqD,EAAE,EAAE,uBAAuB,+CAA+C,kCAAkC,0DAA0D,qGAAqG,kBAAkB,wGAAwG,iBAAiB,IAAI,IAAI,wDAAwD,yEAAyE,wCAAwC,+DAA+D,kFAAkF,qHAAqH,iBAAiB,EAAE,EAAE,GAAG,kCAAkC,kBAAkB,6DAA6D,cAAc,cAAc,WAAW,EAAE,KAAK,cAAc,cAAc,YAAY,GAAG,IAA2B,EAAE,gBAAgB,yBAAyB,IAAI;;;;;;;;;;ACAn5G;AACA,MAAM,IAA0C;AAChD,IAAI,iCAAgC,CAAC,MAAQ,CAAC,oCAAE,OAAO;AAAA;AAAA;AAAA,kGAAC;AACxD,IAAI,KAAK,YAQN;AACH,CAAC;AACD;;AAEA,sCAAsC;;AAEtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wHAAwH;AACxH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,GAAG;AACpB,mBAAmB,SAAS;AAC5B;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA,iBAAiB,UAAU;AAC3B;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;;;AAGA;AACA;AACA;AACA,iDAAiD,kBAAkB,EAAE,sCAAsC,MAAM,KAAK,UAAU,YAAY;AAC5I;;AAEA;AACA,gDAAgD,kBAAkB,EAAE,sCAAsC,MAAM,KAAK,UAAU,YAAY;AAC3I;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB,gCAAgC,MAAM;AACtC,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,eAAe;AACf;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA,iBAAiB,QAAQ,cAAc;AACvC;AACA;AACA;AACA,6DAA6D,gBAAgB;AAC7E;AACA,iBAAiB,QAAQ,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,mBAAmB;AACnB;;AAEA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA,eAAe;AACf;AACA;;AAEA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oCAAoC;AACrD;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;;AAGA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,GAAG;AACtB;AACA,mBAAmB,QAAQ;AAC3B;AACA,mBAAmB,aAAa;AAChC;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA,YAAY;AACZ;AACA;;AAEA,0EAA0E;AAC1E;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA,aAAa;AACb,aAAa;AACb;AACA;;;AAGA;AACA;AACA,YAAY;AACZ;AACA,YAAY;;;AAGZ;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,kBAAkB,EAAE,sCAAsC,MAAM,KAAK,UAAU,YAAY;AAC1I;;AAEA;AACA,8CAA8C,kBAAkB,EAAE,sCAAsC,MAAM,KAAK,UAAU,YAAY;AACzI;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;;AAGA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;ACpvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,gCAAgC;AAChC;AACA,eAAe;AACf,cAAc;AACd,cAAc;AACd,gBAAgB;AAChB,eAAe;AACf,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,KAAK;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,KAAK;AACnD;AACA;AACA,oCAAoC,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,iEAAiE,QAAQ;AACzE;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,KAAK,cAAc,SAAS,YAAY,SAAS;AAC5G;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,kEAAkE,QAAQ;AAC1E;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC,KAAK,+BAA+B;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC,yBAAyB,iCAAiC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAM;AAChC,IAAI,qBAAM;AACV,IAAI,qBAAM;AACV,IAAI,qBAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,yCAAyC;AACzC;AACA,WAAW,QAAQ,WAAW;AAC9B,WAAW,SAAS;AACpB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,SAAS;AACpB;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,+CAA+C,iBAAiB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG;AAClG;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gCAAgC,MAAM,UAAU,OAAO,WAAW,oBAAoB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,kDAAkD,sBAAsB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,kCAAkC,kCAAkC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA,sEAAsE,UAAU;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,kCAAkC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,6CAA6C,WAAW;AACxD;AACA;AACA;AACA;AACA;AACA,8CAA8C,WAAW,SAAS,cAAc;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,UAAU;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,gDAAgD;AAChD,yCAAyC;AACzC;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,kCAAkC;AACjF;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO,eAAe,KAAK,UAAU,oBAAoB;AAC1F;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0CAA0C;AACtD;AACA,oEAAoE,QAAQ;AAC5E;AACA;AACA,2EAA2E,YAAY;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,eAAe;AAC5D,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,SAAS;AAClG;AACA;AACA;AACA;AACA;AACA,uFAAuF,SAAS;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,KAAK,cAAc,UAAU;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,cAAc;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,UAAU;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,qEAAqE,UAAU;AAC/E;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,UAAU;AACpE;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,GAAG,KAAK;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yEAAyE;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB,GAAG,iBAAiB,GAAG,kBAAkB;AAC7E;AACA;AACA,iBAAiB,iBAAiB,GAAG,kBAAkB;AACvD;AACA;AACA,iBAAiB,eAAe,GAAG,eAAe;AAClD,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS,IAAI,WAAW;AACzD;AACA;AACA;AACA,+CAA+C,2BAA2B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE,SAAS;AACT;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA,cAAc,mDAAmD;AACjE,iBAAiB,gCAAgC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,oBAAoB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,KAAK;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,2DAA2D,cAAc;AACzE;AACA;AACA;AACA,oDAAoD,WAAW;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA;AACA,qCAAqC,KAAK;AAC1C;AACA;AACA;AACA,oCAAoC,MAAM;AAC1C;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,oCAAoC,KAAK,aAAa,KAAK;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8BAA8B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,kCAAkC;AAClC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,EAAE;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,kBAAkB;AACnE;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,KAAK,eAAe,IAAI;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sCAAsC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sGAAsG;AACtG;AACA;AACA;AACA,qGAAqG;AACrG;AACA;AACA;AACA,sBAAsB;AACtB,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA,yBAAyB,KAAK,WAAW,gBAAgB,IAAI,SAAS;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,WAAW,SAAS,iBAAiB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,WAAW,WAAW,iBAAiB;AAClG;AACA;AACA;AACA,yEAAyE,UAAU;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sBAAsB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD,mDAAmD,qBAAqB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,aAAa,qBAAqB,gBAAgB,iBAAiB,mBAAmB;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G,SAAS;AACtH,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,uCAAuC,UAAU;AACjD,mDAAmD,iBAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,KAAK;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,MAAM;AAC/D;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,sCAAsC,wEAAwE;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,KAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sBAAsB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,IAAI;AAC5C,yCAAyC,gBAAgB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,qCAAqC,yBAAyB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,YAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6BAA6B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,0DAA0D,OAAO;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,qCAAqC,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F;AAC/F,+FAA+F;AAC/F,2GAA2G;AAC3G,6FAA6F;AAC7F,0FAA0F;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,iCAAiC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iCAAiC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mCAAmC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,2CAA2C,eAAe;AAC1D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW,QAAQ,aAAa;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,+BAA+B;AACzE;AACA,QAAQ,gCAAgC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,YAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,qCAAqC,UAAU;AAC/C;AACA;AACA;AACA;AACA;AACA,gDAAgD,oCAAoC;AACpF;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA,aAAa,uCAAuC,GAAG,uBAAuB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,UAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,UAAU,YAAY,sBAAsB;AAC7F;AACA;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D;AACA;AACA,iDAAiD,cAAc;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,KAAK;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,MAAM;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,MAAM;AAC7C;AACA;AACA;AACA;AACA,gEAAgE,SAAS,KAAK,OAAO;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,yEAAyE,SAAS,KAAK,OAAO;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA;AACA,sCAAsC;AACtC,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,qBAAqB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mBAAmB;AACjD;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+BAA+B,SAAS,IAAI,aAAa;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,YAAY;AACtD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uGAAuG;AACvG;AACA;AACA;AACA;AACA;AACA,8BAA8B,mCAAmC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,aAAa;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,oBAAoB;AACxE;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mBAAmB;AAChE;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2CAA2C,kCAAkC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,+BAA+B;AAC1E;AACA;AACA,2CAA2C,UAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,8CAA8C,kCAAkC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,+CAA+C,uBAAuB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,IAAI;AACvF;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,yBAAyB,IAAI,sDAAsD;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,KAAK;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,0CAA0C;AACtF,iBAAiB;AACjB,8DAA8D,KAAK;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,kEAAkE;AAClE,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI,oDAAoD;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI,qDAAqD;AAClE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uCAAuC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,IAAI;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,KAAK,IAAI,MAAM;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,2CAA2C,kBAAkB,MAAM,EAAE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,MAAM,GAAG,KAAK,OAAO,WAAW;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,MAAM,GAAG,KAAK,OAAO,QAAQ;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8BAA8B,KAAK,4BAA4B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oCAAoC;AACtD;AACA,eAAe,OAAO;AACtB,iBAAiB,QAAQ,UAAU,oCAAoC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW,WAAW,MAAM,gBAAgB,UAAU,aAAa,SAAS,WAAW,OAAO,aAAa,SAAS;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA,iCAAiC,OAAO,KAAK,WAAW,KAAK,aAAa;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB,KAAK,QAAQ,IAAI,SAAS,aAAa,WAAW,YAAY,QAAQ,YAAY,YAAY,KAAK,QAAQ;AAC9J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO,SAAS,MAAM,iBAAiB,yBAAyB;AACxG;AACA;AACA;AACA;AACA,mCAAmC,OAAO,SAAS,KAAK;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,KAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4BAA4B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uCAAuC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,QAAQ;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,UAAU;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,IAAI;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,oBAAoB;AACzE,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA,6DAA6D,QAAQ,GAAG,MAAM,SAAS,QAAQ;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,kCAAkC;AAC3F;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iCAAiC,IAAI,6BAA6B;AAC1E,WAAW,4CAA4C;AACvD;AACA;AACA;AACA;AACA;AACA,6EAA6E,yBAAyB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,EAAE,WAAW,WAAW,QAAQ,IAAI,OAAO,QAAQ;AAC3E;AACA;AACA;AACA;AACA,6CAA6C,EAAE,QAAQ,IAAI;AAC3D;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qBAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2BAA2B;AACzD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,IAAI;AACnD;AACA,sCAAsC,IAAI,IAAI,SAAS,IAAI,OAAO;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uCAAuC,GAAG,2BAA2B;AAClF;AACA,eAAe,UAAU;AACzB;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,MAAM,wBAAwB,OAAO;AACxF,8BAA8B,qBAAqB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,KAAK,cAAc,yBAAyB;AAC7E;AACA;AACA,4FAA4F,gCAAgC;AAC5H;AACA,mDAAmD,iBAAiB;AACpE;AACA;AACA;AACA;AACA;AACA,iCAAiC,KAAK,cAAc,yBAAyB;AAC7E;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;;AAEsB;;;;;;;;;;;;;;;;AClzNtB;;AAEA;AACA;;AAEA;AACA,qBAAqB,yBAAyB;AAC9C;AACA;;AAEA;AACA;;AAEA,4CAA4C,sBAAsB,IAAI;AACtE;AACA;AACA;;AAEA;;AAEA;AACA;;AAEO;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1B4N;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAnO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,KAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yBAAyB;AACxD,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,IAAI;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC,qBAAqB,4CAA4C;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,kBAAkB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,oBAAoB,QAAQ,SAAS,aAAa,cAAc;AAClH,2BAA2B,WAAW,YAAY,sBAAsB,YAAY;AACpF;AACA;AACA;AACA;AACA;AACA,iEAAiE,0BAA0B;AAC3F;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sCAAsC,IAAI;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,oBAAoB,QAAQ;AAC5B;AACA,kCAAkC,EAAE,cAAc;AAClD;AACA,oCAAoC,EAAE,cAAc,GAAG;AACvD,6BAA6B,WAAW,GAAG,IAAI;AAC/C;AACA,YAAY,oBAAoB;AAChC;AACA;AACA,4CAA4C,MAAM,EAAE,KAAK;AACzD;AACA;AACA,8BAA8B,eAAe,UAAU,SAAS,EAAE,MAAM,EAAE,SAAS,YAAY,MAAM;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,oDAAoD,aAAa,UAAU;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,WAAW,YAAY,gBAAgB,MAAM,cAAc;AAC7F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB,IAAI;AACrD;AACA;AACA;AACA;AACA,uDAAuD,YAAY;AACnE;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,uCAAuC,8BAA8B,EAAE,KAAK;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAiE;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAiE;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAiE;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qDAAqD,KAAK,IAAI,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,MAAM,GAAG,OAAO,GAAG,OAAO;AACrX;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,KAAK,IAAI,MAAM;AACtC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,yBAAyB,SAAS;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,IAAI;AAChC,4BAA4B,KAAK;AACjC;AACA;AACA;AACA;AACA,kBAAkB,QAAQ,EAAE,uBAAuB,GAAG,KAAK,GAAG,OAAO,KAAK;AAC1E,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,IAAI;AACpC;AACA;AACA;AACA;AACA;AACA,2BAA2B,IAAI,YAAY,wBAAwB,IAAI;AACvE;AACA,6BAA6B;AAC7B,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,oBAAoB;AACnF,eAAe,KAAK,EAAE,WAAW;AACjC;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA,uBAAuB,IAAI,IAAI,mBAAmB;AAClD;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+CAA+C;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8DAA8D,mBAAmB,aAAa,eAAe;AAC7G;AACA;AACA,sCAAsC,cAAc;AACpD;AACA;AACA;AACA,sCAAsC,cAAc;AACpD;AACA;AACA;AACA,sCAAsC,sBAAsB;AAC5D;AACA;AACA;AACA,sCAAsC,sBAAsB;AAC5D;AACA;AACA;AACA,sCAAsC,MAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,iCAAiC;AACjF;AACA;AACA,uDAAuD,iCAAiC;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,iBAAiB;AACpE;AACA,gDAAgD,wBAAwB;AACxE;AACA;AACA;AACA,2CAA2C,uBAAuB;AAClE;AACA;AACA;AACA,0CAA0C,uBAAuB;AACjE;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,KAAK,iCAAiC,SAAS;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,IAAI;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uBAAuB;AACnC,0DAA0D,YAAY;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA,6DAA6D,YAAY;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoqF;;;;;;;;;;;;;;;;;;AClnEtkF;AAC/B;;AAE/D;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,mBAAmB;AAC9B;AACA,iCAAiC,qDAAI;AACrC;AACA;AACA;AACA,YAAY,mEAAc;AAC1B;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6BAA6B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qDAAI;AAC7C;AACA;AACA;AACA,iCAAiC,qDAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qDAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAW,oBAAoB,qDAAI;AAC7D;AACA;AACA,6DAA6D,8DAAS;AACtE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,YAAY,4DAAO;AACnB;AACA;AACA,KAAK;AACL;;AAEuC","sources":["file:///Users/miezan/Desktop/Dev/Bookmark2/node_modules/.pnpm/@iconify+icons-line-md@1.2.22/node_modules/@iconify/icons-line-md/moon-alt-to-sunny-outline-loop-transition.js","file:///Users/miezan/Desktop/Dev/Bookmark2/node_modules/.pnpm/@iconify+icons-line-md@1.2.22/node_modules/@iconify/icons-line-md/moon-filled-alt-loop.js","file:///Users/miezan/Desktop/Dev/Bookmark2/node_modules/.pnpm/svelte-hmr@0.14.12_svelte@3.50.1/node_modules/svelte-hmr/runtime/overlay.js","file:///Users/miezan/Desktop/Dev/Bookmark2/node_modules/.pnpm/svelte-hmr@0.14.12_svelte@3.50.1/node_modules/svelte-hmr/runtime/proxy-adapter-dom.js","file:///Users/miezan/Desktop/Dev/Bookmark2/node_modules/.pnpm/@iconify+svelte@3.1.3_svelte@3.50.1/node_modules/@iconify/svelte/dist/functions.mjs","file:///Users/miezan/Desktop/Dev/Bookmark2/node_modules/.pnpm/@iconify+svelte@3.1.3_svelte@3.50.1/node_modules/@iconify/svelte/dist/Icon.svelte","file:///Users/miezan/Desktop/Dev/Bookmark2/node_modules/.pnpm/svelte-hmr@0.14.12_svelte@3.50.1/node_modules/svelte-hmr/runtime/svelte-hooks.js","file:///Users/miezan/Desktop/Dev/Bookmark2/node_modules/.pnpm/svelte-hmr@0.14.12_svelte@3.50.1/node_modules/svelte-hmr/runtime/proxy.js","file:///Users/miezan/Desktop/Dev/Bookmark2/node_modules/.pnpm/svelte-hmr@0.14.12_svelte@3.50.1/node_modules/svelte-hmr/runtime/hot-api.js","file:///Users/miezan/Desktop/Dev/Bookmark2/node_modules/.pnpm/svelte-hmr@0.14.12_svelte@3.50.1/node_modules/svelte-hmr/runtime/index.js","file:///Users/miezan/Desktop/Dev/Bookmark2/node_modules/.pnpm/svelte-loader@3.1.3_svelte@3.50.1/node_modules/svelte-loader/lib/hot-api.js","file:///Users/miezan/Desktop/Dev/Bookmark2/node_modules/.pnpm/theme-change@2.2.0/node_modules/theme-change/index.js","file:///Users/miezan/Desktop/Dev/Bookmark2/node_modules/.pnpm/webextension-polyfill@0.10.0/node_modules/webextension-polyfill/dist/browser-polyfill.js","file:///Users/miezan/Desktop/Dev/Bookmark2/node_modules/.pnpm/wunderbaum@0.3.5/node_modules/wunderbaum/dist/wunderbaum.esm.js","file:///Users/miezan/Desktop/Dev/Bookmark2/node_modules/.pnpm/crypto-hash@2.0.1/node_modules/crypto-hash/browser.js","file:///Users/miezan/Desktop/Dev/Bookmark2/node_modules/.pnpm/svelte@3.50.1/node_modules/svelte/index.mjs","file:///Users/miezan/Desktop/Dev/Bookmark2/node_modules/.pnpm/svelte@3.50.1/node_modules/svelte/internal/index.mjs","file:///Users/miezan/Desktop/Dev/Bookmark2/node_modules/.pnpm/svelte@3.50.1/node_modules/svelte/store/index.mjs"],"sourcesContent":["const data = {\n\t\"width\": 24,\n\t\"height\": 24,\n\t\"body\": \"<g fill=\\\"none\\\" stroke=\\\"currentColor\\\" stroke-dasharray=\\\"2\\\" stroke-dashoffset=\\\"2\\\" stroke-linecap=\\\"round\\\" stroke-width=\\\"2\\\"><path d=\\\"M0 0\\\"><animate fill=\\\"freeze\\\" attributeName=\\\"d\\\" begin=\\\"0.6s\\\" dur=\\\"0.2s\\\" values=\\\"M12 19v1M19 12h1M12 5v-1M5 12h-1;M12 21v1M21 12h1M12 3v-1M3 12h-1\\\"/><animate fill=\\\"freeze\\\" attributeName=\\\"stroke-dashoffset\\\" begin=\\\"0.6s\\\" dur=\\\"0.2s\\\" values=\\\"2;0\\\"/></path><path d=\\\"M0 0\\\"><animate fill=\\\"freeze\\\" attributeName=\\\"d\\\" begin=\\\"0.9s\\\" dur=\\\"0.2s\\\" values=\\\"M17 17l0.5 0.5M17 7l0.5 -0.5M7 7l-0.5 -0.5M7 17l-0.5 0.5;M18.5 18.5l0.5 0.5M18.5 5.5l0.5 -0.5M5.5 5.5l-0.5 -0.5M5.5 18.5l-0.5 0.5\\\"/><animate fill=\\\"freeze\\\" attributeName=\\\"stroke-dashoffset\\\" begin=\\\"0.9s\\\" dur=\\\"1.2s\\\" values=\\\"2;0\\\"/></path><animateTransform attributeName=\\\"transform\\\" dur=\\\"30s\\\" repeatCount=\\\"indefinite\\\" type=\\\"rotate\\\" values=\\\"0 12 12;360 12 12\\\"/></g><mask id=\\\"lineMdMoonAltToSunnyOutlineLoopTransition0\\\"><circle cx=\\\"12\\\" cy=\\\"12\\\" r=\\\"12\\\" fill=\\\"#fff\\\"/><circle cx=\\\"12\\\" cy=\\\"12\\\" r=\\\"8\\\"><animate fill=\\\"freeze\\\" attributeName=\\\"r\\\" dur=\\\"0.4s\\\" values=\\\"8;4\\\"/></circle><circle cx=\\\"18\\\" cy=\\\"6\\\" r=\\\"12\\\" fill=\\\"#fff\\\"><animate fill=\\\"freeze\\\" attributeName=\\\"cx\\\" dur=\\\"0.4s\\\" values=\\\"18;22\\\"/><animate fill=\\\"freeze\\\" attributeName=\\\"cy\\\" dur=\\\"0.4s\\\" values=\\\"6;2\\\"/><animate fill=\\\"freeze\\\" attributeName=\\\"r\\\" dur=\\\"0.4s\\\" values=\\\"12;3\\\"/></circle><circle cx=\\\"18\\\" cy=\\\"6\\\" r=\\\"10\\\"><animate fill=\\\"freeze\\\" attributeName=\\\"cx\\\" dur=\\\"0.4s\\\" values=\\\"18;22\\\"/><animate fill=\\\"freeze\\\" attributeName=\\\"cy\\\" dur=\\\"0.4s\\\" values=\\\"6;2\\\"/><animate fill=\\\"freeze\\\" attributeName=\\\"r\\\" dur=\\\"0.4s\\\" values=\\\"10;1\\\"/></circle></mask><circle cx=\\\"12\\\" cy=\\\"12\\\" r=\\\"10\\\" fill=\\\"currentColor\\\" mask=\\\"url(#lineMdMoonAltToSunnyOutlineLoopTransition0)\\\"><animate fill=\\\"freeze\\\" attributeName=\\\"r\\\" dur=\\\"0.4s\\\" values=\\\"10;6\\\"/></circle>\"\n};\nexports.__esModule = true;\nexports.default = data;\n","const data = {\n\t\"width\": 24,\n\t\"height\": 24,\n\t\"body\": \"<g fill=\\\"none\\\" stroke=\\\"currentColor\\\" stroke-dasharray=\\\"4\\\" stroke-dashoffset=\\\"4\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\"><path d=\\\"M13 4h1.5M13 4h-1.5M13 4v1.5M13 4v-1.5\\\"><animate id=\\\"lineMdMoonFilledAltLoop0\\\" fill=\\\"freeze\\\" attributeName=\\\"stroke-dashoffset\\\" begin=\\\"0.7s;lineMdMoonFilledAltLoop0.begin+6s\\\" dur=\\\"0.4s\\\" values=\\\"4;0\\\"/><animate fill=\\\"freeze\\\" attributeName=\\\"stroke-dashoffset\\\" begin=\\\"lineMdMoonFilledAltLoop0.begin+2s;lineMdMoonFilledAltLoop0.begin+4s\\\" dur=\\\"0.4s\\\" values=\\\"4;0\\\"/><animate fill=\\\"freeze\\\" attributeName=\\\"stroke-dashoffset\\\" begin=\\\"lineMdMoonFilledAltLoop0.begin+1.2s;lineMdMoonFilledAltLoop0.begin+3.2s;lineMdMoonFilledAltLoop0.begin+5.2s\\\" dur=\\\"0.4s\\\" values=\\\"0;4\\\"/><set attributeName=\\\"d\\\" begin=\\\"lineMdMoonFilledAltLoop0.begin+1.8s\\\" to=\\\"M12 5h1.5M12 5h-1.5M12 5v1.5M12 5v-1.5\\\"/><set attributeName=\\\"d\\\" begin=\\\"lineMdMoonFilledAltLoop0.begin+3.8s\\\" to=\\\"M12 4h1.5M12 4h-1.5M12 4v1.5M12 4v-1.5\\\"/><set attributeName=\\\"d\\\" begin=\\\"lineMdMoonFilledAltLoop0.begin+5.8s\\\" to=\\\"M13 4h1.5M13 4h-1.5M13 4v1.5M13 4v-1.5\\\"/></path><path d=\\\"M19 11h1.5M19 11h-1.5M19 11v1.5M19 11v-1.5\\\"><animate id=\\\"lineMdMoonFilledAltLoop1\\\" fill=\\\"freeze\\\" attributeName=\\\"stroke-dashoffset\\\" begin=\\\"1.1s;lineMdMoonFilledAltLoop1.begin+6s\\\" dur=\\\"0.4s\\\" values=\\\"4;0\\\"/><animate fill=\\\"freeze\\\" attributeName=\\\"stroke-dashoffset\\\" begin=\\\"lineMdMoonFilledAltLoop1.begin+2s;lineMdMoonFilledAltLoop1.begin+4s\\\" dur=\\\"0.4s\\\" values=\\\"4;0\\\"/><animate fill=\\\"freeze\\\" attributeName=\\\"stroke-dashoffset\\\" begin=\\\"lineMdMoonFilledAltLoop1.begin+1.2s;lineMdMoonFilledAltLoop1.begin+3.2s;lineMdMoonFilledAltLoop1.begin+5.2s\\\" dur=\\\"0.4s\\\" values=\\\"0;4\\\"/><set attributeName=\\\"d\\\" begin=\\\"lineMdMoonFilledAltLoop1.begin+1.8s\\\" to=\\\"M17 11h1.5M17 11h-1.5M17 11v1.5M17 11v-1.5\\\"/><set attributeName=\\\"d\\\" begin=\\\"lineMdMoonFilledAltLoop1.begin+3.8s\\\" to=\\\"M18 12h1.5M18 12h-1.5M18 12v1.5M18 12v-1.5\\\"/><set attributeName=\\\"d\\\" begin=\\\"lineMdMoonFilledAltLoop1.begin+5.8s\\\" to=\\\"M19 11h1.5M19 11h-1.5M19 11v1.5M19 11v-1.5\\\"/></path><path d=\\\"M19 4h1.5M19 4h-1.5M19 4v1.5M19 4v-1.5\\\"><animate id=\\\"lineMdMoonFilledAltLoop2\\\" fill=\\\"freeze\\\" attributeName=\\\"stroke-dashoffset\\\" begin=\\\"2.9s;lineMdMoonFilledAltLoop2.begin+6s\\\" dur=\\\"0.4s\\\" values=\\\"4;0\\\"/><animate fill=\\\"freeze\\\" attributeName=\\\"stroke-dashoffset\\\" begin=\\\"lineMdMoonFilledAltLoop2.begin+2s\\\" dur=\\\"0.4s\\\" values=\\\"4;0\\\"/><animate fill=\\\"freeze\\\" attributeName=\\\"stroke-dashoffset\\\" begin=\\\"lineMdMoonFilledAltLoop2.begin+1.2s;lineMdMoonFilledAltLoop2.begin+3.2s\\\" dur=\\\"0.4s\\\" values=\\\"0;4\\\"/><set attributeName=\\\"d\\\" begin=\\\"lineMdMoonFilledAltLoop2.begin+1.8s\\\" to=\\\"M20 5h1.5M20 5h-1.5M20 5v1.5M20 5v-1.5\\\"/><set attributeName=\\\"d\\\" begin=\\\"lineMdMoonFilledAltLoop2.begin+5.8s\\\" to=\\\"M19 4h1.5M19 4h-1.5M19 4v1.5M19 4v-1.5\\\"/></path></g><g fill-opacity=\\\"0\\\" stroke=\\\"currentColor\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" stroke-width=\\\"2\\\"><path fill=\\\"currentColor\\\" stroke-dasharray=\\\"56\\\" stroke-dashoffset=\\\"56\\\" d=\\\"M7 6 C7 12.08 11.92 17 18 17 C18.53 17 19.05 16.96 19.56 16.89 C17.95 19.36 15.17 21 12 21 C7.03 21 3 16.97 3 12 C3 8.83 4.64 6.05 7.11 4.44 C7.04 4.95 7 5.47 7 6 Z\\\"><animate fill=\\\"freeze\\\" attributeName=\\\"stroke-dashoffset\\\" dur=\\\"0.6s\\\" values=\\\"56;0\\\"/><animate fill=\\\"freeze\\\" attributeName=\\\"fill-opacity\\\" begin=\\\"1.5s\\\" dur=\\\"0.5s\\\" values=\\\"0;1\\\"/></path></g>\"\n};\nexports.__esModule = true;\nexports.default = data;\n","/* eslint-env browser */\n\nconst removeElement = el => el && el.parentNode && el.parentNode.removeChild(el)\n\nconst ErrorOverlay = () => {\n  let errors = []\n  let compileError = null\n\n  const errorsTitle = 'Failed to init component'\n  const compileErrorTitle = 'Failed to compile'\n\n  const style = {\n    section: `\n      position: fixed;\n      top: 0;\n      bottom: 0;\n      left: 0;\n      right: 0;\n      padding: 32px;\n      background: rgba(0, 0, 0, .85);\n      font-family: Menlo, Consolas, monospace;\n      font-size: large;\n      color: rgb(232, 232, 232);\n      overflow: auto;\n      z-index: 2147483647;\n    `,\n    h1: `\n      margin-top: 0;\n      color: #E36049;\n      font-size: large;\n      font-weight: normal;\n    `,\n    h2: `\n      margin: 32px 0 0;\n      font-size: large;\n      font-weight: normal;\n    `,\n    pre: ``,\n  }\n\n  const createOverlay = () => {\n    const h1 = document.createElement('h1')\n    h1.style = style.h1\n    const section = document.createElement('section')\n    section.appendChild(h1)\n    section.style = style.section\n    const body = document.createElement('div')\n    section.appendChild(body)\n    return { h1, el: section, body }\n  }\n\n  const setTitle = title => {\n    overlay.h1.textContent = title\n  }\n\n  const show = () => {\n    const { el } = overlay\n    if (!el.parentNode) {\n      const target = document.body\n      target.appendChild(overlay.el)\n    }\n  }\n\n  const hide = () => {\n    const { el } = overlay\n    if (el.parentNode) {\n      overlay.el.remove()\n    }\n  }\n\n  const update = () => {\n    if (compileError) {\n      overlay.body.innerHTML = ''\n      setTitle(compileErrorTitle)\n      const errorEl = renderError(compileError)\n      overlay.body.appendChild(errorEl)\n      show()\n    } else if (errors.length > 0) {\n      overlay.body.innerHTML = ''\n      setTitle(errorsTitle)\n      errors.forEach(({ title, message }) => {\n        const errorEl = renderError(message, title)\n        overlay.body.appendChild(errorEl)\n      })\n      show()\n    } else {\n      hide()\n    }\n  }\n\n  const renderError = (message, title) => {\n    const div = document.createElement('div')\n    if (title) {\n      const h2 = document.createElement('h2')\n      h2.textContent = title\n      h2.style = style.h2\n      div.appendChild(h2)\n    }\n    const pre = document.createElement('pre')\n    pre.textContent = message\n    div.appendChild(pre)\n    return div\n  }\n\n  const addError = (error, title) => {\n    const message = (error && error.stack) || error\n    errors.push({ title, message })\n    update()\n  }\n\n  const clearErrors = () => {\n    errors.forEach(({ element }) => {\n      removeElement(element)\n    })\n    errors = []\n    update()\n  }\n\n  const setCompileError = message => {\n    compileError = message\n    update()\n  }\n\n  const overlay = createOverlay()\n\n  return {\n    addError,\n    clearErrors,\n    setCompileError,\n  }\n}\n\nexport default ErrorOverlay\n","/* global window, document */\nimport * as svelteInternal from 'svelte/internal'\n// NOTE from 3.38.3 (or so), insert was carrying the hydration logic, that must\n// be used because DOM elements are reused more (and so insertion points are not\n// necessarily added in order); then in 3.40 the logic was moved to\n// insert_hydration, which is the one we must use for HMR\nconst svelteInsert = svelteInternal.insert_hydration || svelteInternal.insert\nif (!svelteInsert) {\n  throw new Error(\n    'failed to find insert_hydration and insert in svelte/internal'\n  )\n}\n\nimport ErrorOverlay from './overlay.js'\n\nconst removeElement = el => el && el.parentNode && el.parentNode.removeChild(el)\n\nexport const adapter = class ProxyAdapterDom {\n  constructor(instance) {\n    this.instance = instance\n    this.insertionPoint = null\n\n    this.afterMount = this.afterMount.bind(this)\n    this.rerender = this.rerender.bind(this)\n\n    this._noOverlay = !!instance.hotOptions.noOverlay\n  }\n\n  // NOTE overlay is only created before being actually shown to help test\n  // runner (it won't have to account for error overlay when running assertions\n  // about the contents of the rendered page)\n  static getErrorOverlay(noCreate = false) {\n    if (!noCreate && !this.errorOverlay) {\n      this.errorOverlay = ErrorOverlay()\n    }\n    return this.errorOverlay\n  }\n\n  // TODO this is probably unused now: remove in next breaking release\n  static renderCompileError(message) {\n    const noCreate = !message\n    const overlay = this.getErrorOverlay(noCreate)\n    if (!overlay) return\n    overlay.setCompileError(message)\n  }\n\n  dispose() {\n    // Component is being destroyed, detaching is not optional in Svelte3's\n    // component API, so we can dispose of the insertion point in every case.\n    if (this.insertionPoint) {\n      removeElement(this.insertionPoint)\n      this.insertionPoint = null\n    }\n    this.clearError()\n  }\n\n  // NOTE afterMount CAN be called multiple times (e.g. keyed list)\n  afterMount(target, anchor) {\n    const {\n      instance: { debugName },\n    } = this\n    if (!this.insertionPoint) {\n      this.insertionPoint = document.createComment(debugName)\n    }\n    svelteInsert(target, this.insertionPoint, anchor)\n  }\n\n  rerender() {\n    this.clearError()\n    const {\n      instance: { refreshComponent },\n      insertionPoint,\n    } = this\n    if (!insertionPoint) {\n      throw new Error('Cannot rerender: missing insertion point')\n    }\n    refreshComponent(insertionPoint.parentNode, insertionPoint)\n  }\n\n  renderError(err) {\n    if (this._noOverlay) return\n    const {\n      instance: { debugName },\n    } = this\n    const title = debugName || err.moduleName || 'Error'\n    this.constructor.getErrorOverlay().addError(err, title)\n  }\n\n  clearError() {\n    if (this._noOverlay) return\n    const overlay = this.constructor.getErrorOverlay(true)\n    if (!overlay) return\n    overlay.clearErrors()\n  }\n}\n\n// TODO this is probably unused now: remove in next breaking release\nif (typeof window !== 'undefined') {\n  window.__SVELTE_HMR_ADAPTER = adapter\n}\n\n// mitigate situation with Snowpack remote source pulling latest of runtime,\n// but using previous version of the Node code transform in the plugin\n// see: https://github.com/rixo/svelte-hmr/issues/27\nexport default adapter\n","const matchIconName = /^[a-z0-9]+(-[a-z0-9]+)*$/;\nconst stringToIcon = (value, validate, allowSimpleName, provider = \"\") => {\n  const colonSeparated = value.split(\":\");\n  if (value.slice(0, 1) === \"@\") {\n    if (colonSeparated.length < 2 || colonSeparated.length > 3) {\n      return null;\n    }\n    provider = colonSeparated.shift().slice(1);\n  }\n  if (colonSeparated.length > 3 || !colonSeparated.length) {\n    return null;\n  }\n  if (colonSeparated.length > 1) {\n    const name2 = colonSeparated.pop();\n    const prefix = colonSeparated.pop();\n    const result = {\n      // Allow provider without '@': \"provider:prefix:name\"\n      provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,\n      prefix,\n      name: name2\n    };\n    return validate && !validateIconName(result) ? null : result;\n  }\n  const name = colonSeparated[0];\n  const dashSeparated = name.split(\"-\");\n  if (dashSeparated.length > 1) {\n    const result = {\n      provider,\n      prefix: dashSeparated.shift(),\n      name: dashSeparated.join(\"-\")\n    };\n    return validate && !validateIconName(result) ? null : result;\n  }\n  if (allowSimpleName && provider === \"\") {\n    const result = {\n      provider,\n      prefix: \"\",\n      name\n    };\n    return validate && !validateIconName(result, allowSimpleName) ? null : result;\n  }\n  return null;\n};\nconst validateIconName = (icon, allowSimpleName) => {\n  if (!icon) {\n    return false;\n  }\n  return !!((icon.provider === \"\" || icon.provider.match(matchIconName)) && (allowSimpleName && icon.prefix === \"\" || icon.prefix.match(matchIconName)) && icon.name.match(matchIconName));\n};\n\nconst defaultIconDimensions = Object.freeze(\n  {\n    left: 0,\n    top: 0,\n    width: 16,\n    height: 16\n  }\n);\nconst defaultIconTransformations = Object.freeze({\n  rotate: 0,\n  vFlip: false,\n  hFlip: false\n});\nconst defaultIconProps = Object.freeze({\n  ...defaultIconDimensions,\n  ...defaultIconTransformations\n});\nconst defaultExtendedIconProps = Object.freeze({\n  ...defaultIconProps,\n  body: \"\",\n  hidden: false\n});\n\nfunction mergeIconTransformations(obj1, obj2) {\n  const result = {};\n  if (!obj1.hFlip !== !obj2.hFlip) {\n    result.hFlip = true;\n  }\n  if (!obj1.vFlip !== !obj2.vFlip) {\n    result.vFlip = true;\n  }\n  const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;\n  if (rotate) {\n    result.rotate = rotate;\n  }\n  return result;\n}\n\nfunction mergeIconData(parent, child) {\n  const result = mergeIconTransformations(parent, child);\n  for (const key in defaultExtendedIconProps) {\n    if (key in defaultIconTransformations) {\n      if (key in parent && !(key in result)) {\n        result[key] = defaultIconTransformations[key];\n      }\n    } else if (key in child) {\n      result[key] = child[key];\n    } else if (key in parent) {\n      result[key] = parent[key];\n    }\n  }\n  return result;\n}\n\nfunction getIconsTree(data, names) {\n  const icons = data.icons;\n  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n  const resolved = /* @__PURE__ */ Object.create(null);\n  function resolve(name) {\n    if (icons[name]) {\n      return resolved[name] = [];\n    }\n    if (!(name in resolved)) {\n      resolved[name] = null;\n      const parent = aliases[name] && aliases[name].parent;\n      const value = parent && resolve(parent);\n      if (value) {\n        resolved[name] = [parent].concat(value);\n      }\n    }\n    return resolved[name];\n  }\n  (names || Object.keys(icons).concat(Object.keys(aliases))).forEach(resolve);\n  return resolved;\n}\n\nfunction internalGetIconData(data, name, tree) {\n  const icons = data.icons;\n  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n  let currentProps = {};\n  function parse(name2) {\n    currentProps = mergeIconData(\n      icons[name2] || aliases[name2],\n      currentProps\n    );\n  }\n  parse(name);\n  tree.forEach(parse);\n  return mergeIconData(data, currentProps);\n}\n\nfunction parseIconSet(data, callback) {\n  const names = [];\n  if (typeof data !== \"object\" || typeof data.icons !== \"object\") {\n    return names;\n  }\n  if (data.not_found instanceof Array) {\n    data.not_found.forEach((name) => {\n      callback(name, null);\n      names.push(name);\n    });\n  }\n  const tree = getIconsTree(data);\n  for (const name in tree) {\n    const item = tree[name];\n    if (item) {\n      callback(name, internalGetIconData(data, name, item));\n      names.push(name);\n    }\n  }\n  return names;\n}\n\nconst optionalPropertyDefaults = {\n  provider: \"\",\n  aliases: {},\n  not_found: {},\n  ...defaultIconDimensions\n};\nfunction checkOptionalProps(item, defaults) {\n  for (const prop in defaults) {\n    if (prop in item && typeof item[prop] !== typeof defaults[prop]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction quicklyValidateIconSet(obj) {\n  if (typeof obj !== \"object\" || obj === null) {\n    return null;\n  }\n  const data = obj;\n  if (typeof data.prefix !== \"string\" || !obj.icons || typeof obj.icons !== \"object\") {\n    return null;\n  }\n  if (!checkOptionalProps(obj, optionalPropertyDefaults)) {\n    return null;\n  }\n  const icons = data.icons;\n  for (const name in icons) {\n    const icon = icons[name];\n    if (!name.match(matchIconName) || typeof icon.body !== \"string\" || !checkOptionalProps(\n      icon,\n      defaultExtendedIconProps\n    )) {\n      return null;\n    }\n  }\n  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n  for (const name in aliases) {\n    const icon = aliases[name];\n    const parent = icon.parent;\n    if (!name.match(matchIconName) || typeof parent !== \"string\" || !icons[parent] && !aliases[parent] || !checkOptionalProps(\n      icon,\n      defaultExtendedIconProps\n    )) {\n      return null;\n    }\n  }\n  return data;\n}\n\nconst dataStorage = /* @__PURE__ */ Object.create(null);\nfunction newStorage(provider, prefix) {\n  return {\n    provider,\n    prefix,\n    icons: /* @__PURE__ */ Object.create(null),\n    missing: /* @__PURE__ */ new Set()\n  };\n}\nfunction getStorage(provider, prefix) {\n  const providerStorage = dataStorage[provider] || (dataStorage[provider] = /* @__PURE__ */ Object.create(null));\n  return providerStorage[prefix] || (providerStorage[prefix] = newStorage(provider, prefix));\n}\nfunction addIconSet(storage, data) {\n  if (!quicklyValidateIconSet(data)) {\n    return [];\n  }\n  return parseIconSet(data, (name, icon) => {\n    if (icon) {\n      storage.icons[name] = icon;\n    } else {\n      storage.missing.add(name);\n    }\n  });\n}\nfunction addIconToStorage(storage, name, icon) {\n  try {\n    if (typeof icon.body === \"string\") {\n      storage.icons[name] = { ...icon };\n      return true;\n    }\n  } catch (err) {\n  }\n  return false;\n}\nfunction listIcons(provider, prefix) {\n  let allIcons = [];\n  const providers = typeof provider === \"string\" ? [provider] : Object.keys(dataStorage);\n  providers.forEach((provider2) => {\n    const prefixes = typeof provider2 === \"string\" && typeof prefix === \"string\" ? [prefix] : Object.keys(dataStorage[provider2] || {});\n    prefixes.forEach((prefix2) => {\n      const storage = getStorage(provider2, prefix2);\n      allIcons = allIcons.concat(\n        Object.keys(storage.icons).map(\n          (name) => (provider2 !== \"\" ? \"@\" + provider2 + \":\" : \"\") + prefix2 + \":\" + name\n        )\n      );\n    });\n  });\n  return allIcons;\n}\n\nlet simpleNames = false;\nfunction allowSimpleNames(allow) {\n  if (typeof allow === \"boolean\") {\n    simpleNames = allow;\n  }\n  return simpleNames;\n}\nfunction getIconData(name) {\n  const icon = typeof name === \"string\" ? stringToIcon(name, true, simpleNames) : name;\n  if (icon) {\n    const storage = getStorage(icon.provider, icon.prefix);\n    const iconName = icon.name;\n    return storage.icons[iconName] || (storage.missing.has(iconName) ? null : void 0);\n  }\n}\nfunction addIcon(name, data) {\n  const icon = stringToIcon(name, true, simpleNames);\n  if (!icon) {\n    return false;\n  }\n  const storage = getStorage(icon.provider, icon.prefix);\n  return addIconToStorage(storage, icon.name, data);\n}\nfunction addCollection(data, provider) {\n  if (typeof data !== \"object\") {\n    return false;\n  }\n  if (typeof provider !== \"string\") {\n    provider = data.provider || \"\";\n  }\n  if (simpleNames && !provider && !data.prefix) {\n    let added = false;\n    if (quicklyValidateIconSet(data)) {\n      data.prefix = \"\";\n      parseIconSet(data, (name, icon) => {\n        if (icon && addIcon(name, icon)) {\n          added = true;\n        }\n      });\n    }\n    return added;\n  }\n  const prefix = data.prefix;\n  if (!validateIconName({\n    provider,\n    prefix,\n    name: \"a\"\n  })) {\n    return false;\n  }\n  const storage = getStorage(provider, prefix);\n  return !!addIconSet(storage, data);\n}\nfunction iconExists(name) {\n  return !!getIconData(name);\n}\nfunction getIcon(name) {\n  const result = getIconData(name);\n  return result ? {\n    ...defaultIconProps,\n    ...result\n  } : null;\n}\n\nconst defaultIconSizeCustomisations = Object.freeze({\n  width: null,\n  height: null\n});\nconst defaultIconCustomisations = Object.freeze({\n  // Dimensions\n  ...defaultIconSizeCustomisations,\n  // Transformations\n  ...defaultIconTransformations\n});\n\nconst unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;\nconst unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;\nfunction calculateSize(size, ratio, precision) {\n  if (ratio === 1) {\n    return size;\n  }\n  precision = precision || 100;\n  if (typeof size === \"number\") {\n    return Math.ceil(size * ratio * precision) / precision;\n  }\n  if (typeof size !== \"string\") {\n    return size;\n  }\n  const oldParts = size.split(unitsSplit);\n  if (oldParts === null || !oldParts.length) {\n    return size;\n  }\n  const newParts = [];\n  let code = oldParts.shift();\n  let isNumber = unitsTest.test(code);\n  while (true) {\n    if (isNumber) {\n      const num = parseFloat(code);\n      if (isNaN(num)) {\n        newParts.push(code);\n      } else {\n        newParts.push(Math.ceil(num * ratio * precision) / precision);\n      }\n    } else {\n      newParts.push(code);\n    }\n    code = oldParts.shift();\n    if (code === void 0) {\n      return newParts.join(\"\");\n    }\n    isNumber = !isNumber;\n  }\n}\n\nconst isUnsetKeyword = (value) => value === \"unset\" || value === \"undefined\" || value === \"none\";\nfunction iconToSVG(icon, customisations) {\n  const fullIcon = {\n    ...defaultIconProps,\n    ...icon\n  };\n  const fullCustomisations = {\n    ...defaultIconCustomisations,\n    ...customisations\n  };\n  const box = {\n    left: fullIcon.left,\n    top: fullIcon.top,\n    width: fullIcon.width,\n    height: fullIcon.height\n  };\n  let body = fullIcon.body;\n  [fullIcon, fullCustomisations].forEach((props) => {\n    const transformations = [];\n    const hFlip = props.hFlip;\n    const vFlip = props.vFlip;\n    let rotation = props.rotate;\n    if (hFlip) {\n      if (vFlip) {\n        rotation += 2;\n      } else {\n        transformations.push(\n          \"translate(\" + (box.width + box.left).toString() + \" \" + (0 - box.top).toString() + \")\"\n        );\n        transformations.push(\"scale(-1 1)\");\n        box.top = box.left = 0;\n      }\n    } else if (vFlip) {\n      transformations.push(\n        \"translate(\" + (0 - box.left).toString() + \" \" + (box.height + box.top).toString() + \")\"\n      );\n      transformations.push(\"scale(1 -1)\");\n      box.top = box.left = 0;\n    }\n    let tempValue;\n    if (rotation < 0) {\n      rotation -= Math.floor(rotation / 4) * 4;\n    }\n    rotation = rotation % 4;\n    switch (rotation) {\n      case 1:\n        tempValue = box.height / 2 + box.top;\n        transformations.unshift(\n          \"rotate(90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\"\n        );\n        break;\n      case 2:\n        transformations.unshift(\n          \"rotate(180 \" + (box.width / 2 + box.left).toString() + \" \" + (box.height / 2 + box.top).toString() + \")\"\n        );\n        break;\n      case 3:\n        tempValue = box.width / 2 + box.left;\n        transformations.unshift(\n          \"rotate(-90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\"\n        );\n        break;\n    }\n    if (rotation % 2 === 1) {\n      if (box.left !== box.top) {\n        tempValue = box.left;\n        box.left = box.top;\n        box.top = tempValue;\n      }\n      if (box.width !== box.height) {\n        tempValue = box.width;\n        box.width = box.height;\n        box.height = tempValue;\n      }\n    }\n    if (transformations.length) {\n      body = '<g transform=\"' + transformations.join(\" \") + '\">' + body + \"</g>\";\n    }\n  });\n  const customisationsWidth = fullCustomisations.width;\n  const customisationsHeight = fullCustomisations.height;\n  const boxWidth = box.width;\n  const boxHeight = box.height;\n  let width;\n  let height;\n  if (customisationsWidth === null) {\n    height = customisationsHeight === null ? \"1em\" : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n    width = calculateSize(height, boxWidth / boxHeight);\n  } else {\n    width = customisationsWidth === \"auto\" ? boxWidth : customisationsWidth;\n    height = customisationsHeight === null ? calculateSize(width, boxHeight / boxWidth) : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n  }\n  const attributes = {};\n  const setAttr = (prop, value) => {\n    if (!isUnsetKeyword(value)) {\n      attributes[prop] = value.toString();\n    }\n  };\n  setAttr(\"width\", width);\n  setAttr(\"height\", height);\n  attributes.viewBox = box.left.toString() + \" \" + box.top.toString() + \" \" + boxWidth.toString() + \" \" + boxHeight.toString();\n  return {\n    attributes,\n    body\n  };\n}\n\nconst regex = /\\sid=\"(\\S+)\"/g;\nconst randomPrefix = \"IconifyId\" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);\nlet counter = 0;\nfunction replaceIDs(body, prefix = randomPrefix) {\n  const ids = [];\n  let match;\n  while (match = regex.exec(body)) {\n    ids.push(match[1]);\n  }\n  if (!ids.length) {\n    return body;\n  }\n  const suffix = \"suffix\" + (Math.random() * 16777216 | Date.now()).toString(16);\n  ids.forEach((id) => {\n    const newID = typeof prefix === \"function\" ? prefix(id) : prefix + (counter++).toString();\n    const escapedID = id.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n    body = body.replace(\n      // Allowed characters before id: [#;\"]\n      // Allowed characters after id: [)\"], .[a-z]\n      new RegExp('([#;\"])(' + escapedID + ')([\")]|\\\\.[a-z])', \"g\"),\n      \"$1\" + newID + suffix + \"$3\"\n    );\n  });\n  body = body.replace(new RegExp(suffix, \"g\"), \"\");\n  return body;\n}\n\nconst storage = /* @__PURE__ */ Object.create(null);\nfunction setAPIModule(provider, item) {\n  storage[provider] = item;\n}\nfunction getAPIModule(provider) {\n  return storage[provider] || storage[\"\"];\n}\n\nfunction createAPIConfig(source) {\n  let resources;\n  if (typeof source.resources === \"string\") {\n    resources = [source.resources];\n  } else {\n    resources = source.resources;\n    if (!(resources instanceof Array) || !resources.length) {\n      return null;\n    }\n  }\n  const result = {\n    // API hosts\n    resources,\n    // Root path\n    path: source.path || \"/\",\n    // URL length limit\n    maxURL: source.maxURL || 500,\n    // Timeout before next host is used.\n    rotate: source.rotate || 750,\n    // Timeout before failing query.\n    timeout: source.timeout || 5e3,\n    // Randomise default API end point.\n    random: source.random === true,\n    // Start index\n    index: source.index || 0,\n    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).\n    dataAfterTimeout: source.dataAfterTimeout !== false\n  };\n  return result;\n}\nconst configStorage = /* @__PURE__ */ Object.create(null);\nconst fallBackAPISources = [\n  \"https://api.simplesvg.com\",\n  \"https://api.unisvg.com\"\n];\nconst fallBackAPI = [];\nwhile (fallBackAPISources.length > 0) {\n  if (fallBackAPISources.length === 1) {\n    fallBackAPI.push(fallBackAPISources.shift());\n  } else {\n    if (Math.random() > 0.5) {\n      fallBackAPI.push(fallBackAPISources.shift());\n    } else {\n      fallBackAPI.push(fallBackAPISources.pop());\n    }\n  }\n}\nconfigStorage[\"\"] = createAPIConfig({\n  resources: [\"https://api.iconify.design\"].concat(fallBackAPI)\n});\nfunction addAPIProvider(provider, customConfig) {\n  const config = createAPIConfig(customConfig);\n  if (config === null) {\n    return false;\n  }\n  configStorage[provider] = config;\n  return true;\n}\nfunction getAPIConfig(provider) {\n  return configStorage[provider];\n}\nfunction listAPIProviders() {\n  return Object.keys(configStorage);\n}\n\nconst detectFetch = () => {\n  let callback;\n  try {\n    callback = fetch;\n    if (typeof callback === \"function\") {\n      return callback;\n    }\n  } catch (err) {\n  }\n};\nlet fetchModule = detectFetch();\nfunction setFetch(fetch2) {\n  fetchModule = fetch2;\n}\nfunction getFetch() {\n  return fetchModule;\n}\nfunction calculateMaxLength(provider, prefix) {\n  const config = getAPIConfig(provider);\n  if (!config) {\n    return 0;\n  }\n  let result;\n  if (!config.maxURL) {\n    result = 0;\n  } else {\n    let maxHostLength = 0;\n    config.resources.forEach((item) => {\n      const host = item;\n      maxHostLength = Math.max(maxHostLength, host.length);\n    });\n    const url = prefix + \".json?icons=\";\n    result = config.maxURL - maxHostLength - config.path.length - url.length;\n  }\n  return result;\n}\nfunction shouldAbort(status) {\n  return status === 404;\n}\nconst prepare = (provider, prefix, icons) => {\n  const results = [];\n  const maxLength = calculateMaxLength(provider, prefix);\n  const type = \"icons\";\n  let item = {\n    type,\n    provider,\n    prefix,\n    icons: []\n  };\n  let length = 0;\n  icons.forEach((name, index) => {\n    length += name.length + 1;\n    if (length >= maxLength && index > 0) {\n      results.push(item);\n      item = {\n        type,\n        provider,\n        prefix,\n        icons: []\n      };\n      length = name.length;\n    }\n    item.icons.push(name);\n  });\n  results.push(item);\n  return results;\n};\nfunction getPath(provider) {\n  if (typeof provider === \"string\") {\n    const config = getAPIConfig(provider);\n    if (config) {\n      return config.path;\n    }\n  }\n  return \"/\";\n}\nconst send = (host, params, callback) => {\n  if (!fetchModule) {\n    callback(\"abort\", 424);\n    return;\n  }\n  let path = getPath(params.provider);\n  switch (params.type) {\n    case \"icons\": {\n      const prefix = params.prefix;\n      const icons = params.icons;\n      const iconsList = icons.join(\",\");\n      const urlParams = new URLSearchParams({\n        icons: iconsList\n      });\n      path += prefix + \".json?\" + urlParams.toString();\n      break;\n    }\n    case \"custom\": {\n      const uri = params.uri;\n      path += uri.slice(0, 1) === \"/\" ? uri.slice(1) : uri;\n      break;\n    }\n    default:\n      callback(\"abort\", 400);\n      return;\n  }\n  let defaultError = 503;\n  fetchModule(host + path).then((response) => {\n    const status = response.status;\n    if (status !== 200) {\n      setTimeout(() => {\n        callback(shouldAbort(status) ? \"abort\" : \"next\", status);\n      });\n      return;\n    }\n    defaultError = 501;\n    return response.json();\n  }).then((data) => {\n    if (typeof data !== \"object\" || data === null) {\n      setTimeout(() => {\n        if (data === 404) {\n          callback(\"abort\", data);\n        } else {\n          callback(\"next\", defaultError);\n        }\n      });\n      return;\n    }\n    setTimeout(() => {\n      callback(\"success\", data);\n    });\n  }).catch(() => {\n    callback(\"next\", defaultError);\n  });\n};\nconst fetchAPIModule = {\n  prepare,\n  send\n};\n\nfunction sortIcons(icons) {\n  const result = {\n    loaded: [],\n    missing: [],\n    pending: []\n  };\n  const storage = /* @__PURE__ */ Object.create(null);\n  icons.sort((a, b) => {\n    if (a.provider !== b.provider) {\n      return a.provider.localeCompare(b.provider);\n    }\n    if (a.prefix !== b.prefix) {\n      return a.prefix.localeCompare(b.prefix);\n    }\n    return a.name.localeCompare(b.name);\n  });\n  let lastIcon = {\n    provider: \"\",\n    prefix: \"\",\n    name: \"\"\n  };\n  icons.forEach((icon) => {\n    if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) {\n      return;\n    }\n    lastIcon = icon;\n    const provider = icon.provider;\n    const prefix = icon.prefix;\n    const name = icon.name;\n    const providerStorage = storage[provider] || (storage[provider] = /* @__PURE__ */ Object.create(null));\n    const localStorage = providerStorage[prefix] || (providerStorage[prefix] = getStorage(provider, prefix));\n    let list;\n    if (name in localStorage.icons) {\n      list = result.loaded;\n    } else if (prefix === \"\" || localStorage.missing.has(name)) {\n      list = result.missing;\n    } else {\n      list = result.pending;\n    }\n    const item = {\n      provider,\n      prefix,\n      name\n    };\n    list.push(item);\n  });\n  return result;\n}\n\nfunction removeCallback(storages, id) {\n  storages.forEach((storage) => {\n    const items = storage.loaderCallbacks;\n    if (items) {\n      storage.loaderCallbacks = items.filter((row) => row.id !== id);\n    }\n  });\n}\nfunction updateCallbacks(storage) {\n  if (!storage.pendingCallbacksFlag) {\n    storage.pendingCallbacksFlag = true;\n    setTimeout(() => {\n      storage.pendingCallbacksFlag = false;\n      const items = storage.loaderCallbacks ? storage.loaderCallbacks.slice(0) : [];\n      if (!items.length) {\n        return;\n      }\n      let hasPending = false;\n      const provider = storage.provider;\n      const prefix = storage.prefix;\n      items.forEach((item) => {\n        const icons = item.icons;\n        const oldLength = icons.pending.length;\n        icons.pending = icons.pending.filter((icon) => {\n          if (icon.prefix !== prefix) {\n            return true;\n          }\n          const name = icon.name;\n          if (storage.icons[name]) {\n            icons.loaded.push({\n              provider,\n              prefix,\n              name\n            });\n          } else if (storage.missing.has(name)) {\n            icons.missing.push({\n              provider,\n              prefix,\n              name\n            });\n          } else {\n            hasPending = true;\n            return true;\n          }\n          return false;\n        });\n        if (icons.pending.length !== oldLength) {\n          if (!hasPending) {\n            removeCallback([storage], item.id);\n          }\n          item.callback(\n            icons.loaded.slice(0),\n            icons.missing.slice(0),\n            icons.pending.slice(0),\n            item.abort\n          );\n        }\n      });\n    });\n  }\n}\nlet idCounter = 0;\nfunction storeCallback(callback, icons, pendingSources) {\n  const id = idCounter++;\n  const abort = removeCallback.bind(null, pendingSources, id);\n  if (!icons.pending.length) {\n    return abort;\n  }\n  const item = {\n    id,\n    icons,\n    callback,\n    abort\n  };\n  pendingSources.forEach((storage) => {\n    (storage.loaderCallbacks || (storage.loaderCallbacks = [])).push(item);\n  });\n  return abort;\n}\n\nfunction listToIcons(list, validate = true, simpleNames = false) {\n  const result = [];\n  list.forEach((item) => {\n    const icon = typeof item === \"string\" ? stringToIcon(item, validate, simpleNames) : item;\n    if (icon) {\n      result.push(icon);\n    }\n  });\n  return result;\n}\n\n// src/config.ts\nvar defaultConfig = {\n  resources: [],\n  index: 0,\n  timeout: 2e3,\n  rotate: 750,\n  random: false,\n  dataAfterTimeout: false\n};\n\n// src/query.ts\nfunction sendQuery(config, payload, query, done) {\n  const resourcesCount = config.resources.length;\n  const startIndex = config.random ? Math.floor(Math.random() * resourcesCount) : config.index;\n  let resources;\n  if (config.random) {\n    let list = config.resources.slice(0);\n    resources = [];\n    while (list.length > 1) {\n      const nextIndex = Math.floor(Math.random() * list.length);\n      resources.push(list[nextIndex]);\n      list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));\n    }\n    resources = resources.concat(list);\n  } else {\n    resources = config.resources.slice(startIndex).concat(config.resources.slice(0, startIndex));\n  }\n  const startTime = Date.now();\n  let status = \"pending\";\n  let queriesSent = 0;\n  let lastError;\n  let timer = null;\n  let queue = [];\n  let doneCallbacks = [];\n  if (typeof done === \"function\") {\n    doneCallbacks.push(done);\n  }\n  function resetTimer() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  }\n  function abort() {\n    if (status === \"pending\") {\n      status = \"aborted\";\n    }\n    resetTimer();\n    queue.forEach((item) => {\n      if (item.status === \"pending\") {\n        item.status = \"aborted\";\n      }\n    });\n    queue = [];\n  }\n  function subscribe(callback, overwrite) {\n    if (overwrite) {\n      doneCallbacks = [];\n    }\n    if (typeof callback === \"function\") {\n      doneCallbacks.push(callback);\n    }\n  }\n  function getQueryStatus() {\n    return {\n      startTime,\n      payload,\n      status,\n      queriesSent,\n      queriesPending: queue.length,\n      subscribe,\n      abort\n    };\n  }\n  function failQuery() {\n    status = \"failed\";\n    doneCallbacks.forEach((callback) => {\n      callback(void 0, lastError);\n    });\n  }\n  function clearQueue() {\n    queue.forEach((item) => {\n      if (item.status === \"pending\") {\n        item.status = \"aborted\";\n      }\n    });\n    queue = [];\n  }\n  function moduleResponse(item, response, data) {\n    const isError = response !== \"success\";\n    queue = queue.filter((queued) => queued !== item);\n    switch (status) {\n      case \"pending\":\n        break;\n      case \"failed\":\n        if (isError || !config.dataAfterTimeout) {\n          return;\n        }\n        break;\n      default:\n        return;\n    }\n    if (response === \"abort\") {\n      lastError = data;\n      failQuery();\n      return;\n    }\n    if (isError) {\n      lastError = data;\n      if (!queue.length) {\n        if (!resources.length) {\n          failQuery();\n        } else {\n          execNext();\n        }\n      }\n      return;\n    }\n    resetTimer();\n    clearQueue();\n    if (!config.random) {\n      const index = config.resources.indexOf(item.resource);\n      if (index !== -1 && index !== config.index) {\n        config.index = index;\n      }\n    }\n    status = \"completed\";\n    doneCallbacks.forEach((callback) => {\n      callback(data);\n    });\n  }\n  function execNext() {\n    if (status !== \"pending\") {\n      return;\n    }\n    resetTimer();\n    const resource = resources.shift();\n    if (resource === void 0) {\n      if (queue.length) {\n        timer = setTimeout(() => {\n          resetTimer();\n          if (status === \"pending\") {\n            clearQueue();\n            failQuery();\n          }\n        }, config.timeout);\n        return;\n      }\n      failQuery();\n      return;\n    }\n    const item = {\n      status: \"pending\",\n      resource,\n      callback: (status2, data) => {\n        moduleResponse(item, status2, data);\n      }\n    };\n    queue.push(item);\n    queriesSent++;\n    timer = setTimeout(execNext, config.rotate);\n    query(resource, payload, item.callback);\n  }\n  setTimeout(execNext);\n  return getQueryStatus;\n}\n\n// src/index.ts\nfunction initRedundancy(cfg) {\n  const config = {\n    ...defaultConfig,\n    ...cfg\n  };\n  let queries = [];\n  function cleanup() {\n    queries = queries.filter((item) => item().status === \"pending\");\n  }\n  function query(payload, queryCallback, doneCallback) {\n    const query2 = sendQuery(\n      config,\n      payload,\n      queryCallback,\n      (data, error) => {\n        cleanup();\n        if (doneCallback) {\n          doneCallback(data, error);\n        }\n      }\n    );\n    queries.push(query2);\n    return query2;\n  }\n  function find(callback) {\n    return queries.find((value) => {\n      return callback(value);\n    }) || null;\n  }\n  const instance = {\n    query,\n    find,\n    setIndex: (index) => {\n      config.index = index;\n    },\n    getIndex: () => config.index,\n    cleanup\n  };\n  return instance;\n}\n\nfunction emptyCallback$1() {\n}\nconst redundancyCache = /* @__PURE__ */ Object.create(null);\nfunction getRedundancyCache(provider) {\n  if (!redundancyCache[provider]) {\n    const config = getAPIConfig(provider);\n    if (!config) {\n      return;\n    }\n    const redundancy = initRedundancy(config);\n    const cachedReundancy = {\n      config,\n      redundancy\n    };\n    redundancyCache[provider] = cachedReundancy;\n  }\n  return redundancyCache[provider];\n}\nfunction sendAPIQuery(target, query, callback) {\n  let redundancy;\n  let send;\n  if (typeof target === \"string\") {\n    const api = getAPIModule(target);\n    if (!api) {\n      callback(void 0, 424);\n      return emptyCallback$1;\n    }\n    send = api.send;\n    const cached = getRedundancyCache(target);\n    if (cached) {\n      redundancy = cached.redundancy;\n    }\n  } else {\n    const config = createAPIConfig(target);\n    if (config) {\n      redundancy = initRedundancy(config);\n      const moduleKey = target.resources ? target.resources[0] : \"\";\n      const api = getAPIModule(moduleKey);\n      if (api) {\n        send = api.send;\n      }\n    }\n  }\n  if (!redundancy || !send) {\n    callback(void 0, 424);\n    return emptyCallback$1;\n  }\n  return redundancy.query(query, send, callback)().abort;\n}\n\nconst browserCacheVersion = \"iconify2\";\nconst browserCachePrefix = \"iconify\";\nconst browserCacheCountKey = browserCachePrefix + \"-count\";\nconst browserCacheVersionKey = browserCachePrefix + \"-version\";\nconst browserStorageHour = 36e5;\nconst browserStorageCacheExpiration = 168;\n\nfunction getStoredItem(func, key) {\n  try {\n    return func.getItem(key);\n  } catch (err) {\n  }\n}\nfunction setStoredItem(func, key, value) {\n  try {\n    func.setItem(key, value);\n    return true;\n  } catch (err) {\n  }\n}\nfunction removeStoredItem(func, key) {\n  try {\n    func.removeItem(key);\n  } catch (err) {\n  }\n}\n\nfunction setBrowserStorageItemsCount(storage, value) {\n  return setStoredItem(storage, browserCacheCountKey, value.toString());\n}\nfunction getBrowserStorageItemsCount(storage) {\n  return parseInt(getStoredItem(storage, browserCacheCountKey)) || 0;\n}\n\nconst browserStorageConfig = {\n  local: true,\n  session: true\n};\nconst browserStorageEmptyItems = {\n  local: /* @__PURE__ */ new Set(),\n  session: /* @__PURE__ */ new Set()\n};\nlet browserStorageStatus = false;\nfunction setBrowserStorageStatus(status) {\n  browserStorageStatus = status;\n}\n\nlet _window = typeof window === \"undefined\" ? {} : window;\nfunction getBrowserStorage(key) {\n  const attr = key + \"Storage\";\n  try {\n    if (_window && _window[attr] && typeof _window[attr].length === \"number\") {\n      return _window[attr];\n    }\n  } catch (err) {\n  }\n  browserStorageConfig[key] = false;\n}\n\nfunction iterateBrowserStorage(key, callback) {\n  const func = getBrowserStorage(key);\n  if (!func) {\n    return;\n  }\n  const version = getStoredItem(func, browserCacheVersionKey);\n  if (version !== browserCacheVersion) {\n    if (version) {\n      const total2 = getBrowserStorageItemsCount(func);\n      for (let i = 0; i < total2; i++) {\n        removeStoredItem(func, browserCachePrefix + i.toString());\n      }\n    }\n    setStoredItem(func, browserCacheVersionKey, browserCacheVersion);\n    setBrowserStorageItemsCount(func, 0);\n    return;\n  }\n  const minTime = Math.floor(Date.now() / browserStorageHour) - browserStorageCacheExpiration;\n  const parseItem = (index) => {\n    const name = browserCachePrefix + index.toString();\n    const item = getStoredItem(func, name);\n    if (typeof item !== \"string\") {\n      return;\n    }\n    try {\n      const data = JSON.parse(item);\n      if (typeof data === \"object\" && typeof data.cached === \"number\" && data.cached > minTime && typeof data.provider === \"string\" && typeof data.data === \"object\" && typeof data.data.prefix === \"string\" && // Valid item: run callback\n      callback(data, index)) {\n        return true;\n      }\n    } catch (err) {\n    }\n    removeStoredItem(func, name);\n  };\n  let total = getBrowserStorageItemsCount(func);\n  for (let i = total - 1; i >= 0; i--) {\n    if (!parseItem(i)) {\n      if (i === total - 1) {\n        total--;\n        setBrowserStorageItemsCount(func, total);\n      } else {\n        browserStorageEmptyItems[key].add(i);\n      }\n    }\n  }\n}\n\nfunction initBrowserStorage() {\n  if (browserStorageStatus) {\n    return;\n  }\n  setBrowserStorageStatus(true);\n  for (const key in browserStorageConfig) {\n    iterateBrowserStorage(key, (item) => {\n      const iconSet = item.data;\n      const provider = item.provider;\n      const prefix = iconSet.prefix;\n      const storage = getStorage(\n        provider,\n        prefix\n      );\n      if (!addIconSet(storage, iconSet).length) {\n        return false;\n      }\n      const lastModified = iconSet.lastModified || -1;\n      storage.lastModifiedCached = storage.lastModifiedCached ? Math.min(storage.lastModifiedCached, lastModified) : lastModified;\n      return true;\n    });\n  }\n}\n\nfunction updateLastModified(storage, lastModified) {\n  const lastValue = storage.lastModifiedCached;\n  if (\n    // Matches or newer\n    lastValue && lastValue >= lastModified\n  ) {\n    return lastValue === lastModified;\n  }\n  storage.lastModifiedCached = lastModified;\n  if (lastValue) {\n    for (const key in browserStorageConfig) {\n      iterateBrowserStorage(key, (item) => {\n        const iconSet = item.data;\n        return item.provider !== storage.provider || iconSet.prefix !== storage.prefix || iconSet.lastModified === lastModified;\n      });\n    }\n  }\n  return true;\n}\nfunction storeInBrowserStorage(storage, data) {\n  if (!browserStorageStatus) {\n    initBrowserStorage();\n  }\n  function store(key) {\n    let func;\n    if (!browserStorageConfig[key] || !(func = getBrowserStorage(key))) {\n      return;\n    }\n    const set = browserStorageEmptyItems[key];\n    let index;\n    if (set.size) {\n      set.delete(index = Array.from(set).shift());\n    } else {\n      index = getBrowserStorageItemsCount(func);\n      if (!setBrowserStorageItemsCount(func, index + 1)) {\n        return;\n      }\n    }\n    const item = {\n      cached: Math.floor(Date.now() / browserStorageHour),\n      provider: storage.provider,\n      data\n    };\n    return setStoredItem(\n      func,\n      browserCachePrefix + index.toString(),\n      JSON.stringify(item)\n    );\n  }\n  if (data.lastModified && !updateLastModified(storage, data.lastModified)) {\n    return;\n  }\n  if (!Object.keys(data.icons).length) {\n    return;\n  }\n  if (data.not_found) {\n    data = Object.assign({}, data);\n    delete data.not_found;\n  }\n  if (!store(\"local\")) {\n    store(\"session\");\n  }\n}\n\nfunction emptyCallback() {\n}\nfunction loadedNewIcons(storage) {\n  if (!storage.iconsLoaderFlag) {\n    storage.iconsLoaderFlag = true;\n    setTimeout(() => {\n      storage.iconsLoaderFlag = false;\n      updateCallbacks(storage);\n    });\n  }\n}\nfunction loadNewIcons(storage, icons) {\n  if (!storage.iconsToLoad) {\n    storage.iconsToLoad = icons;\n  } else {\n    storage.iconsToLoad = storage.iconsToLoad.concat(icons).sort();\n  }\n  if (!storage.iconsQueueFlag) {\n    storage.iconsQueueFlag = true;\n    setTimeout(() => {\n      storage.iconsQueueFlag = false;\n      const { provider, prefix } = storage;\n      const icons2 = storage.iconsToLoad;\n      delete storage.iconsToLoad;\n      let api;\n      if (!icons2 || !(api = getAPIModule(provider))) {\n        return;\n      }\n      const params = api.prepare(provider, prefix, icons2);\n      params.forEach((item) => {\n        sendAPIQuery(provider, item, (data) => {\n          if (typeof data !== \"object\") {\n            item.icons.forEach((name) => {\n              storage.missing.add(name);\n            });\n          } else {\n            try {\n              const parsed = addIconSet(\n                storage,\n                data\n              );\n              if (!parsed.length) {\n                return;\n              }\n              const pending = storage.pendingIcons;\n              if (pending) {\n                parsed.forEach((name) => {\n                  pending.delete(name);\n                });\n              }\n              storeInBrowserStorage(storage, data);\n            } catch (err) {\n              console.error(err);\n            }\n          }\n          loadedNewIcons(storage);\n        });\n      });\n    });\n  }\n}\nconst loadIcons = (icons, callback) => {\n  const cleanedIcons = listToIcons(icons, true, allowSimpleNames());\n  const sortedIcons = sortIcons(cleanedIcons);\n  if (!sortedIcons.pending.length) {\n    let callCallback = true;\n    if (callback) {\n      setTimeout(() => {\n        if (callCallback) {\n          callback(\n            sortedIcons.loaded,\n            sortedIcons.missing,\n            sortedIcons.pending,\n            emptyCallback\n          );\n        }\n      });\n    }\n    return () => {\n      callCallback = false;\n    };\n  }\n  const newIcons = /* @__PURE__ */ Object.create(null);\n  const sources = [];\n  let lastProvider, lastPrefix;\n  sortedIcons.pending.forEach((icon) => {\n    const { provider, prefix } = icon;\n    if (prefix === lastPrefix && provider === lastProvider) {\n      return;\n    }\n    lastProvider = provider;\n    lastPrefix = prefix;\n    sources.push(getStorage(provider, prefix));\n    const providerNewIcons = newIcons[provider] || (newIcons[provider] = /* @__PURE__ */ Object.create(null));\n    if (!providerNewIcons[prefix]) {\n      providerNewIcons[prefix] = [];\n    }\n  });\n  sortedIcons.pending.forEach((icon) => {\n    const { provider, prefix, name } = icon;\n    const storage = getStorage(provider, prefix);\n    const pendingQueue = storage.pendingIcons || (storage.pendingIcons = /* @__PURE__ */ new Set());\n    if (!pendingQueue.has(name)) {\n      pendingQueue.add(name);\n      newIcons[provider][prefix].push(name);\n    }\n  });\n  sources.forEach((storage) => {\n    const { provider, prefix } = storage;\n    if (newIcons[provider][prefix].length) {\n      loadNewIcons(storage, newIcons[provider][prefix]);\n    }\n  });\n  return callback ? storeCallback(callback, sortedIcons, sources) : emptyCallback;\n};\nconst loadIcon = (icon) => {\n  return new Promise((fulfill, reject) => {\n    const iconObj = typeof icon === \"string\" ? stringToIcon(icon, true) : icon;\n    if (!iconObj) {\n      reject(icon);\n      return;\n    }\n    loadIcons([iconObj || icon], (loaded) => {\n      if (loaded.length && iconObj) {\n        const data = getIconData(iconObj);\n        if (data) {\n          fulfill({\n            ...defaultIconProps,\n            ...data\n          });\n          return;\n        }\n      }\n      reject(icon);\n    });\n  });\n};\n\nfunction toggleBrowserCache(storage, value) {\n  switch (storage) {\n    case \"local\":\n    case \"session\":\n      browserStorageConfig[storage] = value;\n      break;\n    case \"all\":\n      for (const key in browserStorageConfig) {\n        browserStorageConfig[key] = value;\n      }\n      break;\n  }\n}\n\nfunction mergeCustomisations(defaults, item) {\n  const result = {\n    ...defaults\n  };\n  for (const key in item) {\n    const value = item[key];\n    const valueType = typeof value;\n    if (key in defaultIconSizeCustomisations) {\n      if (value === null || value && (valueType === \"string\" || valueType === \"number\")) {\n        result[key] = value;\n      }\n    } else if (valueType === typeof result[key]) {\n      result[key] = key === \"rotate\" ? value % 4 : value;\n    }\n  }\n  return result;\n}\n\nconst separator = /[\\s,]+/;\nfunction flipFromString(custom, flip) {\n  flip.split(separator).forEach((str) => {\n    const value = str.trim();\n    switch (value) {\n      case \"horizontal\":\n        custom.hFlip = true;\n        break;\n      case \"vertical\":\n        custom.vFlip = true;\n        break;\n    }\n  });\n}\n\nfunction rotateFromString(value, defaultValue = 0) {\n  const units = value.replace(/^-?[0-9.]*/, \"\");\n  function cleanup(value2) {\n    while (value2 < 0) {\n      value2 += 4;\n    }\n    return value2 % 4;\n  }\n  if (units === \"\") {\n    const num = parseInt(value);\n    return isNaN(num) ? 0 : cleanup(num);\n  } else if (units !== value) {\n    let split = 0;\n    switch (units) {\n      case \"%\":\n        split = 25;\n        break;\n      case \"deg\":\n        split = 90;\n    }\n    if (split) {\n      let num = parseFloat(value.slice(0, value.length - units.length));\n      if (isNaN(num)) {\n        return 0;\n      }\n      num = num / split;\n      return num % 1 === 0 ? cleanup(num) : 0;\n    }\n  }\n  return defaultValue;\n}\n\nfunction iconToHTML(body, attributes) {\n  let renderAttribsHTML = body.indexOf(\"xlink:\") === -1 ? \"\" : ' xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n  for (const attr in attributes) {\n    renderAttribsHTML += \" \" + attr + '=\"' + attributes[attr] + '\"';\n  }\n  return '<svg xmlns=\"http://www.w3.org/2000/svg\"' + renderAttribsHTML + \">\" + body + \"</svg>\";\n}\n\nfunction encodeSVGforURL(svg) {\n  return svg.replace(/\"/g, \"'\").replace(/%/g, \"%25\").replace(/#/g, \"%23\").replace(/</g, \"%3C\").replace(/>/g, \"%3E\").replace(/\\s+/g, \" \");\n}\nfunction svgToData(svg) {\n  return \"data:image/svg+xml,\" + encodeSVGforURL(svg);\n}\nfunction svgToURL(svg) {\n  return 'url(\"' + svgToData(svg) + '\")';\n}\n\nconst defaultExtendedIconCustomisations = {\n    ...defaultIconCustomisations,\n    inline: false,\n};\n\n/**\n * Default SVG attributes\n */\nconst svgDefaults = {\n    'xmlns': 'http://www.w3.org/2000/svg',\n    'xmlns:xlink': 'http://www.w3.org/1999/xlink',\n    'aria-hidden': true,\n    'role': 'img',\n};\n/**\n * Style modes\n */\nconst commonProps = {\n    display: 'inline-block',\n};\nconst monotoneProps = {\n    'background-color': 'currentColor',\n};\nconst coloredProps = {\n    'background-color': 'transparent',\n};\n// Dynamically add common props to variables above\nconst propsToAdd = {\n    image: 'var(--svg)',\n    repeat: 'no-repeat',\n    size: '100% 100%',\n};\nconst propsToAddTo = {\n    '-webkit-mask': monotoneProps,\n    'mask': monotoneProps,\n    'background': coloredProps,\n};\nfor (const prefix in propsToAddTo) {\n    const list = propsToAddTo[prefix];\n    for (const prop in propsToAdd) {\n        list[prefix + '-' + prop] = propsToAdd[prop];\n    }\n}\n/**\n * Fix size: add 'px' to numbers\n */\nfunction fixSize(value) {\n    return value + (value.match(/^[-0-9.]+$/) ? 'px' : '');\n}\n/**\n * Generate icon from properties\n */\nfunction render(\n// Icon must be validated before calling this function\nicon, \n// Properties\nprops) {\n    const customisations = mergeCustomisations(defaultExtendedIconCustomisations, props);\n    // Check mode\n    const mode = props.mode || 'svg';\n    const componentProps = (mode === 'svg' ? { ...svgDefaults } : {});\n    if (icon.body.indexOf('xlink:') === -1) {\n        delete componentProps['xmlns:xlink'];\n    }\n    // Create style if missing\n    let style = typeof props.style === 'string' ? props.style : '';\n    // Get element properties\n    for (let key in props) {\n        const value = props[key];\n        if (value === void 0) {\n            continue;\n        }\n        switch (key) {\n            // Properties to ignore\n            case 'icon':\n            case 'style':\n            case 'onLoad':\n            case 'mode':\n                break;\n            // Boolean attributes\n            case 'inline':\n            case 'hFlip':\n            case 'vFlip':\n                customisations[key] =\n                    value === true || value === 'true' || value === 1;\n                break;\n            // Flip as string: 'horizontal,vertical'\n            case 'flip':\n                if (typeof value === 'string') {\n                    flipFromString(customisations, value);\n                }\n                break;\n            // Color: copy to style, add extra ';' in case style is missing it\n            case 'color':\n                style =\n                    style +\n                        (style.length > 0 && style.trim().slice(-1) !== ';'\n                            ? ';'\n                            : '') +\n                        'color: ' +\n                        value +\n                        '; ';\n                break;\n            // Rotation as string\n            case 'rotate':\n                if (typeof value === 'string') {\n                    customisations[key] = rotateFromString(value);\n                }\n                else if (typeof value === 'number') {\n                    customisations[key] = value;\n                }\n                break;\n            // Remove aria-hidden\n            case 'ariaHidden':\n            case 'aria-hidden':\n                if (value !== true && value !== 'true') {\n                    delete componentProps['aria-hidden'];\n                }\n                break;\n            default:\n                if (key.slice(0, 3) === 'on:') {\n                    // Svelte event\n                    break;\n                }\n                // Copy missing property if it does not exist in customisations\n                if (defaultExtendedIconCustomisations[key] === void 0) {\n                    componentProps[key] = value;\n                }\n        }\n    }\n    // Generate icon\n    const item = iconToSVG(icon, customisations);\n    const renderAttribs = item.attributes;\n    // Inline display\n    if (customisations.inline) {\n        // Style overrides it\n        style = 'vertical-align: -0.125em; ' + style;\n    }\n    if (mode === 'svg') {\n        // Add icon stuff\n        Object.assign(componentProps, renderAttribs);\n        // Style\n        if (style !== '') {\n            componentProps.style = style;\n        }\n        // Counter for ids based on \"id\" property to render icons consistently on server and client\n        let localCounter = 0;\n        let id = props.id;\n        if (typeof id === 'string') {\n            // Convert '-' to '_' to avoid errors in animations\n            id = id.replace(/-/g, '_');\n        }\n        // Generate HTML\n        return {\n            svg: true,\n            attributes: componentProps,\n            body: replaceIDs(item.body, id ? () => id + 'ID' + localCounter++ : 'iconifySvelte'),\n        };\n    }\n    // Render <span> with style\n    const { body, width, height } = icon;\n    const useMask = mode === 'mask' ||\n        (mode === 'bg' ? false : body.indexOf('currentColor') !== -1);\n    // Generate SVG\n    const html = iconToHTML(body, {\n        ...renderAttribs,\n        width: width + '',\n        height: height + '',\n    });\n    // Generate style\n    const url = svgToURL(html);\n    const styles = {\n        '--svg': url,\n    };\n    const size = (prop) => {\n        const value = renderAttribs[prop];\n        if (value) {\n            styles[prop] = fixSize(value);\n        }\n    };\n    size('width');\n    size('height');\n    Object.assign(styles, commonProps, useMask ? monotoneProps : coloredProps);\n    let customStyle = '';\n    for (const key in styles) {\n        customStyle += key + ': ' + styles[key] + ';';\n    }\n    componentProps.style = customStyle + style;\n    return {\n        svg: false,\n        attributes: componentProps,\n    };\n}\n\n/**\n * Enable cache\n */\nfunction enableCache(storage) {\n    toggleBrowserCache(storage, true);\n}\n/**\n * Disable cache\n */\nfunction disableCache(storage) {\n    toggleBrowserCache(storage, false);\n}\n/**\n * Initialise stuff\n */\n// Enable short names\nallowSimpleNames(true);\n// Set API module\nsetAPIModule('', fetchAPIModule);\n/**\n * Browser stuff\n */\nif (typeof document !== 'undefined' && typeof window !== 'undefined') {\n    // Set cache and load existing cache\n    initBrowserStorage();\n    const _window = window;\n    // Load icons from global \"IconifyPreload\"\n    if (_window.IconifyPreload !== void 0) {\n        const preload = _window.IconifyPreload;\n        const err = 'Invalid IconifyPreload syntax.';\n        if (typeof preload === 'object' && preload !== null) {\n            (preload instanceof Array ? preload : [preload]).forEach((item) => {\n                try {\n                    if (\n                    // Check if item is an object and not null/array\n                    typeof item !== 'object' ||\n                        item === null ||\n                        item instanceof Array ||\n                        // Check for 'icons' and 'prefix'\n                        typeof item.icons !== 'object' ||\n                        typeof item.prefix !== 'string' ||\n                        // Add icon set\n                        !addCollection(item)) {\n                        console.error(err);\n                    }\n                }\n                catch (e) {\n                    console.error(err);\n                }\n            });\n        }\n    }\n    // Set API from global \"IconifyProviders\"\n    if (_window.IconifyProviders !== void 0) {\n        const providers = _window.IconifyProviders;\n        if (typeof providers === 'object' && providers !== null) {\n            for (let key in providers) {\n                const err = 'IconifyProviders[' + key + '] is invalid.';\n                try {\n                    const value = providers[key];\n                    if (typeof value !== 'object' ||\n                        !value ||\n                        value.resources === void 0) {\n                        continue;\n                    }\n                    if (!addAPIProvider(key, value)) {\n                        console.error(err);\n                    }\n                }\n                catch (e) {\n                    console.error(err);\n                }\n            }\n        }\n    }\n}\n/**\n * Check if component needs to be updated\n */\nfunction checkIconState(icon, state, mounted, callback, onload) {\n    // Abort loading icon\n    function abortLoading() {\n        if (state.loading) {\n            state.loading.abort();\n            state.loading = null;\n        }\n    }\n    // Icon is an object\n    if (typeof icon === 'object' &&\n        icon !== null &&\n        typeof icon.body === 'string') {\n        // Stop loading\n        state.name = '';\n        abortLoading();\n        return { data: { ...defaultIconProps, ...icon } };\n    }\n    // Invalid icon?\n    let iconName;\n    if (typeof icon !== 'string' ||\n        (iconName = stringToIcon(icon, false, true)) === null) {\n        abortLoading();\n        return null;\n    }\n    // Load icon\n    const data = getIconData(iconName);\n    if (!data) {\n        // Icon data is not available\n        // Do not load icon until component is mounted\n        if (mounted && (!state.loading || state.loading.name !== icon)) {\n            // New icon to load\n            abortLoading();\n            state.name = '';\n            state.loading = {\n                name: icon,\n                abort: loadIcons([iconName], callback),\n            };\n        }\n        return null;\n    }\n    // Icon data is available\n    abortLoading();\n    if (state.name !== icon) {\n        state.name = icon;\n        if (onload && !state.destroyed) {\n            onload(icon);\n        }\n    }\n    // Add classes\n    const classes = ['iconify'];\n    if (iconName.prefix !== '') {\n        classes.push('iconify--' + iconName.prefix);\n    }\n    if (iconName.provider !== '') {\n        classes.push('iconify--' + iconName.provider);\n    }\n    return { data, classes };\n}\n/**\n * Generate icon\n */\nfunction generateIcon(icon, props) {\n    return icon\n        ? render({\n            ...defaultIconProps,\n            ...icon,\n        }, props)\n        : null;\n}\n/**\n * Internal API\n */\nconst _api = {\n    getAPIConfig,\n    setAPIModule,\n    sendAPIQuery,\n    setFetch,\n    getFetch,\n    listAPIProviders,\n};\n\nexport { _api, addAPIProvider, addCollection, addIcon, iconToSVG as buildIcon, calculateSize, checkIconState, disableCache, enableCache, generateIcon, getIcon, iconExists, listIcons, loadIcon, loadIcons, replaceIDs };\n","<script context=\"module\">\n\n// Export stuff.\n// Important: duplicate of iconify.ts. When changing exports, they must be changed in both files.\nimport { \n\tenableCache,\n\tdisableCache, \n\ticonExists,\n\tgetIcon,\n\tlistIcons,\n\taddIcon,\n\taddCollection,\n\tcalculateSize,\n\treplaceIDs,\n\tbuildIcon,\n\tloadIcons,\n\tloadIcon,\n\taddAPIProvider,\n\t_api\n} from './functions';\n\nexport { \n\tenableCache,\n\tdisableCache, \n\ticonExists,\n\tgetIcon,\n\tlistIcons,\n\taddIcon,\n\taddCollection,\n\tcalculateSize,\n\treplaceIDs,\n\tbuildIcon,\n\tloadIcons,\n\tloadIcon,\n\taddAPIProvider,\n\t_api\n}\n\n</script>\n<script>\n\timport { onMount, onDestroy, createEventDispatcher } from 'svelte';\n\timport { checkIconState, generateIcon } from './functions';\n\n\t// State\n\tconst state = {\n\t\t// Last icon name\n\t\tname: '',\n\n\t\t// Loading status\n\t\tloading: null,\n\n\t\t// Destroyed status\n\t\tdestroyed: false,\n\t};\n\n\t// Mounted status\n\tlet mounted = false;\n\n\t// Callback counter\n\tlet counter = 0;\n\n\t// Generated data\n\tlet data;\n\n\tconst onLoad = (icon) => {\n\t\t// Legacy onLoad property\n\t\tif (typeof $$props.onLoad === 'function') {\n\t\t\t$$props.onLoad(icon);\n\t\t}\n\t\t// on:load event\n\t\tconst dispatch = createEventDispatcher();\n\t\tdispatch('load', {\n\t\t\ticon\n\t\t});\n\t}\n\n\t// Generate data\n\t$: {\n\t\tcounter;\n\t\tconst iconData = checkIconState($$props.icon, state, mounted, loaded, onLoad);\n\t\tdata = iconData ? generateIcon(iconData.data, $$props) : null;\n\t\tif (data && iconData.classes) {\n\t\t\t// Add classes\n\t\t\tdata.attributes['class'] = (typeof $$props['class'] === 'string' ? $$props['class'] + ' ' : '') + iconData.classes.join(' ');\n\t\t}\n\t}\n\n\t// Increase counter when loaded to force re-calculation of data\n\tfunction loaded() {\n\t\tcounter ++;\n\t}\n\n\t// Force re-render\n\tonMount(() => {\n\t\tmounted = true;\n\t});\n\n\t// Abort loading when component is destroyed\n\tonDestroy(() => {\n\t\tstate.destroyed = true;\n\t\tif (state.loading) {\n\t\t\tstate.loading.abort();\n\t\t\tstate.loading = null;\n\t\t}\n\t})\n</script>\n\n{#if data}\n\t{#if data.svg}\n\t\t<svg {...data.attributes}>\n\t\t\t{@html data.body}\n\t\t</svg>\n\t{:else}\n\t\t<span {...data.attributes} />\n\t{/if}\n{/if}","/**\n * Emulates forthcoming HMR hooks in Svelte.\n *\n * All references to private component state ($$) are now isolated in this\n * module.\n */\nimport {\n  current_component,\n  get_current_component,\n  set_current_component,\n} from 'svelte/internal'\n\nconst captureState = cmp => {\n  // sanity check: propper behaviour here is to crash noisily so that\n  // user knows that they're looking at something broken\n  if (!cmp) {\n    throw new Error('Missing component')\n  }\n  if (!cmp.$$) {\n    throw new Error('Invalid component')\n  }\n\n  const {\n    $$: { callbacks, bound, ctx, props },\n  } = cmp\n\n  const state = cmp.$capture_state()\n\n  // capturing current value of props (or we'll recreate the component with the\n  // initial prop values, that may have changed -- and would not be reflected in\n  // options.props)\n  const hmr_props_values = {}\n  Object.keys(cmp.$$.props).forEach(prop => {\n    hmr_props_values[prop] = ctx[props[prop]]\n  })\n\n  return {\n    ctx,\n    props,\n    callbacks,\n    bound,\n    state,\n    hmr_props_values,\n  }\n}\n\n// remapping all existing bindings (including hmr_future_foo ones) to the\n// new version's props indexes, and refresh them with the new value from\n// context\nconst restoreBound = (cmp, restore) => {\n  // reverse prop:ctxIndex in $$.props to ctxIndex:prop\n  //\n  // ctxIndex can be either a regular index in $$.ctx or a hmr_future_ prop\n  //\n  const propsByIndex = {}\n  for (const [name, i] of Object.entries(restore.props)) {\n    propsByIndex[i] = name\n  }\n\n  // NOTE $$.bound cannot change in the HMR lifetime of a component, because\n  //      if bindings changes, that means the parent component has changed,\n  //      which means the child (current) component will be wholly recreated\n  for (const [oldIndex, updateBinding] of Object.entries(restore.bound)) {\n    // can be either regular prop, or future_hmr_ prop\n    const propName = propsByIndex[oldIndex]\n\n    // this should never happen if remembering of future props is enabled...\n    // in any case, there's nothing we can do about it if we have lost prop\n    // name knowledge at this point\n    if (propName == null) continue\n\n    // NOTE $$.props[propName] also propagates knowledge of a possible\n    //      future prop to the new $$.props (via $$.props being a Proxy)\n    const newIndex = cmp.$$.props[propName]\n    cmp.$$.bound[newIndex] = updateBinding\n\n    // NOTE if the prop doesn't exist or doesn't exist anymore in the new\n    //      version of the component, clearing the binding is the expected\n    //      behaviour (since that's what would happen in non HMR code)\n    const newValue = cmp.$$.ctx[newIndex]\n    updateBinding(newValue)\n  }\n}\n\n// restoreState\n//\n// It is too late to restore context at this point because component instance\n// function has already been called (and so context has already been read).\n// Instead, we rely on setting current_component to the same value it has when\n// the component was first rendered -- which fix support for context, and is\n// also generally more respectful of normal operation.\n//\nconst restoreState = (cmp, restore) => {\n  if (!restore) return\n\n  if (restore.callbacks) {\n    cmp.$$.callbacks = restore.callbacks\n  }\n\n  if (restore.bound) {\n    restoreBound(cmp, restore)\n  }\n\n  // props, props.$$slots are restored at component creation (works\n  // better -- well, at all actually)\n}\n\nconst get_current_component_safe = () => {\n  // NOTE relying on dynamic bindings (current_component) makes us dependent on\n  // bundler config (and apparently it does not work in demo-svelte-nollup)\n  try {\n    // unfortunately, unlike current_component, get_current_component() can\n    // crash in the normal path (when there is really no parent)\n    return get_current_component()\n  } catch (err) {\n    // ... so we need to consider that this error means that there is no parent\n    //\n    // that makes us tightly coupled to the error message but, at least, we\n    // won't mute an unexpected error, which is quite a horrible thing to do\n    if (err.message === 'Function called outside component initialization') {\n      // who knows...\n      return current_component\n    } else {\n      throw err\n    }\n  }\n}\n\nexport const createProxiedComponent = (\n  Component,\n  initialOptions,\n  { allowLiveBinding, onInstance, onMount, onDestroy }\n) => {\n  let cmp\n  let options = initialOptions\n\n  const isCurrent = _cmp => cmp === _cmp\n\n  const assignOptions = (target, anchor, restore, preserveLocalState) => {\n    const props = Object.assign({}, options.props)\n\n    // Filtering props to avoid \"unexpected prop\" warning\n    // NOTE this is based on props present in initial options, but it should\n    //      always works, because props that are passed from the parent can't\n    //      change without a code change to the parent itself -- hence, the\n    //      child component will be fully recreated, and initial options should\n    //      always represent props that are currnetly passed by the parent\n    if (options.props && restore.hmr_props_values) {\n      for (const prop of Object.keys(options.props)) {\n        if (restore.hmr_props_values.hasOwnProperty(prop)) {\n          props[prop] = restore.hmr_props_values[prop]\n        }\n      }\n    }\n\n    if (preserveLocalState && restore.state) {\n      if (Array.isArray(preserveLocalState)) {\n        // form ['a', 'b'] => preserve only 'a' and 'b'\n        props.$$inject = {}\n        for (const key of preserveLocalState) {\n          props.$$inject[key] = restore.state[key]\n        }\n      } else {\n        props.$$inject = restore.state\n      }\n    } else {\n      delete props.$$inject\n    }\n    options = Object.assign({}, initialOptions, {\n      target,\n      anchor,\n      props,\n      hydrate: false,\n    })\n  }\n\n  // Preserving knowledge of \"future props\" -- very hackish version (maybe\n  // there should be an option to opt out of this)\n  //\n  // The use case is bind:something where something doesn't exist yet in the\n  // target component, but comes to exist later, after a HMR update.\n  //\n  // If Svelte can't map a prop in the current version of the component, it\n  // will just completely discard it:\n  // https://github.com/sveltejs/svelte/blob/1632bca34e4803d6b0e0b0abd652ab5968181860/src/runtime/internal/Component.ts#L46\n  //\n  const rememberFutureProps = cmp => {\n    if (typeof Proxy === 'undefined') return\n\n    cmp.$$.props = new Proxy(cmp.$$.props, {\n      get(target, name) {\n        if (target[name] === undefined) {\n          target[name] = 'hmr_future_' + name\n        }\n        return target[name]\n      },\n      set(target, name, value) {\n        target[name] = value\n      },\n    })\n  }\n\n  const instrument = targetCmp => {\n    const createComponent = (Component, restore, previousCmp) => {\n      set_current_component(parentComponent || previousCmp)\n      const comp = new Component(options)\n      // NOTE must be instrumented before restoreState, because restoring\n      // bindings relies on hacked $$.props\n      instrument(comp)\n      restoreState(comp, restore)\n      return comp\n    }\n\n    rememberFutureProps(targetCmp)\n\n    targetCmp.$$.on_hmr = []\n\n    // `conservative: true` means we want to be sure that the new component has\n    // actually been successfuly created before destroying the old instance.\n    // This could be useful for preventing runtime errors in component init to\n    // bring down the whole HMR. Unfortunately the implementation bellow is\n    // broken (FIXME), but that remains an interesting target for when HMR hooks\n    // will actually land in Svelte itself.\n    //\n    // The goal would be to render an error inplace in case of error, to avoid\n    // losing the navigation stack (especially annoying in native, that is not\n    // based on URL navigation, so we lose the current page on each error).\n    //\n    targetCmp.$replace = (\n      Component,\n      {\n        target = options.target,\n        anchor = options.anchor,\n        preserveLocalState,\n        conservative = false,\n      }\n    ) => {\n      const restore = captureState(targetCmp)\n      assignOptions(\n        target || options.target,\n        anchor,\n        restore,\n        preserveLocalState\n      )\n\n      const callbacks = cmp ? cmp.$$.on_hmr : []\n\n      const afterCallbacks = callbacks.map(fn => fn(cmp)).filter(Boolean)\n\n      const previous = cmp\n      if (conservative) {\n        try {\n          const next = createComponent(Component, restore, previous)\n          // prevents on_destroy from firing on non-final cmp instance\n          cmp = null\n          previous.$destroy()\n          cmp = next\n        } catch (err) {\n          cmp = previous\n          throw err\n        }\n      } else {\n        // prevents on_destroy from firing on non-final cmp instance\n        cmp = null\n        if (previous) {\n          // previous can be null if last constructor has crashed\n          previous.$destroy()\n        }\n        cmp = createComponent(Component, restore, cmp)\n      }\n\n      cmp.$$.hmr_cmp = cmp\n\n      for (const fn of afterCallbacks) {\n        fn(cmp)\n      }\n\n      cmp.$$.on_hmr = callbacks\n\n      return cmp\n    }\n\n    // NOTE onMount must provide target & anchor (for us to be able to determinate\n    // \t\t\tactual DOM insertion point)\n    //\n    // \t\t\tAnd also, to support keyed list, it needs to be called each time the\n    // \t\t\tcomponent is moved (same as $$.fragment.m)\n    if (onMount) {\n      const m = targetCmp.$$.fragment.m\n      targetCmp.$$.fragment.m = (...args) => {\n        const result = m(...args)\n        onMount(...args)\n        return result\n      }\n    }\n\n    // NOTE onDestroy must be called even if the call doesn't pass through the\n    //      component's $destroy method (that we can hook onto by ourselves, since\n    //      it's public API) -- this happens a lot in svelte's internals, that\n    //      manipulates cmp.$$.fragment directly, often binding to fragment.d,\n    //      for example\n    if (onDestroy) {\n      targetCmp.$$.on_destroy.push(() => {\n        if (isCurrent(targetCmp)) {\n          onDestroy()\n        }\n      })\n    }\n\n    if (onInstance) {\n      onInstance(targetCmp)\n    }\n\n    // Svelte 3 creates and mount components from their constructor if\n    // options.target is present.\n    //\n    // This means that at this point, the component's `fragment.c` and,\n    // most notably, `fragment.m` will already have been called _from inside\n    // createComponent_. That is: before we have a chance to hook on it.\n    //\n    // Proxy's constructor\n    //   -> createComponent\n    //     -> component constructor\n    //       -> component.$$.fragment.c(...) (or l, if hydrate:true)\n    //       -> component.$$.fragment.m(...)\n    //\n    //   -> you are here <-\n    //\n    if (onMount) {\n      const { target, anchor } = options\n      if (target) {\n        onMount(target, anchor)\n      }\n    }\n  }\n\n  const parentComponent = allowLiveBinding\n    ? current_component\n    : get_current_component_safe()\n\n  cmp = new Component(options)\n  cmp.$$.hmr_cmp = cmp\n\n  instrument(cmp)\n\n  return cmp\n}\n","/* eslint-env browser */\n/**\n * The HMR proxy is a component-like object whose task is to sit in the\n * component tree in place of the proxied component, and rerender each\n * successive versions of said component.\n */\n\nimport { createProxiedComponent } from './svelte-hooks.js'\n\nconst handledMethods = ['constructor', '$destroy']\nconst forwardedMethods = ['$set', '$on']\n\nconst logError = (msg, err) => {\n  // eslint-disable-next-line no-console\n  console.error('[HMR][Svelte]', msg)\n  if (err) {\n    // NOTE avoid too much wrapping around user errors\n    // eslint-disable-next-line no-console\n    console.error(err)\n  }\n}\n\nconst posixify = file => file.replace(/[/\\\\]/g, '/')\n\nconst getBaseName = id =>\n  id\n    .split('/')\n    .pop()\n    .split('.')\n    .slice(0, -1)\n    .join('.')\n\nconst capitalize = str => str[0].toUpperCase() + str.slice(1)\n\nconst getFriendlyName = id => capitalize(getBaseName(posixify(id)))\n\nconst getDebugName = id => `<${getFriendlyName(id)}>`\n\nconst relayCalls = (getTarget, names, dest = {}) => {\n  for (const key of names) {\n    dest[key] = function(...args) {\n      const target = getTarget()\n      if (!target) {\n        return\n      }\n      return target[key] && target[key].call(this, ...args)\n    }\n  }\n  return dest\n}\n\nconst isInternal = key => key !== '$$' && key.slice(0, 2) === '$$'\n\n// This is intented as a somewhat generic / prospective fix to the situation\n// that arised with the introduction of $$set in Svelte 3.24.1 -- trying to\n// avoid giving full knowledge (like its name) of this implementation detail\n// to the proxy. The $$set method can be present or not on the component, and\n// its presence impacts the behaviour (but with HMR it will be tested if it is\n// present _on the proxy_). So the idea here is to expose exactly the same $$\n// props as the current version of the component and, for those that are\n// functions, proxy the calls to the current component.\nconst relayInternalMethods = (proxy, cmp) => {\n  // delete any previously added $$ prop\n  Object.keys(proxy)\n    .filter(isInternal)\n    .forEach(key => {\n      delete proxy[key]\n    })\n  // guard: no component\n  if (!cmp) return\n  // proxy current $$ props to the actual component\n  Object.keys(cmp)\n    .filter(isInternal)\n    .forEach(key => {\n      Object.defineProperty(proxy, key, {\n        configurable: true,\n        get() {\n          const value = cmp[key]\n          if (typeof value !== 'function') return value\n          return (\n            value &&\n            function(...args) {\n              return value.apply(this, args)\n            }\n          )\n        },\n      })\n    })\n}\n\n// proxy custom methods\nconst copyComponentProperties = (proxy, cmp, previous) => {\n  if (previous) {\n    previous.forEach(prop => {\n      delete proxy[prop]\n    })\n  }\n\n  const props = Object.getOwnPropertyNames(Object.getPrototypeOf(cmp))\n  const wrappedProps = props.filter(prop => {\n    if (!handledMethods.includes(prop) && !forwardedMethods.includes(prop)) {\n      Object.defineProperty(proxy, prop, {\n        configurable: true,\n        get() {\n          return cmp[prop]\n        },\n        set(value) {\n          // we're changing it on the real component first to see what it\n          // gives... if it throws an error, we want to throw the same error in\n          // order to most closely follow non-hmr behaviour.\n          cmp[prop] = value\n        },\n      })\n      return true\n    }\n  })\n\n  return wrappedProps\n}\n\n// everything in the constructor!\n//\n// so we don't polute the component class with new members\n//\nclass ProxyComponent {\n  constructor(\n    {\n      Adapter,\n      id,\n      debugName,\n      current, // { Component, hotOptions: { preserveLocalState, ... } }\n      register,\n    },\n    options // { target, anchor, ... }\n  ) {\n    let cmp\n    let disposed = false\n    let lastError = null\n\n    const setComponent = _cmp => {\n      cmp = _cmp\n      relayInternalMethods(this, cmp)\n    }\n\n    const getComponent = () => cmp\n\n    const destroyComponent = () => {\n      // destroyComponent is tolerant (don't crash on no cmp) because it\n      // is possible that reload/rerender is called after a previous\n      // createComponent has failed (hence we have a proxy, but no cmp)\n      if (cmp) {\n        cmp.$destroy()\n        setComponent(null)\n      }\n    }\n\n    const refreshComponent = (target, anchor, conservativeDestroy) => {\n      if (lastError) {\n        lastError = null\n        adapter.rerender()\n      } else {\n        try {\n          const replaceOptions = {\n            target,\n            anchor,\n            preserveLocalState: current.preserveLocalState,\n          }\n          if (conservativeDestroy) {\n            replaceOptions.conservativeDestroy = true\n          }\n          cmp.$replace(current.Component, replaceOptions)\n        } catch (err) {\n          setError(err, target, anchor)\n          if (\n            !current.hotOptions.optimistic ||\n            // non acceptable components (that is components that have to defer\n            // to their parent for rerender -- e.g. accessors, named exports)\n            // are most tricky, and they havent been considered when most of the\n            // code has been written... as a result, they are especially tricky\n            // to deal with, it's better to consider any error with them to be\n            // fatal to avoid odities\n            !current.canAccept ||\n            (err && err.hmrFatal)\n          ) {\n            throw err\n          } else {\n            // const errString = String((err && err.stack) || err)\n            logError(`Error during component init: ${debugName}`, err)\n          }\n        }\n      }\n    }\n\n    const setError = err => {\n      lastError = err\n      adapter.renderError(err)\n    }\n\n    const instance = {\n      hotOptions: current.hotOptions,\n      proxy: this,\n      id,\n      debugName,\n      refreshComponent,\n    }\n\n    const adapter = new Adapter(instance)\n\n    const { afterMount, rerender } = adapter\n\n    // $destroy is not called when a child component is disposed, so we\n    // need to hook from fragment.\n    const onDestroy = () => {\n      // NOTE do NOT call $destroy on the cmp from here; the cmp is already\n      //   dead, this would not work\n      if (!disposed) {\n        disposed = true\n        adapter.dispose()\n        unregister()\n      }\n    }\n\n    // ---- register proxy instance ----\n\n    const unregister = register(rerender)\n\n    // ---- augmented methods ----\n\n    this.$destroy = () => {\n      destroyComponent()\n      onDestroy()\n    }\n\n    // ---- forwarded methods ----\n\n    relayCalls(getComponent, forwardedMethods, this)\n\n    // ---- create & mount target component instance ---\n\n    try {\n      let lastProperties\n      createProxiedComponent(current.Component, options, {\n        allowLiveBinding: current.hotOptions.allowLiveBinding,\n        onDestroy,\n        onMount: afterMount,\n        onInstance: comp => {\n          setComponent(comp)\n          // WARNING the proxy MUST use the same $$ object as its component\n          // instance, because a lot of wiring happens during component\n          // initialisation... lots of references to $$ and $$.fragment have\n          // already been distributed around when the component constructor\n          // returns, before we have a chance to wrap them (and so we can't\n          // wrap them no more, because existing references would become\n          // invalid)\n          this.$$ = comp.$$\n          lastProperties = copyComponentProperties(this, comp, lastProperties)\n        },\n      })\n    } catch (err) {\n      const { target, anchor } = options\n      setError(err, target, anchor)\n      throw err\n    }\n  }\n}\n\nconst syncStatics = (component, proxy, previousKeys) => {\n  // remove previously copied keys\n  if (previousKeys) {\n    for (const key of previousKeys) {\n      delete proxy[key]\n    }\n  }\n\n  // forward static properties and methods\n  const keys = []\n  for (const key in component) {\n    keys.push(key)\n    proxy[key] = component[key]\n  }\n\n  return keys\n}\n\nconst globalListeners = {}\n\nconst onGlobal = (event, fn) => {\n  event = event.toLowerCase()\n  if (!globalListeners[event]) globalListeners[event] = []\n  globalListeners[event].push(fn)\n}\n\nconst fireGlobal = (event, ...args) => {\n  const listeners = globalListeners[event]\n  if (!listeners) return\n  for (const fn of listeners) {\n    fn(...args)\n  }\n}\n\nconst fireBeforeUpdate = () => fireGlobal('beforeupdate')\n\nconst fireAfterUpdate = () => fireGlobal('afterupdate')\n\nif (typeof window !== 'undefined') {\n  window.__SVELTE_HMR = {\n    on: onGlobal,\n  }\n  window.dispatchEvent(new CustomEvent('svelte-hmr:ready'))\n}\n\nlet fatalError = false\n\nexport const hasFatalError = () => fatalError\n\n/**\n * Creates a HMR proxy and its associated `reload` function that pushes a new\n * version to all existing instances of the component.\n */\nexport function createProxy({\n  Adapter,\n  id,\n  Component,\n  hotOptions,\n  canAccept,\n  preserveLocalState,\n}) {\n  const debugName = getDebugName(id)\n  const instances = []\n\n  // current object will be updated, proxy instances will keep a ref\n  const current = {\n    Component,\n    hotOptions,\n    canAccept,\n    preserveLocalState,\n  }\n\n  const name = `Proxy${debugName}`\n\n  // this trick gives the dynamic name Proxy<MyComponent> to the concrete\n  // proxy class... unfortunately, this doesn't shows in dev tools, but\n  // it stills allow to inspect cmp.constructor.name to confirm an instance\n  // is a proxy\n  const proxy = {\n    [name]: class extends ProxyComponent {\n      constructor(options) {\n        try {\n          super(\n            {\n              Adapter,\n              id,\n              debugName,\n              current,\n              register: rerender => {\n                instances.push(rerender)\n                const unregister = () => {\n                  const i = instances.indexOf(rerender)\n                  instances.splice(i, 1)\n                }\n                return unregister\n              },\n            },\n            options\n          )\n        } catch (err) {\n          // If we fail to create a proxy instance, any instance, that means\n          // that we won't be able to fix this instance when it is updated.\n          // Recovering to normal state will be impossible. HMR's dead.\n          //\n          // Fatal error will trigger a full reload on next update (reloading\n          // right now is kinda pointless since buggy code still exists).\n          //\n          // NOTE Only report first error to avoid too much polution -- following\n          // errors are probably caused by the first one, or they will show up\n          // in turn when the first one is fixed ¯\\_(ツ)_/¯\n          //\n          if (!fatalError) {\n            fatalError = true\n            logError(\n              `Unrecoverable HMR error in ${debugName}: ` +\n                `next update will trigger a full reload`\n            )\n          }\n          throw err\n        }\n      }\n    },\n  }[name]\n\n  // initialize static members\n  let previousStatics = syncStatics(current.Component, proxy)\n\n  const update = newState => Object.assign(current, newState)\n\n  // reload all existing instances of this component\n  const reload = () => {\n    fireBeforeUpdate()\n\n    // copy statics before doing anything because a static prop/method\n    // could be used somewhere in the create/render call\n    previousStatics = syncStatics(current.Component, proxy, previousStatics)\n\n    const errors = []\n\n    instances.forEach(rerender => {\n      try {\n        rerender()\n      } catch (err) {\n        logError(`Failed to rerender ${debugName}`, err)\n        errors.push(err)\n      }\n    })\n\n    if (errors.length > 0) {\n      return false\n    }\n\n    fireAfterUpdate()\n\n    return true\n  }\n\n  const hasFatalError = () => fatalError\n\n  return { id, proxy, update, reload, hasFatalError, current }\n}\n","/* eslint-env browser */\n\nimport { createProxy, hasFatalError } from './proxy.js'\n\nconst logPrefix = '[HMR:Svelte]'\n\n// eslint-disable-next-line no-console\nconst log = (...args) => console.log(logPrefix, ...args)\n\nconst domReload = () => {\n  // eslint-disable-next-line no-undef\n  const win = typeof window !== 'undefined' && window\n  if (win && win.location && win.location.reload) {\n    log('Reload')\n    win.location.reload()\n  } else {\n    log('Full reload required')\n  }\n}\n\nconst replaceCss = (previousId, newId) => {\n  if (typeof document === 'undefined') return false\n  if (!previousId) return false\n  if (!newId) return false\n  // svelte-xxx-style => svelte-xxx\n  const previousClass = previousId.slice(0, -6)\n  const newClass = newId.slice(0, -6)\n  // eslint-disable-next-line no-undef\n  document.querySelectorAll('.' + previousClass).forEach(el => {\n    el.classList.remove(previousClass)\n    el.classList.add(newClass)\n  })\n  return true\n}\n\nconst removeStylesheet = cssId => {\n  if (cssId == null) return\n  if (typeof document === 'undefined') return\n  // eslint-disable-next-line no-undef\n  const el = document.getElementById(cssId)\n  if (el) el.remove()\n  return\n}\n\nconst defaultArgs = {\n  reload: domReload,\n}\n\nexport const makeApplyHmr = transformArgs => args => {\n  const allArgs = transformArgs({ ...defaultArgs, ...args })\n  return applyHmr(allArgs)\n}\n\nlet needsReload = false\n\nfunction applyHmr(args) {\n  const {\n    id,\n    cssId,\n    nonCssHash,\n    reload = domReload,\n    // normalized hot API (must conform to rollup-plugin-hot)\n    hot,\n    hotOptions,\n    Component,\n    acceptable, // some types of components are impossible to HMR correctly\n    preserveLocalState,\n    ProxyAdapter,\n    emitCss,\n  } = args\n\n  const existing = hot.data && hot.data.record\n\n  const canAccept = acceptable && (!existing || existing.current.canAccept)\n\n  const r =\n    existing ||\n    createProxy({\n      Adapter: ProxyAdapter,\n      id,\n      Component,\n      hotOptions,\n      canAccept,\n      preserveLocalState,\n    })\n\n  const cssOnly =\n    hotOptions.injectCss &&\n    existing &&\n    nonCssHash &&\n    existing.current.nonCssHash === nonCssHash\n\n  r.update({\n    Component,\n    hotOptions,\n    canAccept,\n    nonCssHash,\n    cssId,\n    previousCssId: r.current.cssId,\n    cssOnly,\n    preserveLocalState,\n  })\n\n  hot.dispose(data => {\n    // handle previous fatal errors\n    if (needsReload || hasFatalError()) {\n      if (hotOptions && hotOptions.noReload) {\n        log('Full reload required')\n      } else {\n        reload()\n      }\n    }\n\n    // 2020-09-21 Snowpack master doesn't pass data as arg to dispose handler\n    data = data || hot.data\n\n    data.record = r\n\n    if (!emitCss && cssId && r.current.cssId !== cssId) {\n      if (hotOptions.cssEjectDelay) {\n        setTimeout(() => removeStylesheet(cssId), hotOptions.cssEjectDelay)\n      } else {\n        removeStylesheet(cssId)\n      }\n    }\n  })\n\n  if (canAccept) {\n    hot.accept(async arg => {\n      const { bubbled } = arg || {}\n\n      // NOTE Snowpack registers accept handlers only once, so we can NOT rely\n      // on the surrounding scope variables -- they're not the last version!\n      const { cssId: newCssId, previousCssId } = r.current\n      const cssChanged = newCssId !== previousCssId\n      // ensure old style sheet has been removed by now\n      if (!emitCss && cssChanged) removeStylesheet(previousCssId)\n      // guard: css only change\n      if (\n        // NOTE bubbled is provided only by rollup-plugin-hot, and we\n        // can't safely assume a CSS only change without it... this means we\n        // can't support CSS only injection with Nollup or Webpack currently\n        bubbled === false && // WARNING check false, not falsy!\n        r.current.cssOnly &&\n        (!cssChanged || replaceCss(previousCssId, newCssId))\n      ) {\n        return\n      }\n\n      const success = await r.reload()\n\n      if (hasFatalError() || (!success && !hotOptions.optimistic)) {\n        needsReload = true\n      }\n    })\n  }\n\n  // well, endgame... we won't be able to render next updates, even successful,\n  // if we don't have proxies in svelte's tree\n  //\n  // since we won't return the proxy and the app will expect a svelte component,\n  // it's gonna crash... so it's best to report the real cause\n  //\n  // full reload required\n  //\n  const proxyOk = r && r.proxy\n  if (!proxyOk) {\n    throw new Error(`Failed to create HMR proxy for Svelte component ${id}`)\n  }\n\n  return r.proxy\n}\n","export { makeApplyHmr } from './hot-api.js'\n","import { makeApplyHmr } from 'svelte-hmr/runtime';\r\n\r\n// eslint-disable-next-line no-undef\r\nconst g = typeof window !== 'undefined' ? window : global;\r\n\r\nconst globalKey =\r\n\ttypeof Symbol !== 'undefined'\r\n\t\t? Symbol('SVELTE_LOADER_HOT')\r\n\t\t: '__SVELTE_LOADER_HOT';\r\n\r\nif (!g[globalKey]) {\r\n\t// do updating refs counting to know when a full update has been applied\r\n\tlet updatingCount = 0;\r\n\r\n\tconst notifyStart = () => {\r\n\t\tupdatingCount++;\r\n\t};\r\n\r\n\tconst notifyError = reload => err => {\r\n\t\tconst errString = (err && err.stack) || err;\r\n\t\t// eslint-disable-next-line no-console\r\n\t\tconsole.error(\r\n\t\t\t'[HMR] Failed to accept update (nollup compat mode)',\r\n\t\t\terrString\r\n\t\t);\r\n\t\treload();\r\n\t\tnotifyEnd();\r\n\t};\r\n\r\n\tconst notifyEnd = () => {\r\n\t\tupdatingCount--;\r\n\t\tif (updatingCount === 0) {\r\n\t\t\t// NOTE this message is important for timing in tests\r\n\t\t\t// eslint-disable-next-line no-console\r\n\t\t\tconsole.log('[HMR:Svelte] Up to date');\r\n\t\t}\r\n\t};\r\n\r\n\tg[globalKey] = {\r\n\t\thotStates: {},\r\n\t\tnotifyStart,\r\n\t\tnotifyError,\r\n\t\tnotifyEnd,\r\n\t};\r\n}\r\n\r\nconst runAcceptHandlers = acceptHandlers => {\r\n\tconst queue = [...acceptHandlers];\r\n\tconst next = () => {\r\n\t\tconst cur = queue.shift();\r\n\t\tif (cur) {\r\n\t\t\treturn cur(null).then(next);\r\n\t\t} else {\r\n\t\t\treturn Promise.resolve(null);\r\n\t\t}\r\n\t};\r\n\treturn next();\r\n};\r\n\r\nexport const applyHmr = makeApplyHmr(args => {\r\n\tconst { notifyStart, notifyError, notifyEnd } = g[globalKey];\r\n\tconst { m, reload } = args;\r\n\r\n\tlet acceptHandlers = (m.hot.data && m.hot.data.acceptHandlers) || [];\r\n\tlet nextAcceptHandlers = [];\r\n\r\n\tm.hot.dispose(data => {\r\n\t\tdata.acceptHandlers = nextAcceptHandlers;\r\n\t});\r\n\r\n\tconst dispose = (...args) => m.hot.dispose(...args);\r\n\r\n\tconst accept = handler => {\r\n\t\tif (nextAcceptHandlers.length === 0) {\r\n\t\t\tm.hot.accept();\r\n\t\t}\r\n\t\tnextAcceptHandlers.push(handler);\r\n\t};\r\n\r\n\tconst check = status => {\r\n\t\tif (status === 'ready') {\r\n\t\t\tnotifyStart();\r\n\t\t} else if (status === 'idle') {\r\n\t\t\trunAcceptHandlers(acceptHandlers)\r\n\t\t\t\t.then(notifyEnd)\r\n\t\t\t\t.catch(notifyError(reload));\r\n\t\t}\r\n\t};\r\n\r\n\tm.hot.addStatusHandler(check);\r\n\r\n\tm.hot.dispose(() => {\r\n\t\tm.hot.removeStatusHandler(check);\r\n\t});\r\n\r\n\tconst hot = {\r\n\t\tdata: m.hot.data,\r\n\t\tdispose,\r\n\t\taccept,\r\n\t};\r\n\r\n\treturn { ...args, hot };\r\n});\r\n","function themeToggle(){var toggleEl=document.querySelector(\"[data-toggle-theme]\");(function(theme=localStorage.getItem(\"theme\")){if(localStorage.getItem(\"theme\")){document.documentElement.setAttribute(\"data-theme\",theme);if(toggleEl){[...document.querySelectorAll(\"[data-toggle-theme]\")].forEach(el=>{el.classList.add(toggleEl.getAttribute(\"data-act-class\"))})}}})();if(toggleEl){[...document.querySelectorAll(\"[data-toggle-theme]\")].forEach(el=>{el.addEventListener(\"click\",function(){var themesList=el.getAttribute(\"data-toggle-theme\");if(themesList){var themesArray=themesList.split(\",\");if(document.documentElement.getAttribute(\"data-theme\")==themesArray[0]){if(themesArray.length==1){document.documentElement.removeAttribute(\"data-theme\");localStorage.removeItem(\"theme\")}else{document.documentElement.setAttribute(\"data-theme\",themesArray[1]);localStorage.setItem(\"theme\",themesArray[1])}}else{document.documentElement.setAttribute(\"data-theme\",themesArray[0]);localStorage.setItem(\"theme\",themesArray[0])}}[...document.querySelectorAll(\"[data-toggle-theme]\")].forEach(el=>{el.classList.toggle(this.getAttribute(\"data-act-class\"))})})})}}function themeBtn(){(function(theme=localStorage.getItem(\"theme\")){if(theme!=undefined&&theme!=\"\"){if(localStorage.getItem(\"theme\")&&localStorage.getItem(\"theme\")!=\"\"){document.documentElement.setAttribute(\"data-theme\",theme);var btnEl=document.querySelector(\"[data-set-theme='\"+theme.toString()+\"']\");if(btnEl){[...document.querySelectorAll(\"[data-set-theme]\")].forEach(el=>{el.classList.remove(el.getAttribute(\"data-act-class\"))});if(btnEl.getAttribute(\"data-act-class\")){btnEl.classList.add(btnEl.getAttribute(\"data-act-class\"))}}}else{var btnEl=document.querySelector(\"[data-set-theme='']\");if(btnEl.getAttribute(\"data-act-class\")){btnEl.classList.add(btnEl.getAttribute(\"data-act-class\"))}}}})();[...document.querySelectorAll(\"[data-set-theme]\")].forEach(el=>{el.addEventListener(\"click\",function(){document.documentElement.setAttribute(\"data-theme\",this.getAttribute(\"data-set-theme\"));localStorage.setItem(\"theme\",document.documentElement.getAttribute(\"data-theme\"));[...document.querySelectorAll(\"[data-set-theme]\")].forEach(el=>{el.classList.remove(el.getAttribute(\"data-act-class\"))});if(el.getAttribute(\"data-act-class\")){el.classList.add(el.getAttribute(\"data-act-class\"))}})})}function themeSelect(){(function(theme=localStorage.getItem(\"theme\")){if(localStorage.getItem(\"theme\")){document.documentElement.setAttribute(\"data-theme\",theme);var optionToggler=document.querySelector(\"select[data-choose-theme] [value='\"+theme.toString()+\"']\");if(optionToggler){[...document.querySelectorAll(\"select[data-choose-theme] [value='\"+theme.toString()+\"']\")].forEach(el=>{el.selected=true})}}})();if(document.querySelector(\"select[data-choose-theme]\")){[...document.querySelectorAll(\"select[data-choose-theme]\")].forEach(el=>{el.addEventListener(\"change\",function(){document.documentElement.setAttribute(\"data-theme\",this.value);localStorage.setItem(\"theme\",document.documentElement.getAttribute(\"data-theme\"));[...document.querySelectorAll(\"select[data-choose-theme] [value='\"+localStorage.getItem(\"theme\")+\"']\")].forEach(el=>{el.selected=true})})})}}function themeChange(attach=true){if(attach===true){document.addEventListener(\"DOMContentLoaded\",function(event){themeToggle();themeSelect();themeBtn()})}else{themeToggle();themeSelect();themeBtn()}}if(typeof exports!=\"undefined\"){module.exports={themeChange:themeChange}}else{themeChange()}","(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define(\"webextension-polyfill\", [\"module\"], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(module);\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod);\n    global.browser = mod.exports;\n  }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (module) {\n  /* webextension-polyfill - v0.10.0 - Fri Aug 12 2022 19:42:44 */\n\n  /* -*- Mode: indent-tabs-mode: nil; js-indent-level: 2 -*- */\n\n  /* vim: set sts=2 sw=2 et tw=80: */\n\n  /* This Source Code Form is subject to the terms of the Mozilla Public\n   * License, v. 2.0. If a copy of the MPL was not distributed with this\n   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n  \"use strict\";\n\n  if (!globalThis.chrome?.runtime?.id) {\n    throw new Error(\"This script should only be loaded in a browser extension.\");\n  }\n\n  if (typeof globalThis.browser === \"undefined\" || Object.getPrototypeOf(globalThis.browser) !== Object.prototype) {\n    const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = \"The message port closed before a response was received.\"; // Wrapping the bulk of this polyfill in a one-time-use function is a minor\n    // optimization for Firefox. Since Spidermonkey does not fully parse the\n    // contents of a function until the first time it's called, and since it will\n    // never actually need to be called, this allows the polyfill to be included\n    // in Firefox nearly for free.\n\n    const wrapAPIs = extensionAPIs => {\n      // NOTE: apiMetadata is associated to the content of the api-metadata.json file\n      // at build time by replacing the following \"include\" with the content of the\n      // JSON file.\n      const apiMetadata = {\n        \"alarms\": {\n          \"clear\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"clearAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"bookmarks\": {\n          \"create\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getChildren\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getRecent\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getSubTree\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getTree\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"move\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeTree\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"search\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        },\n        \"browserAction\": {\n          \"disable\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"enable\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"getBadgeBackgroundColor\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getBadgeText\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"openPopup\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"setBadgeBackgroundColor\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setBadgeText\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setIcon\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"setPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          }\n        },\n        \"browsingData\": {\n          \"remove\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"removeCache\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeCookies\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeDownloads\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeFormData\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeHistory\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeLocalStorage\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removePasswords\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removePluginData\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"settings\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"commands\": {\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"contextMenus\": {\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        },\n        \"cookies\": {\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAllCookieStores\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"set\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"devtools\": {\n          \"inspectedWindow\": {\n            \"eval\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 2,\n              \"singleCallbackArg\": false\n            }\n          },\n          \"panels\": {\n            \"create\": {\n              \"minArgs\": 3,\n              \"maxArgs\": 3,\n              \"singleCallbackArg\": true\n            },\n            \"elements\": {\n              \"createSidebarPane\": {\n                \"minArgs\": 1,\n                \"maxArgs\": 1\n              }\n            }\n          }\n        },\n        \"downloads\": {\n          \"cancel\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"download\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"erase\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getFileIcon\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"open\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"pause\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeFile\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"resume\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"search\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"show\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          }\n        },\n        \"extension\": {\n          \"isAllowedFileSchemeAccess\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"isAllowedIncognitoAccess\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"history\": {\n          \"addUrl\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"deleteAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"deleteRange\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"deleteUrl\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getVisits\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"search\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"i18n\": {\n          \"detectLanguage\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAcceptLanguages\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"identity\": {\n          \"launchWebAuthFlow\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"idle\": {\n          \"queryState\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"management\": {\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getSelf\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"setEnabled\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"uninstallSelf\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          }\n        },\n        \"notifications\": {\n          \"clear\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"create\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getPermissionLevel\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        },\n        \"pageAction\": {\n          \"getPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"hide\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setIcon\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"setPopup\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"setTitle\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          },\n          \"show\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1,\n            \"fallbackToNoCallback\": true\n          }\n        },\n        \"permissions\": {\n          \"contains\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"request\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"runtime\": {\n          \"getBackgroundPage\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getPlatformInfo\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"openOptionsPage\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"requestUpdateCheck\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"sendMessage\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 3\n          },\n          \"sendNativeMessage\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"setUninstallURL\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"sessions\": {\n          \"getDevices\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getRecentlyClosed\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"restore\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          }\n        },\n        \"storage\": {\n          \"local\": {\n            \"clear\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 0\n            },\n            \"get\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"getBytesInUse\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"remove\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            },\n            \"set\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            }\n          },\n          \"managed\": {\n            \"get\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"getBytesInUse\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            }\n          },\n          \"sync\": {\n            \"clear\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 0\n            },\n            \"get\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"getBytesInUse\": {\n              \"minArgs\": 0,\n              \"maxArgs\": 1\n            },\n            \"remove\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            },\n            \"set\": {\n              \"minArgs\": 1,\n              \"maxArgs\": 1\n            }\n          }\n        },\n        \"tabs\": {\n          \"captureVisibleTab\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 2\n          },\n          \"create\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"detectLanguage\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"discard\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"duplicate\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"executeScript\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getCurrent\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          },\n          \"getZoom\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getZoomSettings\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"goBack\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"goForward\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"highlight\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"insertCSS\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"move\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          },\n          \"query\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"reload\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 2\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"removeCSS\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"sendMessage\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 3\n          },\n          \"setZoom\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"setZoomSettings\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"update\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          }\n        },\n        \"topSites\": {\n          \"get\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"webNavigation\": {\n          \"getAllFrames\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"getFrame\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          }\n        },\n        \"webRequest\": {\n          \"handlerBehaviorChanged\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 0\n          }\n        },\n        \"windows\": {\n          \"create\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"get\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 2\n          },\n          \"getAll\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getCurrent\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"getLastFocused\": {\n            \"minArgs\": 0,\n            \"maxArgs\": 1\n          },\n          \"remove\": {\n            \"minArgs\": 1,\n            \"maxArgs\": 1\n          },\n          \"update\": {\n            \"minArgs\": 2,\n            \"maxArgs\": 2\n          }\n        }\n      };\n\n      if (Object.keys(apiMetadata).length === 0) {\n        throw new Error(\"api-metadata.json has not been included in browser-polyfill\");\n      }\n      /**\n       * A WeakMap subclass which creates and stores a value for any key which does\n       * not exist when accessed, but behaves exactly as an ordinary WeakMap\n       * otherwise.\n       *\n       * @param {function} createItem\n       *        A function which will be called in order to create the value for any\n       *        key which does not exist, the first time it is accessed. The\n       *        function receives, as its only argument, the key being created.\n       */\n\n\n      class DefaultWeakMap extends WeakMap {\n        constructor(createItem, items = undefined) {\n          super(items);\n          this.createItem = createItem;\n        }\n\n        get(key) {\n          if (!this.has(key)) {\n            this.set(key, this.createItem(key));\n          }\n\n          return super.get(key);\n        }\n\n      }\n      /**\n       * Returns true if the given object is an object with a `then` method, and can\n       * therefore be assumed to behave as a Promise.\n       *\n       * @param {*} value The value to test.\n       * @returns {boolean} True if the value is thenable.\n       */\n\n\n      const isThenable = value => {\n        return value && typeof value === \"object\" && typeof value.then === \"function\";\n      };\n      /**\n       * Creates and returns a function which, when called, will resolve or reject\n       * the given promise based on how it is called:\n       *\n       * - If, when called, `chrome.runtime.lastError` contains a non-null object,\n       *   the promise is rejected with that value.\n       * - If the function is called with exactly one argument, the promise is\n       *   resolved to that value.\n       * - Otherwise, the promise is resolved to an array containing all of the\n       *   function's arguments.\n       *\n       * @param {object} promise\n       *        An object containing the resolution and rejection functions of a\n       *        promise.\n       * @param {function} promise.resolve\n       *        The promise's resolution function.\n       * @param {function} promise.reject\n       *        The promise's rejection function.\n       * @param {object} metadata\n       *        Metadata about the wrapped method which has created the callback.\n       * @param {boolean} metadata.singleCallbackArg\n       *        Whether or not the promise is resolved with only the first\n       *        argument of the callback, alternatively an array of all the\n       *        callback arguments is resolved. By default, if the callback\n       *        function is invoked with only a single argument, that will be\n       *        resolved to the promise, while all arguments will be resolved as\n       *        an array if multiple are given.\n       *\n       * @returns {function}\n       *        The generated callback function.\n       */\n\n\n      const makeCallback = (promise, metadata) => {\n        return (...callbackArgs) => {\n          if (extensionAPIs.runtime.lastError) {\n            promise.reject(new Error(extensionAPIs.runtime.lastError.message));\n          } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {\n            promise.resolve(callbackArgs[0]);\n          } else {\n            promise.resolve(callbackArgs);\n          }\n        };\n      };\n\n      const pluralizeArguments = numArgs => numArgs == 1 ? \"argument\" : \"arguments\";\n      /**\n       * Creates a wrapper function for a method with the given name and metadata.\n       *\n       * @param {string} name\n       *        The name of the method which is being wrapped.\n       * @param {object} metadata\n       *        Metadata about the method being wrapped.\n       * @param {integer} metadata.minArgs\n       *        The minimum number of arguments which must be passed to the\n       *        function. If called with fewer than this number of arguments, the\n       *        wrapper will raise an exception.\n       * @param {integer} metadata.maxArgs\n       *        The maximum number of arguments which may be passed to the\n       *        function. If called with more than this number of arguments, the\n       *        wrapper will raise an exception.\n       * @param {boolean} metadata.singleCallbackArg\n       *        Whether or not the promise is resolved with only the first\n       *        argument of the callback, alternatively an array of all the\n       *        callback arguments is resolved. By default, if the callback\n       *        function is invoked with only a single argument, that will be\n       *        resolved to the promise, while all arguments will be resolved as\n       *        an array if multiple are given.\n       *\n       * @returns {function(object, ...*)}\n       *       The generated wrapper function.\n       */\n\n\n      const wrapAsyncFunction = (name, metadata) => {\n        return function asyncFunctionWrapper(target, ...args) {\n          if (args.length < metadata.minArgs) {\n            throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);\n          }\n\n          if (args.length > metadata.maxArgs) {\n            throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);\n          }\n\n          return new Promise((resolve, reject) => {\n            if (metadata.fallbackToNoCallback) {\n              // This API method has currently no callback on Chrome, but it return a promise on Firefox,\n              // and so the polyfill will try to call it with a callback first, and it will fallback\n              // to not passing the callback if the first call fails.\n              try {\n                target[name](...args, makeCallback({\n                  resolve,\n                  reject\n                }, metadata));\n              } catch (cbError) {\n                console.warn(`${name} API method doesn't seem to support the callback parameter, ` + \"falling back to call it without a callback: \", cbError);\n                target[name](...args); // Update the API method metadata, so that the next API calls will not try to\n                // use the unsupported callback anymore.\n\n                metadata.fallbackToNoCallback = false;\n                metadata.noCallback = true;\n                resolve();\n              }\n            } else if (metadata.noCallback) {\n              target[name](...args);\n              resolve();\n            } else {\n              target[name](...args, makeCallback({\n                resolve,\n                reject\n              }, metadata));\n            }\n          });\n        };\n      };\n      /**\n       * Wraps an existing method of the target object, so that calls to it are\n       * intercepted by the given wrapper function. The wrapper function receives,\n       * as its first argument, the original `target` object, followed by each of\n       * the arguments passed to the original method.\n       *\n       * @param {object} target\n       *        The original target object that the wrapped method belongs to.\n       * @param {function} method\n       *        The method being wrapped. This is used as the target of the Proxy\n       *        object which is created to wrap the method.\n       * @param {function} wrapper\n       *        The wrapper function which is called in place of a direct invocation\n       *        of the wrapped method.\n       *\n       * @returns {Proxy<function>}\n       *        A Proxy object for the given method, which invokes the given wrapper\n       *        method in its place.\n       */\n\n\n      const wrapMethod = (target, method, wrapper) => {\n        return new Proxy(method, {\n          apply(targetMethod, thisObj, args) {\n            return wrapper.call(thisObj, target, ...args);\n          }\n\n        });\n      };\n\n      let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);\n      /**\n       * Wraps an object in a Proxy which intercepts and wraps certain methods\n       * based on the given `wrappers` and `metadata` objects.\n       *\n       * @param {object} target\n       *        The target object to wrap.\n       *\n       * @param {object} [wrappers = {}]\n       *        An object tree containing wrapper functions for special cases. Any\n       *        function present in this object tree is called in place of the\n       *        method in the same location in the `target` object tree. These\n       *        wrapper methods are invoked as described in {@see wrapMethod}.\n       *\n       * @param {object} [metadata = {}]\n       *        An object tree containing metadata used to automatically generate\n       *        Promise-based wrapper functions for asynchronous. Any function in\n       *        the `target` object tree which has a corresponding metadata object\n       *        in the same location in the `metadata` tree is replaced with an\n       *        automatically-generated wrapper function, as described in\n       *        {@see wrapAsyncFunction}\n       *\n       * @returns {Proxy<object>}\n       */\n\n      const wrapObject = (target, wrappers = {}, metadata = {}) => {\n        let cache = Object.create(null);\n        let handlers = {\n          has(proxyTarget, prop) {\n            return prop in target || prop in cache;\n          },\n\n          get(proxyTarget, prop, receiver) {\n            if (prop in cache) {\n              return cache[prop];\n            }\n\n            if (!(prop in target)) {\n              return undefined;\n            }\n\n            let value = target[prop];\n\n            if (typeof value === \"function\") {\n              // This is a method on the underlying object. Check if we need to do\n              // any wrapping.\n              if (typeof wrappers[prop] === \"function\") {\n                // We have a special-case wrapper for this method.\n                value = wrapMethod(target, target[prop], wrappers[prop]);\n              } else if (hasOwnProperty(metadata, prop)) {\n                // This is an async method that we have metadata for. Create a\n                // Promise wrapper for it.\n                let wrapper = wrapAsyncFunction(prop, metadata[prop]);\n                value = wrapMethod(target, target[prop], wrapper);\n              } else {\n                // This is a method that we don't know or care about. Return the\n                // original method, bound to the underlying object.\n                value = value.bind(target);\n              }\n            } else if (typeof value === \"object\" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {\n              // This is an object that we need to do some wrapping for the children\n              // of. Create a sub-object wrapper for it with the appropriate child\n              // metadata.\n              value = wrapObject(value, wrappers[prop], metadata[prop]);\n            } else if (hasOwnProperty(metadata, \"*\")) {\n              // Wrap all properties in * namespace.\n              value = wrapObject(value, wrappers[prop], metadata[\"*\"]);\n            } else {\n              // We don't need to do any wrapping for this property,\n              // so just forward all access to the underlying object.\n              Object.defineProperty(cache, prop, {\n                configurable: true,\n                enumerable: true,\n\n                get() {\n                  return target[prop];\n                },\n\n                set(value) {\n                  target[prop] = value;\n                }\n\n              });\n              return value;\n            }\n\n            cache[prop] = value;\n            return value;\n          },\n\n          set(proxyTarget, prop, value, receiver) {\n            if (prop in cache) {\n              cache[prop] = value;\n            } else {\n              target[prop] = value;\n            }\n\n            return true;\n          },\n\n          defineProperty(proxyTarget, prop, desc) {\n            return Reflect.defineProperty(cache, prop, desc);\n          },\n\n          deleteProperty(proxyTarget, prop) {\n            return Reflect.deleteProperty(cache, prop);\n          }\n\n        }; // Per contract of the Proxy API, the \"get\" proxy handler must return the\n        // original value of the target if that value is declared read-only and\n        // non-configurable. For this reason, we create an object with the\n        // prototype set to `target` instead of using `target` directly.\n        // Otherwise we cannot return a custom object for APIs that\n        // are declared read-only and non-configurable, such as `chrome.devtools`.\n        //\n        // The proxy handlers themselves will still use the original `target`\n        // instead of the `proxyTarget`, so that the methods and properties are\n        // dereferenced via the original targets.\n\n        let proxyTarget = Object.create(target);\n        return new Proxy(proxyTarget, handlers);\n      };\n      /**\n       * Creates a set of wrapper functions for an event object, which handles\n       * wrapping of listener functions that those messages are passed.\n       *\n       * A single wrapper is created for each listener function, and stored in a\n       * map. Subsequent calls to `addListener`, `hasListener`, or `removeListener`\n       * retrieve the original wrapper, so that  attempts to remove a\n       * previously-added listener work as expected.\n       *\n       * @param {DefaultWeakMap<function, function>} wrapperMap\n       *        A DefaultWeakMap object which will create the appropriate wrapper\n       *        for a given listener function when one does not exist, and retrieve\n       *        an existing one when it does.\n       *\n       * @returns {object}\n       */\n\n\n      const wrapEvent = wrapperMap => ({\n        addListener(target, listener, ...args) {\n          target.addListener(wrapperMap.get(listener), ...args);\n        },\n\n        hasListener(target, listener) {\n          return target.hasListener(wrapperMap.get(listener));\n        },\n\n        removeListener(target, listener) {\n          target.removeListener(wrapperMap.get(listener));\n        }\n\n      });\n\n      const onRequestFinishedWrappers = new DefaultWeakMap(listener => {\n        if (typeof listener !== \"function\") {\n          return listener;\n        }\n        /**\n         * Wraps an onRequestFinished listener function so that it will return a\n         * `getContent()` property which returns a `Promise` rather than using a\n         * callback API.\n         *\n         * @param {object} req\n         *        The HAR entry object representing the network request.\n         */\n\n\n        return function onRequestFinished(req) {\n          const wrappedReq = wrapObject(req, {}\n          /* wrappers */\n          , {\n            getContent: {\n              minArgs: 0,\n              maxArgs: 0\n            }\n          });\n          listener(wrappedReq);\n        };\n      });\n      const onMessageWrappers = new DefaultWeakMap(listener => {\n        if (typeof listener !== \"function\") {\n          return listener;\n        }\n        /**\n         * Wraps a message listener function so that it may send responses based on\n         * its return value, rather than by returning a sentinel value and calling a\n         * callback. If the listener function returns a Promise, the response is\n         * sent when the promise either resolves or rejects.\n         *\n         * @param {*} message\n         *        The message sent by the other end of the channel.\n         * @param {object} sender\n         *        Details about the sender of the message.\n         * @param {function(*)} sendResponse\n         *        A callback which, when called with an arbitrary argument, sends\n         *        that value as a response.\n         * @returns {boolean}\n         *        True if the wrapped listener returned a Promise, which will later\n         *        yield a response. False otherwise.\n         */\n\n\n        return function onMessage(message, sender, sendResponse) {\n          let didCallSendResponse = false;\n          let wrappedSendResponse;\n          let sendResponsePromise = new Promise(resolve => {\n            wrappedSendResponse = function (response) {\n              didCallSendResponse = true;\n              resolve(response);\n            };\n          });\n          let result;\n\n          try {\n            result = listener(message, sender, wrappedSendResponse);\n          } catch (err) {\n            result = Promise.reject(err);\n          }\n\n          const isResultThenable = result !== true && isThenable(result); // If the listener didn't returned true or a Promise, or called\n          // wrappedSendResponse synchronously, we can exit earlier\n          // because there will be no response sent from this listener.\n\n          if (result !== true && !isResultThenable && !didCallSendResponse) {\n            return false;\n          } // A small helper to send the message if the promise resolves\n          // and an error if the promise rejects (a wrapped sendMessage has\n          // to translate the message into a resolved promise or a rejected\n          // promise).\n\n\n          const sendPromisedResult = promise => {\n            promise.then(msg => {\n              // send the message value.\n              sendResponse(msg);\n            }, error => {\n              // Send a JSON representation of the error if the rejected value\n              // is an instance of error, or the object itself otherwise.\n              let message;\n\n              if (error && (error instanceof Error || typeof error.message === \"string\")) {\n                message = error.message;\n              } else {\n                message = \"An unexpected error occurred\";\n              }\n\n              sendResponse({\n                __mozWebExtensionPolyfillReject__: true,\n                message\n              });\n            }).catch(err => {\n              // Print an error on the console if unable to send the response.\n              console.error(\"Failed to send onMessage rejected reply\", err);\n            });\n          }; // If the listener returned a Promise, send the resolved value as a\n          // result, otherwise wait the promise related to the wrappedSendResponse\n          // callback to resolve and send it as a response.\n\n\n          if (isResultThenable) {\n            sendPromisedResult(result);\n          } else {\n            sendPromisedResult(sendResponsePromise);\n          } // Let Chrome know that the listener is replying.\n\n\n          return true;\n        };\n      });\n\n      const wrappedSendMessageCallback = ({\n        reject,\n        resolve\n      }, reply) => {\n        if (extensionAPIs.runtime.lastError) {\n          // Detect when none of the listeners replied to the sendMessage call and resolve\n          // the promise to undefined as in Firefox.\n          // See https://github.com/mozilla/webextension-polyfill/issues/130\n          if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {\n            resolve();\n          } else {\n            reject(new Error(extensionAPIs.runtime.lastError.message));\n          }\n        } else if (reply && reply.__mozWebExtensionPolyfillReject__) {\n          // Convert back the JSON representation of the error into\n          // an Error instance.\n          reject(new Error(reply.message));\n        } else {\n          resolve(reply);\n        }\n      };\n\n      const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {\n        if (args.length < metadata.minArgs) {\n          throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);\n        }\n\n        if (args.length > metadata.maxArgs) {\n          throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);\n        }\n\n        return new Promise((resolve, reject) => {\n          const wrappedCb = wrappedSendMessageCallback.bind(null, {\n            resolve,\n            reject\n          });\n          args.push(wrappedCb);\n          apiNamespaceObj.sendMessage(...args);\n        });\n      };\n\n      const staticWrappers = {\n        devtools: {\n          network: {\n            onRequestFinished: wrapEvent(onRequestFinishedWrappers)\n          }\n        },\n        runtime: {\n          onMessage: wrapEvent(onMessageWrappers),\n          onMessageExternal: wrapEvent(onMessageWrappers),\n          sendMessage: wrappedSendMessage.bind(null, \"sendMessage\", {\n            minArgs: 1,\n            maxArgs: 3\n          })\n        },\n        tabs: {\n          sendMessage: wrappedSendMessage.bind(null, \"sendMessage\", {\n            minArgs: 2,\n            maxArgs: 3\n          })\n        }\n      };\n      const settingMetadata = {\n        clear: {\n          minArgs: 1,\n          maxArgs: 1\n        },\n        get: {\n          minArgs: 1,\n          maxArgs: 1\n        },\n        set: {\n          minArgs: 1,\n          maxArgs: 1\n        }\n      };\n      apiMetadata.privacy = {\n        network: {\n          \"*\": settingMetadata\n        },\n        services: {\n          \"*\": settingMetadata\n        },\n        websites: {\n          \"*\": settingMetadata\n        }\n      };\n      return wrapObject(extensionAPIs, staticWrappers, apiMetadata);\n    }; // The build process adds a UMD wrapper around this file, which makes the\n    // `module` variable available.\n\n\n    module.exports = wrapAPIs(chrome);\n  } else {\n    module.exports = globalThis.browser;\n  }\n});\n//# sourceMappingURL=browser-polyfill.js.map\n","/*!\n * Wunderbaum - util\n * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.\n * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)\n */\n/** @module util */\n/** Readable names for `MouseEvent.button` */\nconst MOUSE_BUTTONS = {\n    0: \"\",\n    1: \"left\",\n    2: \"middle\",\n    3: \"right\",\n    4: \"back\",\n    5: \"forward\",\n};\nconst MAX_INT = 9007199254740991;\nconst userInfo = _getUserInfo();\n/**True if the client is using a macOS platform. */\nconst isMac = userInfo.isMac;\nconst REX_HTML = /[&<>\"'/]/g; // Escape those characters\nconst REX_TOOLTIP = /[<>\"'/]/g; // Don't escape `&` in tooltips\nconst ENTITY_MAP = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\",\n    \"/\": \"&#x2F;\",\n};\n/**\n * A ES6 Promise, that exposes the resolve()/reject() methods.\n */\nlet Deferred$1 = class Deferred {\n    constructor() {\n        this.thens = [];\n        this.catches = [];\n        this.status = \"\";\n    }\n    resolve(value) {\n        if (this.status) {\n            throw new Error(\"already settled\");\n        }\n        this.status = \"resolved\";\n        this.resolvedValue = value;\n        this.thens.forEach((t) => t(value));\n        this.thens = []; // Avoid memleaks.\n    }\n    reject(error) {\n        if (this.status) {\n            throw new Error(\"already settled\");\n        }\n        this.status = \"rejected\";\n        this.rejectedError = error;\n        this.catches.forEach((c) => c(error));\n        this.catches = []; // Avoid memleaks.\n    }\n    then(cb) {\n        if (status === \"resolved\") {\n            cb(this.resolvedValue);\n        }\n        else {\n            this.thens.unshift(cb);\n        }\n    }\n    catch(cb) {\n        if (this.status === \"rejected\") {\n            cb(this.rejectedError);\n        }\n        else {\n            this.catches.unshift(cb);\n        }\n    }\n    promise() {\n        return {\n            then: this.then,\n            catch: this.catch,\n        };\n    }\n};\n/**Throw an `Error` if `cond` is falsey. */\nfunction assert(cond, msg) {\n    if (!cond) {\n        msg = msg || \"Assertion failed.\";\n        throw new Error(msg);\n    }\n}\nfunction _getUserInfo() {\n    const nav = navigator;\n    // const ua = nav.userAgentData;\n    const res = {\n        isMac: /Mac/.test(nav.platform),\n    };\n    return res;\n}\n/** Run `callback` when document was loaded. */\nfunction documentReady(callback) {\n    if (document.readyState === \"loading\") {\n        document.addEventListener(\"DOMContentLoaded\", callback);\n    }\n    else {\n        callback();\n    }\n}\n/** Resolve when document was loaded. */\nfunction documentReadyPromise() {\n    return new Promise((resolve) => {\n        documentReady(resolve);\n    });\n}\n/**\n * Iterate over Object properties or array elements.\n *\n * @param obj `Object`, `Array` or null\n * @param callback(index, item) called for every item.\n *  `this` also contains the item.\n *  Return `false` to stop the iteration.\n */\nfunction each(obj, callback) {\n    if (obj == null) {\n        // accept `null` or `undefined`\n        return obj;\n    }\n    let length = obj.length, i = 0;\n    if (typeof length === \"number\") {\n        for (; i < length; i++) {\n            if (callback.call(obj[i], i, obj[i]) === false) {\n                break;\n            }\n        }\n    }\n    else {\n        for (let k in obj) {\n            if (callback.call(obj[i], k, obj[k]) === false) {\n                break;\n            }\n        }\n    }\n    return obj;\n}\n/** Shortcut for `throw new Error(msg)`.*/\nfunction error(msg) {\n    throw new Error(msg);\n}\n/** Convert `<`, `>`, `&`, `\"`, `'`, and `/` to the equivalent entities. */\nfunction escapeHtml(s) {\n    return (\"\" + s).replace(REX_HTML, function (s) {\n        return ENTITY_MAP[s];\n    });\n}\n// export function escapeRegExp(s: string) {\n//   return s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"); // $& means the whole matched string\n// }\n/**Convert a regular expression string by escaping special characters (e.g. `\"$\"` -> `\"\\$\"`) */\nfunction escapeRegex(s) {\n    return (\"\" + s).replace(/([.?*+^$[\\]\\\\(){}|-])/g, \"\\\\$1\");\n}\n/** Convert `<`, `>`, `\"`, `'`, and `/` (but not `&`) to the equivalent entities. */\nfunction escapeTooltip(s) {\n    return (\"\" + s).replace(REX_TOOLTIP, function (s) {\n        return ENTITY_MAP[s];\n    });\n}\n/** TODO */\nfunction extractHtmlText(s) {\n    if (s.indexOf(\">\") >= 0) {\n        error(\"Not implemented\");\n        // return $(\"<div/>\").html(s).text();\n    }\n    return s;\n}\n/**\n * Read the value from an HTML input element.\n *\n * If a `<span class=\"wb-col\">` is passed, the first child input is used.\n * Depending on the target element type, `value` is interpreted accordingly.\n * For example for a checkbox, a value of true, false, or null is returned if\n * the element is checked, unchecked, or indeterminate.\n * For datetime input control a numerical value is assumed, etc.\n *\n * Common use case: store the new user input in a `change` event handler:\n *\n * ```ts\n *   change: (e) => {\n *     const tree = e.tree;\n *     const node = e.node;\n *     // Read the value from the input control that triggered the change event:\n *     let value = tree.getValueFromElem(e.element);\n *     // and store it to the node model (assuming the column id matches the property name)\n *     node.data[e.info.colId] = value;\n *   },\n * ```\n * @param elem `<input>` or `<select>` element. Also a parent `span.wb-col` is accepted.\n * @param coerce pass true to convert date/time inputs to `Date`.\n * @returns the value\n */\nfunction getValueFromElem(elem, coerce = false) {\n    const tag = elem.tagName;\n    let value = null;\n    if (tag === \"SPAN\" && elem.classList.contains(\"wb-col\")) {\n        const span = elem;\n        const embeddedInput = span.querySelector(\"input,select\");\n        if (embeddedInput) {\n            return getValueFromElem(embeddedInput, coerce);\n        }\n        span.innerText = \"\" + value;\n    }\n    else if (tag === \"INPUT\") {\n        const input = elem;\n        const type = input.type;\n        switch (type) {\n            case \"button\":\n            case \"reset\":\n            case \"submit\":\n            case \"image\":\n                break;\n            case \"checkbox\":\n                value = input.indeterminate ? null : input.checked;\n                break;\n            case \"date\":\n            case \"datetime\":\n            case \"datetime-local\":\n            case \"month\":\n            case \"time\":\n            case \"week\":\n                value = coerce ? input.valueAsDate : input.value;\n                break;\n            case \"number\":\n            case \"range\":\n                value = input.valueAsNumber;\n                break;\n            case \"radio\":\n                const name = input.name;\n                const checked = input.parentElement.querySelector(`input[name=\"${name}\"]:checked`);\n                value = checked ? checked.value : undefined;\n                break;\n            case \"text\":\n            default:\n                value = input.value;\n        }\n    }\n    else if (tag === \"SELECT\") {\n        const select = elem;\n        value = select.value;\n    }\n    return value;\n}\n/**\n * Set the value of an HTML input element.\n *\n * If a `<span class=\"wb-col\">` is passed, the first child input is used.\n * Depending on the target element type, `value` is interpreted accordingly.\n * For example a checkbox is set to checked, unchecked, or indeterminate if the\n * value is truethy, falsy, or `null`.\n * For datetime input control a numerical value is assumed, etc.\n *\n * Common use case: update embedded input controls in a `render` event handler:\n *\n * ```ts\n *   render: (e) => {\n *     // e.node.log(e.type, e, e.node.data);\n *\n *     for (const col of Object.values(e.renderColInfosById)) {\n *       switch (col.id) {\n *         default:\n *           // Assumption: we named column.id === node.data.NAME\n *           util.setValueToElem(col.elem, e.node.data[col.id]);\n *           break;\n *       }\n *     }\n *   },\n * ```\n *\n * @param elem `<input>` or `<select>` element Also a parent `span.wb-col` is accepted.\n * @param value a value that matches the target element.\n */\nfunction setValueToElem(elem, value) {\n    const tag = elem.tagName;\n    if (tag === \"SPAN\" && elem.classList.contains(\"wb-col\")) {\n        const span = elem;\n        const embeddedInput = span.querySelector(\"input,select\");\n        if (embeddedInput) {\n            return setValueToElem(embeddedInput, value);\n        }\n        // No embedded input: simply write as escaped html\n        span.innerText = \"\" + value;\n    }\n    else if (tag === \"INPUT\") {\n        const input = elem;\n        const type = input.type;\n        switch (type) {\n            case \"checkbox\":\n                // An explicit `null` value is interpreted as 'indeterminate'.\n                // `undefined` is interpreted as 'unchecked'\n                input.indeterminate = value === null;\n                input.checked = !!value;\n                break;\n            case \"date\":\n            case \"month\":\n            case \"time\":\n            case \"week\":\n            case \"datetime\":\n            case \"datetime-local\":\n                input.valueAsDate = new Date(value);\n                break;\n            case \"number\":\n            case \"range\":\n                if (value == null) {\n                    input.value = value;\n                }\n                else {\n                    input.valueAsNumber = value;\n                }\n                break;\n            case \"radio\":\n                error(`Not yet implemented: ${type}`);\n                // const name = input.name;\n                // const checked = input.parentElement!.querySelector(\n                //   `input[name=\"${name}\"]:checked`\n                // );\n                // value = checked ? (<HTMLInputElement>checked).value : undefined;\n                break;\n            case \"button\":\n            case \"reset\":\n            case \"submit\":\n            case \"image\":\n                break;\n            case \"text\":\n            default:\n                input.value = value !== null && value !== void 0 ? value : \"\";\n        }\n    }\n    else if (tag === \"SELECT\") {\n        const select = elem;\n        if (value == null) {\n            select.selectedIndex = -1;\n        }\n        else {\n            select.value = value;\n        }\n    }\n}\n/** Show/hide element by setting the `display` style to 'none'. */\nfunction setElemDisplay(elem, flag) {\n    const style = elemFromSelector(elem).style;\n    if (flag) {\n        if (style.display === \"none\") {\n            style.display = \"\";\n        }\n    }\n    else if (style.display === \"\") {\n        style.display = \"none\";\n    }\n}\n/** Create and return an unconnected `HTMLElement` from a HTML string. */\nfunction elemFromHtml(html) {\n    const t = document.createElement(\"template\");\n    t.innerHTML = html.trim();\n    return t.content.firstElementChild;\n}\nconst _IGNORE_KEYS = new Set([\"Alt\", \"Control\", \"Meta\", \"Shift\"]);\n/** Return a HtmlElement from selector or cast an existing element. */\nfunction elemFromSelector(obj) {\n    if (!obj) {\n        return null; //(null as unknown) as HTMLElement;\n    }\n    if (typeof obj === \"string\") {\n        return document.querySelector(obj);\n    }\n    return obj;\n}\n/** Return a EventTarget from selector or cast an existing element. */\nfunction eventTargetFromSelector(obj) {\n    if (!obj) {\n        return null;\n    }\n    if (typeof obj === \"string\") {\n        return document.querySelector(obj);\n    }\n    return obj;\n}\n/**\n * Return a canonical descriptive string for a keyboard or mouse event.\n *\n * The result also contains a prefix for modifiers if any, for example\n * `\"x\"`, `\"F2\"`, `\"Control+Home\"`, or `\"Shift+clickright\"`.\n * This is especially useful in `switch` statements, to make sure that modifier\n * keys are considered and handled correctly:\n * ```ts\n *   const eventName = util.eventToString(e);\n *   switch (eventName) {\n *     case \"+\":\n *     case \"Add\":\n *       ...\n *       break;\n *     case \"Enter\":\n *     case \"End\":\n *     case \"Control+End\":\n *     case \"Meta+ArrowDown\":\n *     case \"PageDown\":\n *       ...\n *       break;\n *   }\n * ```\n */\nfunction eventToString(event) {\n    let key = event.key, et = event.type, s = [];\n    if (event.altKey) {\n        s.push(\"Alt\");\n    }\n    if (event.ctrlKey) {\n        s.push(\"Control\");\n    }\n    if (event.metaKey) {\n        s.push(\"Meta\");\n    }\n    if (event.shiftKey) {\n        s.push(\"Shift\");\n    }\n    if (et === \"click\" || et === \"dblclick\") {\n        s.push(MOUSE_BUTTONS[event.button] + et);\n    }\n    else if (et === \"wheel\") {\n        s.push(et);\n        // } else if (!IGNORE_KEYCODES[key]) {\n        //   s.push(\n        //     SPECIAL_KEYCODES[key] ||\n        //     String.fromCharCode(key).toLowerCase()\n        //   );\n    }\n    else if (!_IGNORE_KEYS.has(key)) {\n        s.push(key);\n    }\n    return s.join(\"+\");\n}\n/**\n * Copy allproperties from one or more source objects to a target object.\n *\n * @returns the modified target object.\n */\n// TODO: use Object.assign()? --> https://stackoverflow.com/a/42740894\n// TODO: support deep merge --> https://stackoverflow.com/a/42740894\nfunction extend(...args) {\n    for (let i = 1; i < args.length; i++) {\n        let arg = args[i];\n        if (arg == null) {\n            continue;\n        }\n        for (let key in arg) {\n            if (Object.prototype.hasOwnProperty.call(arg, key)) {\n                args[0][key] = arg[key];\n            }\n        }\n    }\n    return args[0];\n}\n/** Return true if `obj` is of type `array`. */\nfunction isArray(obj) {\n    return Array.isArray(obj);\n}\n/** Return true if `obj` is of type `Object` and has no propertied. */\nfunction isEmptyObject(obj) {\n    return Object.keys(obj).length === 0 && obj.constructor === Object;\n}\n/** Return true if `obj` is of type `function`. */\nfunction isFunction(obj) {\n    return typeof obj === \"function\";\n}\n/** Return true if `obj` is of type `Object`. */\nfunction isPlainObject(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Object]\";\n}\n/** A dummy function that does nothing ('no operation'). */\nfunction noop(...args) { }\nfunction onEvent(rootTarget, eventNames, selectorOrHandler, handlerOrNone) {\n    let selector, handler;\n    rootTarget = eventTargetFromSelector(rootTarget);\n    if (handlerOrNone) {\n        selector = selectorOrHandler;\n        handler = handlerOrNone;\n    }\n    else {\n        selector = \"\";\n        handler = selectorOrHandler;\n    }\n    eventNames.split(\" \").forEach((evn) => {\n        rootTarget.addEventListener(evn, function (e) {\n            // console.log(evn, selector, e)\n            if (!selector) {\n                return handler(e); // no event delegation\n            }\n            else if (e.target) {\n                let elem = e.target;\n                if (elem.matches(selector)) {\n                    return handler(e);\n                }\n                elem = elem.closest(selector);\n                if (elem) {\n                    return handler(e);\n                }\n            }\n        });\n    });\n}\n/** Return a wrapped handler method, that provides `this._super` and `this._superApply`.\n *\n * ```ts\n  // Implement `opts.createNode` event to add the 'draggable' attribute\n  overrideMethod(ctx.options, \"createNode\", (event, data) => {\n    // Default processing if any\n    this._super.apply(this, event, data);\n    // Add 'draggable' attribute\n    data.node.span.draggable = true;\n  });\n  ```\n  */\nfunction overrideMethod(instance, methodName, handler, ctx) {\n    let prevSuper, prevSuperApply, self = ctx || instance, prevFunc = instance[methodName], _super = (...args) => {\n        return prevFunc.apply(self, args);\n    }, _superApply = (argsArray) => {\n        return prevFunc.apply(self, argsArray);\n    };\n    let wrapper = (...args) => {\n        try {\n            prevSuper = self._super;\n            prevSuperApply = self._superApply;\n            self._super = _super;\n            self._superApply = _superApply;\n            return handler.apply(self, args);\n        }\n        finally {\n            self._super = prevSuper;\n            self._superApply = prevSuperApply;\n        }\n    };\n    instance[methodName] = wrapper;\n}\n/** Run function after ms milliseconds and return a promise that resolves when done. */\nfunction setTimeoutPromise(callback, ms) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            try {\n                resolve(callback.apply(this));\n            }\n            catch (err) {\n                reject(err);\n            }\n        }, ms);\n    });\n}\n/**\n * Wait `ms` microseconds.\n *\n * Example:\n * ```js\n * await sleep(1000);\n * ```\n * @param ms duration\n * @returns\n */\nasync function sleep(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n}\n/**\n * Set or rotate checkbox status with support for tri-state.\n *\n * An initial 'indeterminate' state becomes 'checked' on the first call.\n *\n * If the input element has the class 'wb-tristate' assigned, the sequence is:<br>\n * 'indeterminate' -> 'checked' -> 'unchecked' -> 'indeterminate' -> ...<br>\n * Otherwise we toggle like <br>\n * 'checked' -> 'unchecked' -> 'checked' -> ...\n */\nfunction toggleCheckbox(element, value, tristate) {\n    const input = elemFromSelector(element);\n    assert(input.type === \"checkbox\");\n    tristate !== null && tristate !== void 0 ? tristate : (tristate = input.classList.contains(\"wb-tristate\") || input.indeterminate);\n    if (value === undefined) {\n        const curValue = input.indeterminate ? null : input.checked;\n        switch (curValue) {\n            case true:\n                value = false;\n                break;\n            case false:\n                value = tristate ? null : true;\n                break;\n            case null:\n                value = true;\n                break;\n        }\n    }\n    input.indeterminate = value == null;\n    input.checked = !!value;\n}\n/**\n * Return `opts.NAME` if opts is valid and\n *\n * @param opts dict, object, or null\n * @param name option name (use dot notation to access extension option, e.g. `filter.mode`)\n * @param defaultValue returned when `opts` is not an object, or does not have a NAME property\n */\nfunction getOption(opts, name, defaultValue = undefined) {\n    let ext;\n    // Lookup `name` in options dict\n    if (opts && name.indexOf(\".\") >= 0) {\n        [ext, name] = name.split(\".\");\n        opts = opts[ext];\n    }\n    let value = opts ? opts[name] : null;\n    // Use value from value options dict, fallback do default\n    return value !== null && value !== void 0 ? value : defaultValue;\n}\n/** Convert an Array or space-separated string to a Set. */\nfunction toSet(val) {\n    if (val instanceof Set) {\n        return val;\n    }\n    if (typeof val === \"string\") {\n        let set = new Set();\n        for (const c of val.split(\" \")) {\n            set.add(c.trim());\n        }\n        return set;\n    }\n    if (Array.isArray(val)) {\n        return new Set(val);\n    }\n    throw new Error(\"Cannot convert to Set<string>: \" + val);\n}\n// /** Check if a string is contained in an Array or Set. */\n// export function isAnyOf(s: string, items: Array<string>|Set<string>): boolean {\n//   return Array.prototype.includes.call(items, s)\n// }\n// /** Check if an Array or Set has at least one matching entry. */\n// export function hasAnyOf(container: Array<string>|Set<string>, items: Array<string>): boolean {\n//   if (Array.isArray(container)) {\n//     return container.some(v => )\n//   }\n//   return container.some(v => {})\n//   // const container = toSet(items);\n//   // const itemSet = toSet(items);\n//   // Array.prototype.includes\n//   // throw new Error(\"Cannot convert to Set<string>: \" + val);\n// }\n/** Return a canonical string representation for an object's type (e.g. 'array', 'number', ...). */\nfunction type(obj) {\n    return Object.prototype.toString\n        .call(obj)\n        .replace(/^\\[object (.+)\\]$/, \"$1\")\n        .toLowerCase();\n}\n/**\n * Return a function that can be called instead of `callback`, but guarantees\n * a limited execution rate.\n * The execution rate is calculated based on the runtime duration of the\n * previous call.\n * Example:\n * ```js\n * throttledFoo = util.adaptiveThrottle(foo.bind(this), {});\n * throttledFoo();\n * throttledFoo();\n * ```\n */\nfunction adaptiveThrottle(callback, options) {\n    let waiting = 0; // Initially, we're not waiting\n    let pendingArgs = null;\n    const opts = Object.assign({\n        minDelay: 16,\n        defaultDelay: 200,\n        maxDelay: 5000,\n        delayFactor: 2.0,\n    }, options);\n    const minDelay = Math.max(16, +opts.minDelay);\n    const maxDelay = +opts.maxDelay;\n    const throttledFn = (...args) => {\n        if (waiting) {\n            pendingArgs = args;\n            // console.log(`adaptiveThrottle() queing request #${waiting}...`, args);\n            waiting += 1;\n        }\n        else {\n            // Prevent invocations while running or blocking\n            waiting = 1;\n            const useArgs = args; // pendingArgs || args;\n            pendingArgs = null;\n            // console.log(`adaptiveThrottle() execute...`, useArgs);\n            const start = Date.now();\n            try {\n                callback.apply(this, useArgs);\n            }\n            catch (error) {\n                console.error(error);\n            }\n            const elap = Date.now() - start;\n            const curDelay = Math.min(Math.max(minDelay, elap * opts.delayFactor), maxDelay);\n            const useDelay = Math.max(minDelay, curDelay - elap);\n            // console.log(\n            //   `adaptiveThrottle() calling worker took ${elap}ms. delay = ${curDelay}ms, using ${useDelay}ms`,\n            //   pendingArgs\n            // );\n            setTimeout(() => {\n                // Unblock, and trigger pending requests if any\n                // const skipped = waiting - 1;\n                waiting = 0; // And allow future invocations\n                if (pendingArgs != null) {\n                    // There was another request while running or waiting\n                    // console.log(\n                    //   `adaptiveThrottle() re-trigger (missed ${skipped})...`,\n                    //   pendingArgs\n                    // );\n                    throttledFn.apply(this, pendingArgs);\n                }\n            }, useDelay);\n        }\n    };\n    return throttledFn;\n}\n\nvar util = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Deferred: Deferred$1,\n  MAX_INT: MAX_INT,\n  MOUSE_BUTTONS: MOUSE_BUTTONS,\n  adaptiveThrottle: adaptiveThrottle,\n  assert: assert,\n  documentReady: documentReady,\n  documentReadyPromise: documentReadyPromise,\n  each: each,\n  elemFromHtml: elemFromHtml,\n  elemFromSelector: elemFromSelector,\n  error: error,\n  escapeHtml: escapeHtml,\n  escapeRegex: escapeRegex,\n  escapeTooltip: escapeTooltip,\n  eventTargetFromSelector: eventTargetFromSelector,\n  eventToString: eventToString,\n  extend: extend,\n  extractHtmlText: extractHtmlText,\n  getOption: getOption,\n  getValueFromElem: getValueFromElem,\n  isArray: isArray,\n  isEmptyObject: isEmptyObject,\n  isFunction: isFunction,\n  isMac: isMac,\n  isPlainObject: isPlainObject,\n  noop: noop,\n  onEvent: onEvent,\n  overrideMethod: overrideMethod,\n  setElemDisplay: setElemDisplay,\n  setTimeoutPromise: setTimeoutPromise,\n  setValueToElem: setValueToElem,\n  sleep: sleep,\n  toSet: toSet,\n  toggleCheckbox: toggleCheckbox,\n  type: type\n});\n\n/*!\n * Wunderbaum - types\n * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.\n * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)\n */\n/**\n * Possible values for {@link WunderbaumNode.setModified()} and {@link Wunderbaum.setModified()}.\n */\nvar ChangeType;\n(function (ChangeType) {\n    /** Re-render the whole viewport, headers, and all rows. */\n    ChangeType[\"any\"] = \"any\";\n    /** A node's title, icon, columns, or status have changed. Update the existing row markup. */\n    ChangeType[\"data\"] = \"data\";\n    /** The `tree.columns` definition has changed beyond simple width adjustments. */\n    ChangeType[\"colStructure\"] = \"colStructure\";\n    /** The viewport/window was resized. Adjust layout attributes for all elements. */\n    ChangeType[\"resize\"] = \"resize\";\n    /** A node's definition has changed beyond status and data. Re-render the whole row's markup. */\n    ChangeType[\"row\"] = \"row\";\n    /** Nodes have been added, removed, etc. Update markup. */\n    ChangeType[\"structure\"] = \"structure\";\n    /** A node's status has changed. Update current row's classes, to reflect active, selected, ... */\n    ChangeType[\"status\"] = \"status\";\n    /** Vertical scroll event. Update the 'top' property of all rows. */\n    ChangeType[\"scroll\"] = \"scroll\";\n})(ChangeType || (ChangeType = {}));\n/* Internal use. */\nvar RenderFlag;\n(function (RenderFlag) {\n    RenderFlag[\"clearMarkup\"] = \"clearMarkup\";\n    RenderFlag[\"header\"] = \"header\";\n    RenderFlag[\"redraw\"] = \"redraw\";\n    RenderFlag[\"scroll\"] = \"scroll\";\n})(RenderFlag || (RenderFlag = {}));\n/** Possible values for {@link WunderbaumNode.setStatus()}. */\nvar NodeStatusType;\n(function (NodeStatusType) {\n    NodeStatusType[\"ok\"] = \"ok\";\n    NodeStatusType[\"loading\"] = \"loading\";\n    NodeStatusType[\"error\"] = \"error\";\n    NodeStatusType[\"noData\"] = \"noData\";\n    // paging = \"paging\",\n})(NodeStatusType || (NodeStatusType = {}));\n/** Define the subregion of a node, where an event occurred. */\nvar NodeRegion;\n(function (NodeRegion) {\n    NodeRegion[\"unknown\"] = \"\";\n    NodeRegion[\"checkbox\"] = \"checkbox\";\n    NodeRegion[\"column\"] = \"column\";\n    NodeRegion[\"expander\"] = \"expander\";\n    NodeRegion[\"icon\"] = \"icon\";\n    NodeRegion[\"prefix\"] = \"prefix\";\n    NodeRegion[\"title\"] = \"title\";\n})(NodeRegion || (NodeRegion = {}));\n/** Initial navigation mode and possible transition. */\nvar NavModeEnum;\n(function (NavModeEnum) {\n    NavModeEnum[\"startRow\"] = \"startRow\";\n    NavModeEnum[\"cell\"] = \"cell\";\n    NavModeEnum[\"startCell\"] = \"startCell\";\n    NavModeEnum[\"row\"] = \"row\";\n})(NavModeEnum || (NavModeEnum = {}));\n\n/*!\n * Wunderbaum - wb_extension_base\n * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.\n * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)\n */\nclass WunderbaumExtension {\n    constructor(tree, id, defaults) {\n        this.enabled = true;\n        this.tree = tree;\n        this.id = id;\n        this.treeOpts = tree.options;\n        const opts = tree.options;\n        if (this.treeOpts[id] === undefined) {\n            opts[id] = this.extensionOpts = extend({}, defaults);\n        }\n        else {\n            // TODO: do we break existing object instance references here?\n            this.extensionOpts = extend({}, defaults, opts[id]);\n            opts[id] = this.extensionOpts;\n        }\n        this.enabled = this.getPluginOption(\"enabled\", true);\n    }\n    /** Called on tree (re)init after all extensions are added, but before loading.*/\n    init() {\n        this.tree.element.classList.add(\"wb-ext-\" + this.id);\n    }\n    // protected callEvent(type: string, extra?: any): any {\n    //   let func = this.extensionOpts[type];\n    //   if (func) {\n    //     return func.call(\n    //       this.tree,\n    //       util.extend(\n    //         {\n    //           event: this.id + \".\" + type,\n    //         },\n    //         extra\n    //       )\n    //     );\n    //   }\n    // }\n    getPluginOption(name, defaultValue) {\n        var _a;\n        return (_a = this.extensionOpts[name]) !== null && _a !== void 0 ? _a : defaultValue;\n    }\n    setPluginOption(name, value) {\n        this.extensionOpts[name] = value;\n    }\n    setEnabled(flag = true) {\n        return this.setPluginOption(\"enabled\", !!flag);\n        // this.enabled = !!flag;\n    }\n    onKeyEvent(data) {\n        return;\n    }\n    onRender(data) {\n        return;\n    }\n}\n\n/*!\n * debounce & throttle, taken from https://github.com/lodash/lodash v4.17.21\n * MIT License: https://raw.githubusercontent.com/lodash/lodash/4.17.21-npm/LICENSE\n * Modified for TypeScript type annotations.\n */\n/* --- */\n/** Detect free variable `global` from Node.js. */\nconst freeGlobal = typeof global === \"object\" &&\n    global !== null &&\n    global.Object === Object &&\n    global;\n/** Detect free variable `globalThis` */\nconst freeGlobalThis = typeof globalThis === \"object\" &&\n    globalThis !== null &&\n    globalThis.Object == Object &&\n    globalThis;\n/** Detect free variable `self`. */\nconst freeSelf = typeof self === \"object\" && self !== null && self.Object === Object && self;\n/** Used as a reference to the global object. */\nconst root = freeGlobalThis || freeGlobal || freeSelf || Function(\"return this\")();\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * isObject({})\n * // => true\n *\n * isObject([1, 2, 3])\n * // => true\n *\n * isObject(Function)\n * // => true\n *\n * isObject(null)\n * // => false\n */\nfunction isObject(value) {\n    const type = typeof value;\n    return value != null && (type === \"object\" || type === \"function\");\n}\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked, or until the next browser frame is drawn. The debounced function\n * comes with a `cancel` method to cancel delayed `func` invocations and a\n * `flush` method to immediately invoke them. Provide `options` to indicate\n * whether `func` should be invoked on the leading and/or trailing edge of the\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\n * debounced function. Subsequent calls to the debounced function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `debounce` and `throttle`.\n *\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0]\n *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is\n *  used (if available).\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', debounce(calculateLayout, 150))\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }))\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * const debounced = debounce(batchLog, 250, { 'maxWait': 1000 })\n * const source = new EventSource('/stream')\n * jQuery(source).on('message', debounced)\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel)\n *\n * // Check for pending invocations.\n * const status = debounced.pending() ? \"Pending...\" : \"Ready\"\n */\nfunction debounce(func, wait = 0, options = {}) {\n    let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;\n    let lastInvokeTime = 0;\n    let leading = false;\n    let maxing = false;\n    let trailing = true;\n    // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n    const useRAF = !wait && wait !== 0 && typeof root.requestAnimationFrame === \"function\";\n    if (typeof func !== \"function\") {\n        throw new TypeError(\"Expected a function\");\n    }\n    wait = +wait || 0;\n    if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = \"maxWait\" in options;\n        maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait;\n        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n    }\n    function invokeFunc(time) {\n        const args = lastArgs;\n        const thisArg = lastThis;\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n    }\n    function startTimer(pendingFunc, wait) {\n        if (useRAF) {\n            root.cancelAnimationFrame(timerId);\n            return root.requestAnimationFrame(pendingFunc);\n        }\n        return setTimeout(pendingFunc, wait);\n    }\n    function cancelTimer(id) {\n        if (useRAF) {\n            return root.cancelAnimationFrame(id);\n        }\n        clearTimeout(id);\n    }\n    function leadingEdge(time) {\n        // Reset any `maxWait` timer.\n        lastInvokeTime = time;\n        // Start the timer for the trailing edge.\n        timerId = startTimer(timerExpired, wait);\n        // Invoke the leading edge.\n        return leading ? invokeFunc(time) : result;\n    }\n    function remainingWait(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n        const timeWaiting = wait - timeSinceLastCall;\n        return maxing\n            ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n            : timeWaiting;\n    }\n    function shouldInvoke(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n        // Either this is the first call, activity has stopped and we're at the\n        // trailing edge, the system time has gone backwards and we're treating\n        // it as the trailing edge, or we've hit the `maxWait` limit.\n        return (lastCallTime === undefined ||\n            timeSinceLastCall >= wait ||\n            timeSinceLastCall < 0 ||\n            (maxing && timeSinceLastInvoke >= maxWait));\n    }\n    function timerExpired() {\n        const time = Date.now();\n        if (shouldInvoke(time)) {\n            return trailingEdge(time);\n        }\n        // Restart the timer.\n        timerId = startTimer(timerExpired, remainingWait(time));\n    }\n    function trailingEdge(time) {\n        timerId = undefined;\n        // Only invoke if we have `lastArgs` which means `func` has been\n        // debounced at least once.\n        if (trailing && lastArgs) {\n            return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n    }\n    function cancel() {\n        if (timerId !== undefined) {\n            cancelTimer(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n    }\n    function flush() {\n        return timerId === undefined ? result : trailingEdge(Date.now());\n    }\n    function pending() {\n        return timerId !== undefined;\n    }\n    function debounced(...args) {\n        const time = Date.now();\n        const isInvoking = shouldInvoke(time);\n        lastArgs = args;\n        lastThis = this;\n        lastCallTime = time;\n        if (isInvoking) {\n            if (timerId === undefined) {\n                return leadingEdge(lastCallTime);\n            }\n            if (maxing) {\n                // Handle invocations in a tight loop.\n                timerId = startTimer(timerExpired, wait);\n                return invokeFunc(lastCallTime);\n            }\n        }\n        if (timerId === undefined) {\n            timerId = startTimer(timerExpired, wait);\n        }\n        return result;\n    }\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    debounced.pending = pending;\n    return debounced;\n}\n\n/*!\n * Wunderbaum - ext-filter\n * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.\n * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)\n */\nconst START_MARKER = \"\\uFFF7\";\nconst END_MARKER = \"\\uFFF8\";\nconst RE_START_MARKER = new RegExp(escapeRegex(START_MARKER), \"g\");\nconst RE_END_MARTKER = new RegExp(escapeRegex(END_MARKER), \"g\");\nclass FilterExtension extends WunderbaumExtension {\n    constructor(tree) {\n        super(tree, \"filter\", {\n            connectInput: null,\n            autoApply: true,\n            autoExpand: false,\n            counter: true,\n            fuzzy: false,\n            hideExpandedCounter: true,\n            hideExpanders: false,\n            highlight: true,\n            leavesOnly: false,\n            mode: \"dim\",\n            noData: true, // Display a 'no data' status node if result is empty\n        });\n        this.lastFilterArgs = null;\n    }\n    init() {\n        super.init();\n        const connectInput = this.getPluginOption(\"connectInput\");\n        if (connectInput) {\n            this.queryInput = elemFromSelector(connectInput);\n            onEvent(this.queryInput, \"input\", debounce((e) => {\n                // this.tree.log(\"query\", e);\n                this.filterNodes(this.queryInput.value.trim(), {});\n            }, 700));\n        }\n    }\n    setPluginOption(name, value) {\n        // alert(\"filter opt=\" + name + \", \" + value)\n        super.setPluginOption(name, value);\n        switch (name) {\n            case \"mode\":\n                this.tree.filterMode = value === \"hide\" ? \"hide\" : \"dim\";\n                this.tree.updateFilter();\n                break;\n        }\n    }\n    _applyFilterNoUpdate(filter, branchMode, _opts) {\n        return this.tree.runWithoutUpdate(() => {\n            return this._applyFilterImpl(filter, branchMode, _opts);\n        });\n    }\n    _applyFilterImpl(filter, branchMode, _opts) {\n        let match, temp, start = Date.now(), count = 0, tree = this.tree, treeOpts = tree.options,\n        // escapeTitles = treeOpts.escapeTitles,\n        prevAutoCollapse = treeOpts.autoCollapse, opts = extend({}, treeOpts.filter, _opts), hideMode = opts.mode === \"hide\", leavesOnly = !!opts.leavesOnly && !branchMode;\n        // Default to 'match title substring (case insensitive)'\n        if (typeof filter === \"string\") {\n            if (filter === \"\") {\n                tree.logInfo(\"Passing an empty string as a filter is handled as clearFilter().\");\n                this.clearFilter();\n                return;\n            }\n            if (opts.fuzzy) {\n                // See https://codereview.stackexchange.com/questions/23899/faster-javascript-fuzzy-string-matching-function/23905#23905\n                // and http://www.quora.com/How-is-the-fuzzy-search-algorithm-in-Sublime-Text-designed\n                // and http://www.dustindiaz.com/autocomplete-fuzzy-matching\n                match = filter\n                    .split(\"\")\n                    // Escaping the `filter` will not work because,\n                    // it gets further split into individual characters. So,\n                    // escape each character after splitting\n                    .map(escapeRegex)\n                    .reduce(function (a, b) {\n                    // create capture groups for parts that comes before\n                    // the character\n                    return a + \"([^\" + b + \"]*)\" + b;\n                }, \"\");\n            }\n            else {\n                match = escapeRegex(filter); // make sure a '.' is treated literally\n            }\n            let re = new RegExp(match, \"i\");\n            let reHighlight = new RegExp(escapeRegex(filter), \"gi\");\n            filter = (node) => {\n                if (!node.title) {\n                    return false;\n                }\n                // let text = escapeTitles ? node.title : extractHtmlText(node.title);\n                let text = node.title;\n                // `.match` instead of `.test` to get the capture groups\n                let res = text.match(re);\n                if (res && opts.highlight) {\n                    // if (escapeTitles) {\n                    if (opts.fuzzy) {\n                        temp = _markFuzzyMatchedChars(text, res, true);\n                    }\n                    else {\n                        // #740: we must not apply the marks to escaped entity names, e.g. `&quot;`\n                        // Use some exotic characters to mark matches:\n                        temp = text.replace(reHighlight, function (s) {\n                            return START_MARKER + s + END_MARKER;\n                        });\n                    }\n                    // now we can escape the title...\n                    node.titleWithHighlight = escapeHtml(temp)\n                        // ... and finally insert the desired `<mark>` tags\n                        .replace(RE_START_MARKER, \"<mark>\")\n                        .replace(RE_END_MARTKER, \"</mark>\");\n                    // } else {\n                    //   if (opts.fuzzy) {\n                    //     node.titleWithHighlight = _markFuzzyMatchedChars(text, res);\n                    //   } else {\n                    //     node.titleWithHighlight = text.replace(reHighlight, function (s) {\n                    //       return \"<mark>\" + s + \"</mark>\";\n                    //     });\n                    //   }\n                    // }\n                    // node.debug(\"filter\", escapeTitles, text, node.titleWithHighlight);\n                }\n                return !!res;\n            };\n        }\n        tree.filterMode = opts.mode;\n        this.lastFilterArgs = arguments;\n        tree.element.classList.toggle(\"wb-ext-filter-hide\", !!hideMode);\n        tree.element.classList.toggle(\"wb-ext-filter-dim\", !hideMode);\n        tree.element.classList.toggle(\"wb-ext-filter-hide-expanders\", !!opts.hideExpanders);\n        // Reset current filter\n        tree.root.subMatchCount = 0;\n        tree.visit((node) => {\n            delete node.match;\n            delete node.titleWithHighlight;\n            node.subMatchCount = 0;\n        });\n        // statusNode = tree.root.findDirectChild(KEY_NODATA);\n        // if (statusNode) {\n        //   statusNode.remove();\n        // }\n        tree.setStatus(NodeStatusType.ok);\n        // Adjust node.hide, .match, and .subMatchCount properties\n        treeOpts.autoCollapse = false; // #528\n        tree.visit((node) => {\n            if (leavesOnly && node.children != null) {\n                return;\n            }\n            let res = filter(node);\n            if (res === \"skip\") {\n                node.visit(function (c) {\n                    c.match = false;\n                }, true);\n                return \"skip\";\n            }\n            let matchedByBranch = false;\n            if ((branchMode || res === \"branch\") && node.parent.match) {\n                res = true;\n                matchedByBranch = true;\n            }\n            if (res) {\n                count++;\n                node.match = true;\n                node.visitParents((p) => {\n                    if (p !== node) {\n                        p.subMatchCount += 1;\n                    }\n                    // Expand match (unless this is no real match, but only a node in a matched branch)\n                    if (opts.autoExpand && !matchedByBranch && !p.expanded) {\n                        p.setExpanded(true, {\n                            noAnimation: true,\n                            noEvents: true,\n                            scrollIntoView: false,\n                        });\n                        p._filterAutoExpanded = true;\n                    }\n                }, true);\n            }\n        });\n        treeOpts.autoCollapse = prevAutoCollapse;\n        if (count === 0 && opts.noData && hideMode) {\n            tree.root.setStatus(NodeStatusType.noData);\n        }\n        // Redraw whole tree\n        tree.logInfo(`Filter '${match}' found ${count} nodes in ${Date.now() - start} ms.`);\n        return count;\n    }\n    /**\n     * [ext-filter] Dim or hide nodes.\n     */\n    filterNodes(filter, options) {\n        return this._applyFilterNoUpdate(filter, false, options);\n    }\n    /**\n     * [ext-filter] Dim or hide whole branches.\n     */\n    filterBranches(filter, options) {\n        return this._applyFilterNoUpdate(filter, true, options);\n    }\n    /**\n     * [ext-filter] Re-apply current filter.\n     */\n    updateFilter() {\n        let tree = this.tree;\n        if (tree.filterMode &&\n            this.lastFilterArgs &&\n            tree.options.filter.autoApply) {\n            this._applyFilterNoUpdate.apply(this, this.lastFilterArgs);\n        }\n        else {\n            tree.logWarn(\"updateFilter(): no filter active.\");\n        }\n    }\n    /**\n     * [ext-filter] Reset the filter.\n     */\n    clearFilter() {\n        let tree = this.tree;\n        // statusNode = tree.root.findDirectChild(KEY_NODATA),\n        // escapeTitles = tree.options.escapeTitles;\n        // enhanceTitle = tree.options.enhanceTitle,\n        tree.enableUpdate(false);\n        // if (statusNode) {\n        //   statusNode.remove();\n        // }\n        tree.setStatus(NodeStatusType.ok);\n        // we also counted root node's subMatchCount\n        delete tree.root.match;\n        delete tree.root.subMatchCount;\n        tree.visit((node) => {\n            if (node.match && node._rowElem) {\n                // #491, #601\n                let titleElem = node._rowElem.querySelector(\"span.wb-title\");\n                // if (escapeTitles) {\n                titleElem.textContent = node.title;\n                // } else {\n                //   titleElem.innerHTML = node.title;\n                // }\n                node._callEvent(\"enhanceTitle\", { titleElem: titleElem });\n            }\n            delete node.match;\n            delete node.subMatchCount;\n            delete node.titleWithHighlight;\n            if (node.subMatchBadge) {\n                node.subMatchBadge.remove();\n                delete node.subMatchBadge;\n            }\n            if (node._filterAutoExpanded && node.expanded) {\n                node.setExpanded(false, {\n                    noAnimation: true,\n                    noEvents: true,\n                    scrollIntoView: false,\n                });\n            }\n            delete node._filterAutoExpanded;\n        });\n        tree.filterMode = null;\n        this.lastFilterArgs = null;\n        tree.element.classList.remove(\n        // \"wb-ext-filter\",\n        \"wb-ext-filter-dim\", \"wb-ext-filter-hide\");\n        // tree._callHook(\"treeStructureChanged\", this, \"clearFilter\");\n        // tree.render();\n        tree.enableUpdate(true);\n    }\n}\n/**\n * @description Marks the matching charecters of `text` either by `mark` or\n * by exotic*Chars (if `escapeTitles` is `true`) based on `matches`\n * which is an array of matching groups.\n * @param {string} text\n * @param {RegExpMatchArray} matches\n */\nfunction _markFuzzyMatchedChars(text, matches, escapeTitles = true) {\n    let matchingIndices = [];\n    // get the indices of matched characters (Iterate through `RegExpMatchArray`)\n    for (let _matchingArrIdx = 1; _matchingArrIdx < matches.length; _matchingArrIdx++) {\n        let _mIdx =\n        // get matching char index by cumulatively adding\n        // the matched group length\n        matches[_matchingArrIdx].length +\n            (_matchingArrIdx === 1 ? 0 : 1) +\n            (matchingIndices[matchingIndices.length - 1] || 0);\n        matchingIndices.push(_mIdx);\n    }\n    // Map each `text` char to its position and store in `textPoses`.\n    let textPoses = text.split(\"\");\n    if (escapeTitles) {\n        // If escaping the title, then wrap the matching char within exotic chars\n        matchingIndices.forEach(function (v) {\n            textPoses[v] = START_MARKER + textPoses[v] + END_MARKER;\n        });\n    }\n    else {\n        // Otherwise, Wrap the matching chars within `mark`.\n        matchingIndices.forEach(function (v) {\n            textPoses[v] = \"<mark>\" + textPoses[v] + \"</mark>\";\n        });\n    }\n    // Join back the modified `textPoses` to create final highlight markup.\n    return textPoses.join(\"\");\n}\n\n/*!\n * Wunderbaum - ext-keynav\n * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.\n * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)\n */\nconst QUICKSEARCH_DELAY = 500;\nclass KeynavExtension extends WunderbaumExtension {\n    constructor(tree) {\n        super(tree, \"keynav\", {});\n    }\n    _getEmbeddedInputElem(elem) {\n        var _a;\n        let input = null;\n        if (elem && elem.type != null) {\n            input = elem;\n        }\n        else {\n            // ,[contenteditable]\n            const ace = (_a = this.tree.getActiveColElem()) === null || _a === void 0 ? void 0 : _a.querySelector(\"input,select\");\n            if (ace) {\n                input = ace;\n            }\n        }\n        return input;\n    }\n    /* Return true if the current cell's embedded input has keyboard focus. */\n    _isCurInputFocused() {\n        var _a;\n        const ace = (_a = this.tree\n            .getActiveColElem()) === null || _a === void 0 ? void 0 : _a.querySelector(\"input:focus,select:focus\");\n        return !!ace;\n    }\n    onKeyEvent(data) {\n        const event = data.event, tree = this.tree, opts = data.options, activate = !event.ctrlKey || opts.autoActivate, curInput = this._getEmbeddedInputElem(event.target), inputHasFocus = curInput && this._isCurInputFocused(), navModeOption = opts.navigationModeOption;\n        // isCellEditMode = tree.navMode === NavigationMode.cellEdit;\n        let focusNode, eventName = eventToString(event), node = data.node, handled = true;\n        // tree.log(`onKeyEvent: ${eventName}, curInput`, curInput);\n        if (!tree.isEnabled()) {\n            // tree.logDebug(`onKeyEvent ignored for disabled tree: ${eventName}`);\n            return false;\n        }\n        // Let callback prevent default processing\n        if (tree._callEvent(\"keydown\", data) === false) {\n            return false;\n        }\n        // Let ext-edit trigger editing\n        if (tree._callMethod(\"edit._preprocessKeyEvent\", data) === false) {\n            return false;\n        }\n        // Set focus to active (or first node) if no other node has the focus yet\n        if (!node) {\n            const currentNode = tree.getFocusNode() || tree.getActiveNode();\n            const firstNode = tree.getFirstChild();\n            if (!currentNode && firstNode && eventName === \"ArrowDown\") {\n                firstNode.logInfo(\"Keydown: activate first node.\");\n                firstNode.setActive();\n                return;\n            }\n            focusNode = currentNode || firstNode;\n            if (focusNode) {\n                focusNode.setFocus();\n                node = tree.getFocusNode();\n                node.logInfo(\"Keydown: force focus on active node.\");\n            }\n        }\n        const isColspan = node.isColspan();\n        if (tree.isRowNav()) {\n            // -----------------------------------------------------------------------\n            // --- Row Mode ---\n            // -----------------------------------------------------------------------\n            if (inputHasFocus) {\n                // If editing an embedded input control, let the control handle all\n                // keys. Only Enter and Escape should apply / discard, but keep the\n                // keyboard focus.\n                switch (eventName) {\n                    case \"Enter\":\n                        curInput.blur();\n                        tree.setFocus();\n                        break;\n                    case \"Escape\":\n                        node.render();\n                        tree.setFocus();\n                        break;\n                }\n                return;\n            }\n            // --- Quick-Search\n            if (opts.quicksearch &&\n                eventName.length === 1 &&\n                /^\\w$/.test(eventName) &&\n                !curInput) {\n                // Allow to search for longer streaks if typed in quickly\n                const stamp = Date.now();\n                if (stamp - tree.lastQuicksearchTime > QUICKSEARCH_DELAY) {\n                    tree.lastQuicksearchTerm = \"\";\n                }\n                tree.lastQuicksearchTime = stamp;\n                tree.lastQuicksearchTerm += eventName;\n                let matchNode = tree.findNextNode(tree.lastQuicksearchTerm, tree.getActiveNode());\n                if (matchNode) {\n                    matchNode.setActive(true, { event: event });\n                }\n                event.preventDefault();\n                return;\n            }\n            // Pre-Evaluate expand/collapse action for LEFT/RIGHT\n            switch (eventName) {\n                case \"Enter\":\n                    if (node.isActive()) {\n                        if (node.isExpanded()) {\n                            eventName = \"Subtract\"; // callapse\n                        }\n                        else if (node.isExpandable(true)) {\n                            eventName = \"Add\"; // expand\n                        }\n                    }\n                    break;\n                case \"ArrowLeft\":\n                    if (node.expanded) {\n                        eventName = \"Subtract\"; // collapse\n                    }\n                    break;\n                case \"ArrowRight\":\n                    if (!node.expanded && node.isExpandable(true)) {\n                        eventName = \"Add\"; // expand\n                    }\n                    else if (navModeOption === NavModeEnum.startCell ||\n                        navModeOption === NavModeEnum.startRow) {\n                        event.preventDefault();\n                        tree.setCellNav();\n                        return false;\n                    }\n                    break;\n            }\n            // Standard navigation (row mode)\n            switch (eventName) {\n                case \"+\":\n                case \"Add\":\n                    // case \"=\": // 187: '+' @ Chrome, Safari\n                    node.setExpanded(true);\n                    break;\n                case \"-\":\n                case \"Subtract\":\n                    node.setExpanded(false);\n                    break;\n                case \" \": // Space\n                    // if (node.isPagingNode()) {\n                    //   tree._triggerNodeEvent(\"clickPaging\", ctx, event);\n                    // } else\n                    if (node.getOption(\"checkbox\")) {\n                        node.setSelected(!node.isSelected());\n                    }\n                    else {\n                        node.setActive(true, { event: event });\n                    }\n                    break;\n                case \"Enter\":\n                    node.setActive(true, { event: event });\n                    break;\n                case \"ArrowDown\":\n                case \"ArrowLeft\":\n                case \"ArrowRight\":\n                case \"ArrowUp\":\n                case \"Backspace\":\n                case \"End\":\n                case \"Home\":\n                case \"Control+End\":\n                case \"Control+Home\":\n                case \"Meta+ArrowDown\":\n                case \"Meta+ArrowUp\":\n                case \"PageDown\":\n                case \"PageUp\":\n                    node.navigate(eventName, { activate: activate, event: event });\n                    break;\n                default:\n                    handled = false;\n            }\n        }\n        else {\n            const curInput = this._getEmbeddedInputElem(null);\n            const curInputType = curInput ? curInput.type || curInput.tagName : \"\";\n            const inputHasFocus = curInput && this._isCurInputFocused();\n            const inputCanFocus = curInput && curInputType !== \"checkbox\";\n            if (inputHasFocus) {\n                if (eventName === \"Escape\") {\n                    // Discard changes\n                    node.render();\n                    // Keep cell-nav mode\n                    node.logDebug(`Reset focused input`);\n                    tree.setFocus();\n                    tree.setColumn(tree.activeColIdx);\n                    return;\n                    // } else if (!INPUT_BREAKOUT_KEYS.has(eventName)) {\n                }\n                else if (eventName !== \"Enter\") {\n                    // Let current `<input>` handle it\n                    node.logDebug(`Ignored ${eventName} inside focused input`);\n                    return;\n                }\n                // const curInputType = curInput.type || curInput.tagName;\n                // const breakoutKeys = INPUT_KEYS[curInputType];\n                // if (!breakoutKeys.includes(eventName)) {\n                //   node.logDebug(`Ignored ${eventName} inside ${curInputType} input`);\n                //   return;\n                // }\n            }\n            else if (curInput) {\n                // On a cell that has an embedded, unfocused <input>\n                if (eventName.length === 1 && inputCanFocus) {\n                    curInput.focus();\n                    curInput.value = \"\";\n                    node.logDebug(`Focus imput: ${eventName}`);\n                    return false;\n                }\n            }\n            if (eventName === \"Tab\") {\n                eventName = \"ArrowRight\";\n                handled = true;\n            }\n            else if (eventName === \"Shift+Tab\") {\n                eventName = tree.activeColIdx > 0 ? \"ArrowLeft\" : \"\";\n                handled = true;\n            }\n            else ;\n            switch (eventName) {\n                case \"+\":\n                case \"Add\":\n                    // case \"=\": // 187: '+' @ Chrome, Safari\n                    node.setExpanded(true);\n                    break;\n                case \"-\":\n                case \"Subtract\":\n                    node.setExpanded(false);\n                    break;\n                case \" \": // Space\n                    if (tree.activeColIdx === 0 && node.getOption(\"checkbox\")) {\n                        node.setSelected(!node.isSelected());\n                        handled = true;\n                    }\n                    else if (curInput && curInputType === \"checkbox\") {\n                        curInput.click();\n                        // toggleCheckbox(curInput)\n                        // new Event(\"change\")\n                        // curInput.change\n                        handled = true;\n                    }\n                    break;\n                case \"F2\":\n                    if (curInput && !inputHasFocus && inputCanFocus) {\n                        curInput.focus();\n                        handled = true;\n                    }\n                    break;\n                case \"Enter\":\n                    tree.setFocus(); // Blur prev. input if any\n                    if ((tree.activeColIdx === 0 || isColspan) && node.isExpandable()) {\n                        node.setExpanded(!node.isExpanded());\n                        handled = true;\n                    }\n                    else if (curInput && !inputHasFocus && inputCanFocus) {\n                        curInput.focus();\n                        handled = true;\n                    }\n                    break;\n                case \"Escape\":\n                    tree.setFocus(); // Blur prev. input if any\n                    node.log(`keynav: focus tree...`);\n                    if (tree.isCellNav() && navModeOption !== NavModeEnum.cell) {\n                        node.log(`keynav: setCellNav(false)`);\n                        tree.setCellNav(false); // row-nav mode\n                        tree.setFocus(); //\n                        handled = true;\n                    }\n                    break;\n                case \"ArrowLeft\":\n                    tree.setFocus(); // Blur prev. input if any\n                    if (isColspan && node.isExpanded()) {\n                        node.setExpanded(false);\n                    }\n                    else if (!isColspan && tree.activeColIdx > 0) {\n                        tree.setColumn(tree.activeColIdx - 1);\n                    }\n                    else if (navModeOption !== NavModeEnum.cell) {\n                        tree.setCellNav(false); // row-nav mode\n                    }\n                    handled = true;\n                    break;\n                case \"ArrowRight\":\n                    tree.setFocus(); // Blur prev. input if any\n                    if (isColspan && !node.isExpanded()) {\n                        node.setExpanded();\n                    }\n                    else if (!isColspan &&\n                        tree.activeColIdx < tree.columns.length - 1) {\n                        tree.setColumn(tree.activeColIdx + 1);\n                    }\n                    handled = true;\n                    break;\n                case \"Home\": // Generated by [Fn] + ArrowLeft on Mac\n                    // case \"Meta+ArrowLeft\":\n                    tree.setFocus(); // Blur prev. input if any\n                    if (!isColspan && tree.activeColIdx > 0) {\n                        tree.setColumn(0);\n                    }\n                    handled = true;\n                    break;\n                case \"End\": // Generated by [Fn] + ArrowRight on Mac\n                    // case \"Meta+ArrowRight\":\n                    tree.setFocus(); // Blur prev. input if any\n                    if (!isColspan && tree.activeColIdx < tree.columns.length - 1) {\n                        tree.setColumn(tree.columns.length - 1);\n                    }\n                    handled = true;\n                    break;\n                case \"ArrowDown\":\n                case \"ArrowUp\":\n                case \"Backspace\":\n                case \"Control+End\": // Generated by Control + [Fn] + ArrowRight on Mac\n                case \"Control+Home\": // Generated by Control + [Fn] + Arrowleft on Mac\n                case \"Meta+ArrowDown\": // [⌘] + ArrowDown on Mac\n                case \"Meta+ArrowUp\": // [⌘] + ArrowUp on Mac\n                case \"PageDown\": // Generated by [Fn] + ArrowDown on Mac\n                case \"PageUp\": // Generated by [Fn] + ArrowUp on Mac\n                    node.navigate(eventName, { activate: activate, event: event });\n                    // if (isCellEditMode) {\n                    //   this._getEmbeddedInputElem(null, true); // set focus to input\n                    // }\n                    handled = true;\n                    break;\n                default:\n                    handled = false;\n            }\n        }\n        if (handled) {\n            event.preventDefault();\n        }\n        return;\n    }\n}\n\n/*!\n * Wunderbaum - ext-logger\n * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.\n * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)\n */\nclass LoggerExtension extends WunderbaumExtension {\n    constructor(tree) {\n        super(tree, \"logger\", {});\n        this.ignoreEvents = new Set([\n            \"enhanceTitle\",\n            \"render\",\n            \"discard\",\n        ]);\n        this.prefix = tree + \".ext-logger\";\n    }\n    init() {\n        const tree = this.tree;\n        // this.ignoreEvents.add();\n        if (tree.getOption(\"debugLevel\") >= 4) {\n            // const self = this;\n            const ignoreEvents = this.ignoreEvents;\n            const prefix = this.prefix;\n            overrideMethod(tree, \"callEvent\", function (name, extra) {\n                if (ignoreEvents.has(name)) {\n                    return tree._superApply(arguments);\n                }\n                const start = Date.now();\n                const res = tree._superApply(arguments);\n                console.debug(`${prefix}: callEvent('${name}') took ${Date.now() - start} ms.`, arguments[1]);\n                return res;\n            });\n        }\n    }\n    onKeyEvent(data) {\n        // this.tree.logInfo(\"onKeyEvent\", eventToString(data.event), data);\n        console.debug(`${this.prefix}: onKeyEvent()`, data);\n        return;\n    }\n}\n\n/*!\n * Wunderbaum - common\n * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.\n * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)\n */\nconst DEFAULT_DEBUGLEVEL = 4; // Replaced by rollup script\n/**\n * Fixed height of a row in pixel. Must match the SCSS variable `$row-outer-height`.\n */\nconst ROW_HEIGHT = 22;\n/**\n * Fixed width of node icons in pixel. Must match the SCSS variable `$icon-outer-width`.\n */\nconst ICON_WIDTH = 20;\n/**\n * Adjust the width of the title span, so overflow ellipsis work.\n * (2 x `$col-padding-x` + 3px rounding errors).\n */\nconst TITLE_SPAN_PAD_Y = 7;\n/** Render row markup for N nodes above and below the visible viewport. */\nconst RENDER_MAX_PREFETCH = 5;\n/** Regular expression to detect if a string describes an image URL (in contrast\n * to a class name). Strings are considered image urls if they contain '.' or '/'.\n */\nconst TEST_IMG = new RegExp(/\\.|\\//);\n// export const RECURSIVE_REQUEST_ERROR = \"$recursive_request\";\n// export const INVALID_REQUEST_TARGET_ERROR = \"$request_target_invalid\";\n/**\n * Default node icons.\n * Requires bootstrap icons https://icons.getbootstrap.com\n */\nconst iconMap = {\n    error: \"bi bi-exclamation-triangle\",\n    // loading: \"bi bi-hourglass-split wb-busy\",\n    loading: \"bi bi-chevron-right wb-busy\",\n    // loading: \"bi bi-arrow-repeat wb-spin\",\n    // loading: '<div class=\"spinner-border spinner-border-sm\" role=\"status\"> <span class=\"visually-hidden\">Loading...</span> </div>',\n    // noData: \"bi bi-search\",\n    noData: \"bi bi-question-circle\",\n    expanderExpanded: \"bi bi-chevron-down\",\n    // expanderExpanded: \"bi bi-dash-square\",\n    expanderCollapsed: \"bi bi-chevron-right\",\n    // expanderCollapsed: \"bi bi-plus-square\",\n    expanderLazy: \"bi bi-chevron-right wb-helper-lazy-expander\",\n    // expanderLazy: \"bi bi-chevron-bar-right\",\n    checkChecked: \"bi bi-check-square\",\n    checkUnchecked: \"bi bi-square\",\n    checkUnknown: \"bi dash-square-dotted\",\n    radioChecked: \"bi bi-circle-fill\",\n    radioUnchecked: \"bi bi-circle\",\n    radioUnknown: \"bi bi-circle-dotted\",\n    folder: \"bi bi-folder2\",\n    folderOpen: \"bi bi-folder2-open\",\n    folderLazy: \"bi bi-folder-symlink\",\n    doc: \"bi bi-file-earmark\",\n};\n/** Dict keys that are evaluated by source loader (others are added to `tree.data` instead). */\nconst RESERVED_TREE_SOURCE_KEYS = new Set([\n    \"_format\",\n    \"_keyMap\",\n    \"_positional\",\n    \"_typeList\",\n    \"_version\",\n    \"children\",\n    \"columns\",\n    \"types\",\n]);\n// /** Key codes that trigger grid navigation, even when inside an input element. */\n// export const INPUT_BREAKOUT_KEYS: Set<string> = new Set([\n//   // \"ArrowDown\",\n//   // \"ArrowUp\",\n//   \"Enter\",\n//   \"Escape\",\n// ]);\n/** Map `KeyEvent.key` to navigation action. */\nconst KEY_TO_ACTION_DICT = {\n    \" \": \"toggleSelect\",\n    \"+\": \"expand\",\n    Add: \"expand\",\n    ArrowDown: \"down\",\n    ArrowLeft: \"left\",\n    ArrowRight: \"right\",\n    ArrowUp: \"up\",\n    Backspace: \"parent\",\n    \"/\": \"collapseAll\",\n    Divide: \"collapseAll\",\n    End: \"lastCol\",\n    Home: \"firstCol\",\n    \"Control+End\": \"last\",\n    \"Control+Home\": \"first\",\n    \"Meta+ArrowDown\": \"last\",\n    \"Meta+ArrowUp\": \"first\",\n    \"*\": \"expandAll\",\n    Multiply: \"expandAll\",\n    PageDown: \"pageDown\",\n    PageUp: \"pageUp\",\n    \"-\": \"collapse\",\n    Subtract: \"collapse\",\n};\n/** Return a callback that returns true if the node title matches the string\n * or regular expression.\n * @see {@link WunderbaumNode.findAll}\n */\nfunction makeNodeTitleMatcher(match) {\n    if (match instanceof RegExp) {\n        return function (node) {\n            return match.test(node.title);\n        };\n    }\n    assert(typeof match === \"string\");\n    // s = escapeRegex(s.toLowerCase());\n    return function (node) {\n        return node.title === match;\n        // console.log(\"match \" + node, node.title.toLowerCase().indexOf(match))\n        // return node.title.toLowerCase().indexOf(match) >= 0;\n    };\n}\n/** Return a callback that returns true if the node title starts with a string (case-insensitive). */\nfunction makeNodeTitleStartMatcher(s) {\n    s = escapeRegex(s);\n    const reMatch = new RegExp(\"^\" + s, \"i\");\n    return function (node) {\n        return reMatch.test(node.title);\n    };\n}\n/** Compare two nodes by title (case-insensitive). */\nfunction nodeTitleSorter(a, b) {\n    const x = a.title.toLowerCase();\n    const y = b.title.toLowerCase();\n    return x === y ? 0 : x > y ? 1 : -1;\n}\nfunction unflattenSource(source) {\n    var _a, _b, _c;\n    const { _format, _keyMap, _positional, children } = source;\n    if (_format !== \"flat\") {\n        throw new Error(`Expected source._format: \"flat\", but got ${_format}`);\n    }\n    if (_positional && _positional.includes(\"children\")) {\n        throw new Error(`source._positional must not include \"children\": ${_positional}`);\n    }\n    // Inverse keyMap:\n    let longToShort = {};\n    if (_keyMap) {\n        for (const [key, value] of Object.entries(_keyMap)) {\n            longToShort[value] = key;\n        }\n    }\n    const positionalShort = _positional.map((e) => longToShort[e]);\n    const newChildren = [];\n    const keyToNodeMap = {};\n    const indexToNodeMap = {};\n    const keyAttrName = (_a = longToShort[\"key\"]) !== null && _a !== void 0 ? _a : \"key\";\n    const childrenAttrName = (_b = longToShort[\"children\"]) !== null && _b !== void 0 ? _b : \"children\";\n    for (const [index, node] of children.entries()) {\n        // Node entry format:\n        //   [PARENT_ID, [POSITIONAL_ARGS]]\n        // or\n        //   [PARENT_ID, [POSITIONAL_ARGS], {KEY_VALUE_ARGS}]\n        const [parentId, args, kwargs = {}] = node;\n        // Free up some memory as we go\n        node[1] = null;\n        if (node[2] != null) {\n            node[2] = null;\n        }\n        // console.log(\"flatten\", parentId, args, kwargs)\n        // We keep `kwargs` as our new node definition. Then we add all positional\n        // values to this object:\n        args.forEach((val, positionalIdx) => {\n            kwargs[positionalShort[positionalIdx]] = val;\n        });\n        // Find the parent node. `null` means 'toplevel'. PARENT_ID may be the numeric\n        // index of the source.children list. If PARENT_ID is a string, we search\n        // a parent with node.key of this value.\n        indexToNodeMap[index] = kwargs;\n        const key = kwargs[keyAttrName];\n        if (key != null) {\n            keyToNodeMap[key] = kwargs;\n        }\n        let parentNode = null;\n        if (parentId === null) ;\n        else if (typeof parentId === \"number\") {\n            parentNode = indexToNodeMap[parentId];\n            if (parentNode === undefined) {\n                throw new Error(`unflattenSource: Could not find parent node by index: ${parentId}.`);\n            }\n        }\n        else {\n            parentNode = keyToNodeMap[parentId];\n            if (parentNode === undefined) {\n                throw new Error(`unflattenSource: Could not find parent node by key: ${parentId}`);\n            }\n        }\n        if (parentNode) {\n            (_c = parentNode[childrenAttrName]) !== null && _c !== void 0 ? _c : (parentNode[childrenAttrName] = []);\n            parentNode[childrenAttrName].push(kwargs);\n        }\n        else {\n            newChildren.push(kwargs);\n        }\n    }\n    delete source.children;\n    source.children = newChildren;\n}\nfunction inflateSourceData(source) {\n    const { _format, _keyMap, _typeList } = source;\n    if (_format === \"flat\") {\n        unflattenSource(source);\n    }\n    delete source._format;\n    delete source._version;\n    delete source._keyMap;\n    delete source._typeList;\n    delete source._positional;\n    function _iter(childList) {\n        for (let node of childList) {\n            // Expand short alias names\n            if (_keyMap) {\n                // Iterate over a list of names, because we modify inside the loop:\n                Object.getOwnPropertyNames(node).forEach((propName) => {\n                    var _a;\n                    const long = (_a = _keyMap[propName]) !== null && _a !== void 0 ? _a : propName;\n                    if (long !== propName) {\n                        node[long] = node[propName];\n                        delete node[propName];\n                    }\n                });\n            }\n            // `node` now has long attribute names\n            // Resolve node type indexes\n            const type = node.type;\n            if (_typeList && type != null && typeof type === \"number\") {\n                const newType = _typeList[type];\n                if (newType == null) {\n                    throw new Error(`Expected typeList[${type}] entry in [${_typeList}]`);\n                }\n                node.type = newType;\n            }\n            // Recursion\n            if (node.children) {\n                _iter(node.children);\n            }\n        }\n    }\n    _iter(source.children);\n}\n\n/*!\n * Wunderbaum - ext-dnd\n * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.\n * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)\n */\nconst nodeMimeType = \"application/x-wunderbaum-node\";\nclass DndExtension extends WunderbaumExtension {\n    constructor(tree) {\n        super(tree, \"dnd\", {\n            autoExpandMS: 1500,\n            // dropMarkerInsertOffsetX: -16, // Additional offset for drop-marker with hitMode = \"before\"/\"after\"\n            // dropMarkerOffsetX: -24, // Absolute position offset for .fancytree-drop-marker relatively to ..fancytree-title (icon/img near a node accepting drop)\n            // #1021 `document.body` is not available yet\n            // dropMarkerParent: \"body\", // Root Container used for drop marker (could be a shadow root)\n            multiSource: false,\n            effectAllowed: \"all\",\n            // dropEffect: \"auto\", // 'copy'|'link'|'move'|'auto'(calculate from `effectAllowed`+modifier keys) or callback(node, data) that returns such string.\n            dropEffectDefault: \"move\",\n            preventForeignNodes: false,\n            preventLazyParents: true,\n            preventNonNodes: false,\n            preventRecursion: true,\n            preventSameParent: false,\n            preventVoidMoves: true,\n            scroll: true,\n            scrollSensitivity: 20,\n            scrollSpeed: 5,\n            // setTextTypeJson: false, // Allow dragging of nodes to different IE windows\n            sourceCopyHook: null,\n            // Events (drag support)\n            dragStart: null,\n            dragDrag: null,\n            dragEnd: null,\n            // Events (drop support)\n            dragEnter: null,\n            dragOver: null,\n            dragExpand: null,\n            dragDrop: null,\n            dragLeave: null, // Callback(targetNode, data)\n        });\n        // public dropMarkerElem?: HTMLElement;\n        this.srcNode = null;\n        this.lastTargetNode = null;\n        this.lastEnterStamp = 0;\n        this.lastAllowedDropRegions = null;\n        this.lastDropEffect = null;\n        this.lastDropRegion = false;\n    }\n    init() {\n        super.init();\n        // Store the current scroll parent, which may be the tree\n        // container, any enclosing div, or the document.\n        // #761: scrollParent() always needs a container child\n        // $temp = $(\"<span>\").appendTo(this.$container);\n        // this.$scrollParent = $temp.scrollParent();\n        // $temp.remove();\n        const tree = this.tree;\n        const dndOpts = tree.options.dnd;\n        // Enable drag support if dragStart() is specified:\n        if (dndOpts.dragStart) {\n            onEvent(tree.element, \"dragstart drag dragend\", this.onDragEvent.bind(this));\n        }\n        // Enable drop support if dragEnter() is specified:\n        if (dndOpts.dragEnter) {\n            onEvent(tree.element, \"dragenter dragover dragleave drop\", this.onDropEvent.bind(this));\n        }\n    }\n    /** Cleanup classes after target node is no longer hovered. */\n    _leaveNode() {\n        // We remove the marker on dragenter from the previous target:\n        const ltn = this.lastTargetNode;\n        this.lastEnterStamp = 0;\n        if (ltn) {\n            ltn.setClass(\"wb-drop-target wb-drop-over wb-drop-after wb-drop-before\", false);\n            this.lastTargetNode = null;\n        }\n    }\n    /** */\n    unifyDragover(res) {\n        if (res === false) {\n            return false;\n        }\n        else if (res instanceof Set) {\n            return res.size > 0 ? res : false;\n        }\n        else if (res === true) {\n            return new Set([\"over\", \"before\", \"after\"]);\n        }\n        else if (typeof res === \"string\" || isArray(res)) {\n            res = toSet(res);\n            return res.size > 0 ? res : false;\n        }\n        throw new Error(\"Unsupported drop region definition: \" + res);\n    }\n    /** */\n    _calcDropRegion(e, allowed) {\n        const dy = e.offsetY;\n        if (!allowed) {\n            return false;\n        }\n        else if (allowed.size === 3) {\n            return dy < 0.25 * ROW_HEIGHT\n                ? \"before\"\n                : dy > 0.75 * ROW_HEIGHT\n                    ? \"after\"\n                    : \"over\";\n        }\n        else if (allowed.size === 1 && allowed.has(\"over\")) {\n            return \"over\";\n        }\n        else {\n            // Only 'before' and 'after':\n            return dy > ROW_HEIGHT / 2 ? \"after\" : \"before\";\n        }\n        // return \"over\";\n    }\n    /* Implement auto scrolling when drag cursor is in top/bottom area of scroll parent. */\n    autoScroll(event) {\n        let tree = this.tree, dndOpts = tree.options.dnd, sp = tree.listContainerElement, sensitivity = dndOpts.scrollSensitivity, speed = dndOpts.scrollSpeed, scrolled = 0;\n        const scrollTop = sp.offsetTop;\n        if (scrollTop + sp.offsetHeight - event.pageY < sensitivity) {\n            const delta = sp.scrollHeight - sp.clientHeight - scrollTop;\n            if (delta > 0) {\n                sp.scrollTop = scrolled = scrollTop + speed;\n            }\n        }\n        else if (scrollTop > 0 && event.pageY - scrollTop < sensitivity) {\n            sp.scrollTop = scrolled = scrollTop - speed;\n        }\n        // if (scrolled) {\n        //   tree.logDebug(\"autoScroll: \" + scrolled + \"px\");\n        // }\n        return scrolled;\n    }\n    onDragEvent(e) {\n        // const tree = this.tree;\n        const dndOpts = this.treeOpts.dnd;\n        const srcNode = Wunderbaum.getNode(e);\n        if (!srcNode) {\n            return;\n        }\n        if (e.type !== \"drag\") {\n            this.tree.logDebug(\"onDragEvent.\" + e.type + \", srcNode: \" + srcNode, e);\n        }\n        // --- dragstart ---\n        if (e.type === \"dragstart\") {\n            // Set a default definition of allowed effects\n            e.dataTransfer.effectAllowed = dndOpts.effectAllowed; //\"copyMove\"; // \"all\";\n            if (srcNode.isEditing()) {\n                srcNode.logDebug(\"Prevented dragging node in edit mode.\");\n                e.preventDefault();\n                return false;\n            }\n            // Let user cancel the drag operation, override effectAllowed, etc.:\n            const res = srcNode._callEvent(\"dnd.dragStart\", { event: e });\n            if (!res) {\n                e.preventDefault();\n                return false;\n            }\n            let nodeData = srcNode.toDict(true, (n) => {\n                // We don't want to re-use the key on drop:\n                n._org_key = n.key;\n                delete n.key;\n            });\n            nodeData.treeId = srcNode.tree.id;\n            const json = JSON.stringify(nodeData);\n            e.dataTransfer.setData(nodeMimeType, json);\n            // e.dataTransfer!.setData(\"text/html\", $(node.span).html());\n            e.dataTransfer.setData(\"text/plain\", srcNode.title);\n            this.srcNode = srcNode;\n            setTimeout(() => {\n                // Decouple this call, so the CSS is applied to the node, but not to\n                // the system generated drag image\n                srcNode.setClass(\"wb-drag-source\");\n            }, 0);\n            // --- drag ---\n        }\n        else if (e.type === \"drag\") ;\n        else if (e.type === \"dragend\") {\n            srcNode.setClass(\"wb-drag-source\", false);\n            this.srcNode = null;\n            if (this.lastTargetNode) {\n                this._leaveNode();\n            }\n        }\n        return true;\n    }\n    onDropEvent(e) {\n        // const isLink = event.dataTransfer.types.includes(\"text/uri-list\");\n        const srcNode = this.srcNode;\n        const srcTree = srcNode ? srcNode.tree : null;\n        const targetNode = Wunderbaum.getNode(e);\n        const dndOpts = this.treeOpts.dnd;\n        const dt = e.dataTransfer;\n        if (!targetNode) {\n            this._leaveNode();\n            return;\n        }\n        if (![\"dragenter\", \"dragover\", \"dragleave\"].includes(e.type)) {\n            this.tree.logDebug(\"onDropEvent.\" +\n                e.type +\n                \" targetNode: \" +\n                targetNode +\n                \", ea: \" +\n                (dt === null || dt === void 0 ? void 0 : dt.effectAllowed) +\n                \", de: \" +\n                (dt === null || dt === void 0 ? void 0 : dt.dropEffect), \", cy: \" + e.offsetY, \", r: \" + this._calcDropRegion(e, this.lastAllowedDropRegions), e);\n        }\n        // --- dragenter ---\n        if (e.type === \"dragenter\") {\n            this.lastAllowedDropRegions = null;\n            // `dragleave` is not reliable with event delegation, so we generate it\n            // from dragenter:\n            if (this.lastTargetNode && this.lastTargetNode !== targetNode) {\n                this._leaveNode();\n            }\n            this.lastTargetNode = targetNode;\n            this.lastEnterStamp = Date.now();\n            if (\n            // Don't drop on status node:\n            targetNode.isStatusNode() ||\n                // Prevent dropping nodes from different Wunderbaum trees:\n                (dndOpts.preventForeignNodes && targetNode.tree !== srcTree) ||\n                // Prevent dropping items on unloaded lazy Wunderbaum tree nodes:\n                (dndOpts.preventLazyParents && !targetNode.isLoaded()) ||\n                // Prevent dropping items other than Wunderbaum tree nodes:\n                (dndOpts.preventNonNodes && !srcNode) ||\n                // Prevent dropping nodes on own descendants:\n                (dndOpts.preventRecursion &&\n                    srcNode &&\n                    srcNode.isAncestorOf(targetNode)) ||\n                // Prevent dropping nodes under same direct parent:\n                (dndOpts.preventSameParent &&\n                    srcNode &&\n                    targetNode.parent === srcNode.parent) ||\n                // Don't allow void operation ('drop on self'): TODO: should be checke onn  move only\n                (dndOpts.preventVoidMoves && targetNode === srcNode)) {\n                dt.dropEffect = \"none\";\n                return true; // Prevent drop operation\n            }\n            // User may return a set of regions (or `false` to prevent drop)\n            let regionSet = targetNode._callEvent(\"dnd.dragEnter\", { event: e });\n            //\n            regionSet = this.unifyDragover(regionSet);\n            if (!regionSet) {\n                dt.dropEffect = \"none\";\n                return true; // Prevent drop operation\n            }\n            this.lastAllowedDropRegions = regionSet;\n            this.lastDropEffect = dt.dropEffect;\n            targetNode.setClass(\"wb-drop-target\");\n            e.preventDefault(); // Allow drop (Drop operation is denied by default)\n            return false;\n            // --- dragover ---\n        }\n        else if (e.type === \"dragover\") {\n            this.autoScroll(e);\n            const region = this._calcDropRegion(e, this.lastAllowedDropRegions);\n            this.lastDropRegion = region;\n            if (dndOpts.autoExpandMS > 0 &&\n                targetNode.isExpandable(true) &&\n                !targetNode._isLoading &&\n                Date.now() - this.lastEnterStamp > dndOpts.autoExpandMS &&\n                targetNode._callEvent(\"dnd.dragExpand\", { event: e }) !== false) {\n                targetNode.setExpanded();\n            }\n            if (!region) {\n                return; // We already rejected in dragenter\n            }\n            targetNode.setClass(\"wb-drop-over\", region === \"over\");\n            targetNode.setClass(\"wb-drop-before\", region === \"before\");\n            targetNode.setClass(\"wb-drop-after\", region === \"after\");\n            // console.log(\"dragover\", e);\n            // dt.dropEffect = this.lastDropEffect!;\n            e.preventDefault(); // Allow drop (Drop operation is denied by default)\n            return false;\n            // --- dragleave ---\n        }\n        else if (e.type === \"dragleave\") ;\n        else if (e.type === \"drop\") {\n            e.stopPropagation(); // prevent browser from opening links?\n            this._leaveNode();\n            const region = this.lastDropRegion;\n            targetNode._callEvent(\"dnd.drop\", {\n                event: e,\n                region: region,\n                defaultDropMode: region === \"over\" ? \"appendChild\" : region,\n                sourceNode: this.srcNode,\n            });\n        }\n    }\n}\n\n/*!\n * Wunderbaum - drag_observer\n * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.\n * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)\n */\n/**\n * Convert mouse- and touch events to 'dragstart', 'drag', and 'dragstop'.\n */\nclass DragObserver {\n    constructor(opts) {\n        this.start = {\n            x: 0,\n            y: 0,\n            altKey: false,\n            ctrlKey: false,\n            metaKey: false,\n            shiftKey: false,\n        };\n        this.dragElem = null;\n        this.dragging = false;\n        // TODO: touch events\n        this.events = [\"mousedown\", \"mouseup\", \"mousemove\", \"keydown\"];\n        if (!opts.root) {\n            throw new Error(\"Missing `root` option.\");\n        }\n        this.opts = Object.assign({ thresh: 5 }, opts);\n        this.root = opts.root;\n        this._handler = this.handleEvent.bind(this);\n        this.events.forEach((type) => {\n            this.root.addEventListener(type, this._handler);\n        });\n    }\n    /** Unregister all event listeners. */\n    disconnect() {\n        this.events.forEach((type) => {\n            this.root.removeEventListener(type, this._handler);\n        });\n    }\n    getDragElem() {\n        return this.dragElem;\n    }\n    isDragging() {\n        return this.dragging;\n    }\n    stopDrag(cb_event) {\n        if (this.dragging && this.opts.dragstop && cb_event) {\n            cb_event.type = \"dragstop\";\n            this.opts.dragstop(cb_event);\n        }\n        this.dragElem = null;\n        this.dragging = false;\n    }\n    handleEvent(e) {\n        const type = e.type;\n        const opts = this.opts;\n        const cb_event = {\n            type: e.type,\n            event: e,\n            dragElem: this.dragElem,\n            dx: e.pageX - this.start.x,\n            dy: e.pageY - this.start.y,\n            apply: undefined,\n        };\n        switch (type) {\n            case \"keydown\":\n                this.stopDrag(cb_event);\n                break;\n            case \"mousedown\":\n                if (this.dragElem) {\n                    this.stopDrag(cb_event);\n                    break;\n                }\n                if (opts.selector) {\n                    let elem = e.target;\n                    if (elem.matches(opts.selector)) {\n                        this.dragElem = elem;\n                    }\n                    else {\n                        elem = elem.closest(opts.selector);\n                        if (elem) {\n                            this.dragElem = elem;\n                        }\n                        else {\n                            break; // no event delegation selector matched\n                        }\n                    }\n                }\n                this.start.x = e.pageX;\n                this.start.y = e.pageY;\n                this.start.altKey = e.altKey;\n                this.start.ctrlKey = e.ctrlKey;\n                this.start.metaKey = e.metaKey;\n                this.start.shiftKey = e.shiftKey;\n                break;\n            case \"mousemove\":\n                // TODO: debounce/throttle?\n                // TODO: horizontal mode: ignore if dx unchanged\n                if (!this.dragElem) {\n                    break;\n                }\n                if (!this.dragging) {\n                    if (opts.thresh) {\n                        const dist2 = cb_event.dx * cb_event.dx + cb_event.dy * cb_event.dy;\n                        if (dist2 < opts.thresh * opts.thresh) {\n                            break;\n                        }\n                    }\n                    cb_event.type = \"dragstart\";\n                    if (opts.dragstart(cb_event) === false) {\n                        this.stopDrag(cb_event);\n                        break;\n                    }\n                    this.dragging = true;\n                }\n                if (this.dragging && this.opts.drag) {\n                    cb_event.type = \"drag\";\n                    this.opts.drag(cb_event);\n                }\n                break;\n            case \"mouseup\":\n                if (!this.dragging) {\n                    this.stopDrag(cb_event);\n                    break;\n                }\n                if (e.button === 0) {\n                    cb_event.apply = true;\n                }\n                else {\n                    cb_event.apply = false;\n                }\n                this.stopDrag(cb_event);\n                break;\n        }\n    }\n}\n\n/*!\n * Wunderbaum - ext-grid\n * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.\n * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)\n */\nclass GridExtension extends WunderbaumExtension {\n    constructor(tree) {\n        super(tree, \"grid\", {\n        // throttle: 200,\n        });\n        this.observer = new DragObserver({\n            root: window.document,\n            selector: \"span.wb-col-resizer\",\n            thresh: 4,\n            // throttle: 400,\n            dragstart: (e) => {\n                return this.tree.element.contains(e.dragElem);\n            },\n            drag: (e) => {\n                // TODO: throttle\n                return this.handleDrag(e);\n            },\n            dragstop: (e) => {\n                return this.handleDrag(e);\n            },\n        });\n    }\n    init() {\n        super.init();\n    }\n    handleDrag(e) {\n        const info = Wunderbaum.getEventInfo(e.event);\n        // this.tree.options.\n        this.tree.log(`${e.type}(${e.dx})`, e, info);\n    }\n}\n\n/*!\n * Wunderbaum - deferred\n * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.\n * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)\n */\n/**\n * Implement a ES6 Promise, that exposes a resolve() and reject() method.\n *\n * Loosely mimics {@link https://api.jquery.com/category/deferred-object/ | jQuery.Deferred}.\n * Example:\n * ```js\n * function foo() {\n *   let dfd = new Deferred(),\n *   ...\n *   dfd.resolve('foo')\n *   ...\n *   return dfd.promise();\n * }\n * ```\n */\nclass Deferred {\n    constructor() {\n        this._promise = new Promise((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n    }\n    /** Resolve the [[Promise]]. */\n    resolve(value) {\n        this._resolve(value);\n    }\n    /** Reject the [[Promise]]. */\n    reject(reason) {\n        this._reject(reason);\n    }\n    /** Return the native [[Promise]] instance.*/\n    promise() {\n        return this._promise;\n    }\n    /** Call [[Promise.then]] on the embedded promise instance.*/\n    then(cb) {\n        return this._promise.then(cb);\n    }\n    /** Call [[Promise.catch]] on the embedded promise instance.*/\n    catch(cb) {\n        return this._promise.catch(cb);\n    }\n    /** Call [[Promise.finally]] on the embedded promise instance.*/\n    finally(cb) {\n        return this._promise.finally(cb);\n    }\n}\n\n/*!\n * Wunderbaum - wunderbaum_node\n * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.\n * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)\n */\n/** Top-level properties that can be passed with `data`. */\nconst NODE_PROPS = new Set([\n    // TODO: use NODE_ATTRS instead?\n    \"classes\",\n    \"expanded\",\n    \"icon\",\n    \"key\",\n    \"lazy\",\n    \"refKey\",\n    \"selected\",\n    \"title\",\n    \"tooltip\",\n    \"type\",\n]);\nconst NODE_ATTRS = new Set([\n    \"checkbox\",\n    \"expanded\",\n    \"classes\",\n    \"folder\",\n    \"icon\",\n    \"iconTooltip\",\n    \"key\",\n    \"lazy\",\n    \"partsel\",\n    \"radiogroup\",\n    \"refKey\",\n    \"selected\",\n    \"statusNodeType\",\n    \"title\",\n    \"tooltip\",\n    \"type\",\n    \"unselectable\",\n    \"unselectableIgnore\",\n    \"unselectableStatus\",\n]);\n/**\n * A single tree node.\n *\n * **NOTE:** <br>\n * Generally you should not modify properties directly, since this may break\n * the internal bookkeeping.\n */\nclass WunderbaumNode {\n    constructor(tree, parent, data) {\n        var _a, _b;\n        /** Reference key. Unlike {@link key}, a `refKey` may occur multiple\n         * times within a tree (in this case we have 'clone nodes').\n         * @see Use {@link setKey} to modify.\n         */\n        this.refKey = undefined;\n        this.children = null;\n        this.lazy = false;\n        /** Expansion state.\n         * @see {@link isExpandable}, {@link isExpanded}, {@link setExpanded}. */\n        this.expanded = false;\n        /** Selection state.\n         * @see {@link isSelected}, {@link setSelected}. */\n        this.selected = false;\n        /** Additional classes added to `div.wb-row`.\n         * @see {@link hasClass}, {@link setClass}. */\n        this.classes = null; //new Set<string>();\n        /** Custom data that was passed to the constructor */\n        this.data = {};\n        this._isLoading = false;\n        this._requestId = 0;\n        this._errorInfo = null;\n        this._partsel = false;\n        this._partload = false;\n        this.subMatchCount = 0;\n        this._rowIdx = 0;\n        this._rowElem = undefined;\n        assert(!parent || parent.tree === tree);\n        assert(!data.children);\n        this.tree = tree;\n        this.parent = parent;\n        this.key = \"\" + ((_a = data.key) !== null && _a !== void 0 ? _a : ++WunderbaumNode.sequence);\n        this.title = \"\" + ((_b = data.title) !== null && _b !== void 0 ? _b : \"<\" + this.key + \">\");\n        data.refKey != null ? (this.refKey = \"\" + data.refKey) : 0;\n        data.statusNodeType != null\n            ? (this.statusNodeType = \"\" + data.statusNodeType)\n            : 0;\n        data.type != null ? (this.type = \"\" + data.type) : 0;\n        data.checkbox != null ? (this.checkbox = !!data.checkbox) : 0;\n        data.colspan != null ? (this.colspan = !!data.colspan) : 0;\n        this.expanded = data.expanded === true;\n        data.icon != null ? (this.icon = data.icon) : 0;\n        this.lazy = data.lazy === true;\n        this.selected = data.selected === true;\n        if (data.classes) {\n            this.setClass(data.classes);\n        }\n        // Store custom fields as `node.data`\n        for (const [key, value] of Object.entries(data)) {\n            if (!NODE_PROPS.has(key)) {\n                this.data[key] = value;\n            }\n        }\n        if (parent && !this.statusNodeType) {\n            // Don't register root node or status nodes\n            tree._registerNode(this);\n        }\n    }\n    /**\n     * Return readable string representation for this instance.\n     * @internal\n     */\n    toString() {\n        return `WunderbaumNode@${this.key}<'${this.title}'>`;\n    }\n    /**\n     * Iterate all descendant nodes depth-first, pre-order using `for ... of ...` syntax.\n     * More concise, but slightly slower than {@link WunderbaumNode.visit}.\n     *\n     * Example:\n     * ```js\n     * for(const n of node) {\n     *   ...\n     * }\n     * ```\n     */\n    *[Symbol.iterator]() {\n        // let node: WunderbaumNode | null = this;\n        const cl = this.children;\n        if (cl) {\n            for (let i = 0, l = cl.length; i < l; i++) {\n                const n = cl[i];\n                yield n;\n                if (n.children) {\n                    yield* n;\n                }\n            }\n            // Slower:\n            // for (let node of this.children) {\n            //   yield node;\n            //   yield* node : 0;\n            // }\n        }\n    }\n    // /** Return an option value. */\n    // protected _getOpt(\n    //   name: string,\n    //   nodeObject: any = null,\n    //   treeOptions: any = null,\n    //   defaultValue: any = null\n    // ): any {\n    //   return evalOption(\n    //     name,\n    //     this,\n    //     nodeObject || this,\n    //     treeOptions || this.tree.options,\n    //     defaultValue\n    //   );\n    // }\n    /** Call event handler if defined in tree.options.\n     * Example:\n     * ```js\n     * node._callEvent(\"edit.beforeEdit\", {foo: 42})\n     * ```\n     */\n    _callEvent(type, extra) {\n        return this.tree._callEvent(type, extend({\n            node: this,\n            typeInfo: this.type ? this.tree.types[this.type] : {},\n        }, extra));\n    }\n    /**\n     * Append (or insert) a list of child nodes.\n     *\n     * Tip: pass `{ before: 0 }` to prepend new nodes as first children.\n     *\n     * @returns first child added\n     */\n    addChildren(nodeData, options) {\n        const tree = this.tree;\n        let { before = null, applyMinExpanLevel = true, _level } = options !== null && options !== void 0 ? options : {};\n        // let { before, loadLazy=true, _level } = options ?? {};\n        // const isTopCall = _level == null;\n        _level !== null && _level !== void 0 ? _level : (_level = this.getLevel());\n        const nodeList = [];\n        try {\n            tree.enableUpdate(false);\n            if (isPlainObject(nodeData)) {\n                nodeData = [nodeData];\n            }\n            const forceExpand = applyMinExpanLevel && _level < tree.options.minExpandLevel;\n            for (let child of nodeData) {\n                const subChildren = child.children;\n                delete child.children;\n                const n = new WunderbaumNode(tree, this, child);\n                if (forceExpand && !n.isUnloaded()) {\n                    n.expanded = true;\n                }\n                nodeList.push(n);\n                if (subChildren) {\n                    n.addChildren(subChildren, { _level: _level + 1 });\n                }\n            }\n            if (!this.children) {\n                this.children = nodeList;\n            }\n            else if (before == null || this.children.length === 0) {\n                this.children = this.children.concat(nodeList);\n            }\n            else {\n                // Returns null if before is not a direct child:\n                before = this.findDirectChild(before);\n                let pos = this.children.indexOf(before);\n                assert(pos >= 0, `options.before must be a direct child of ${this}`);\n                // insert nodeList after children[pos]\n                this.children.splice(pos, 0, ...nodeList);\n            }\n            // TODO:\n            // if (tree.options.selectMode === 3) {\n            //   this.fixSelection3FromEndNodes();\n            // }\n            // this.triggerModifyChild(\"add\", nodeList.length === 1 ? nodeList[0] : null);\n            tree.setModified(ChangeType.structure);\n        }\n        finally {\n            tree.enableUpdate(true);\n        }\n        // if(isTopCall && loadLazy){\n        //   this.logWarn(\"addChildren(): loadLazy is not yet implemented.\")\n        // }\n        return nodeList[0];\n    }\n    /**\n     * Append or prepend a node, or append a child node.\n     *\n     * This a convenience function that calls addChildren()\n     *\n     * @param nodeData node definition\n     * @param [mode=child] 'before', 'after', 'firstChild', or 'child' ('over' is a synonym for 'child')\n     * @returns new node\n     */\n    addNode(nodeData, mode = \"appendChild\") {\n        if (mode === \"over\") {\n            mode = \"appendChild\"; // compatible with drop region\n        }\n        switch (mode) {\n            case \"after\":\n                return this.parent.addChildren(nodeData, {\n                    before: this.getNextSibling(),\n                });\n            case \"before\":\n                return this.parent.addChildren(nodeData, { before: this });\n            case \"prependChild\":\n                // Insert before the first child if any\n                // let insertBefore = this.children ? this.children[0] : undefined;\n                return this.addChildren(nodeData, { before: 0 });\n            case \"appendChild\":\n                return this.addChildren(nodeData);\n        }\n        assert(false, \"Invalid mode: \" + mode);\n        return undefined;\n    }\n    /**\n     * Apply a modification (or navigation) operation.\n     *\n     * @see {@link Wunderbaum.applyCommand}\n     */\n    applyCommand(cmd, options) {\n        return this.tree.applyCommand(cmd, this, options);\n    }\n    /**\n     * Add/remove one or more classes to `<div class='wb-row'>`.\n     *\n     * This also maintains `node.classes`, so the class will survive a re-render.\n     *\n     * @param className one or more class names. Multiple classes can be passed\n     *     as space-separated string, array of strings, or set of strings.\n     */\n    setClass(className, flag = true) {\n        const cnSet = toSet(className);\n        if (flag) {\n            if (this.classes === null) {\n                this.classes = new Set();\n            }\n            cnSet.forEach((cn) => {\n                var _a;\n                this.classes.add(cn);\n                (_a = this._rowElem) === null || _a === void 0 ? void 0 : _a.classList.toggle(cn, flag);\n            });\n        }\n        else {\n            if (this.classes === null) {\n                return;\n            }\n            cnSet.forEach((cn) => {\n                var _a;\n                this.classes.delete(cn);\n                (_a = this._rowElem) === null || _a === void 0 ? void 0 : _a.classList.toggle(cn, flag);\n            });\n            if (this.classes.size === 0) {\n                this.classes = null;\n            }\n        }\n    }\n    /** Call `setExpanded()` on all descendant nodes. */\n    async expandAll(flag = true, options) {\n        const tree = this.tree;\n        const minExpandLevel = this.tree.options.minExpandLevel;\n        let { depth = 99, loadLazy, force } = options !== null && options !== void 0 ? options : {};\n        const expand_opts = {\n            scrollIntoView: false,\n            force: force,\n            loadLazy: loadLazy,\n        };\n        // this.logInfo(`expandAll(${flag})`);\n        // Expand all direct children in parallel:\n        async function _iter(n, level) {\n            var _a;\n            // n.logInfo(`  _iter(${level})`);\n            if (level === 0) {\n                return;\n            }\n            // if (!flag && minExpandLevel && !force && n.getLevel() <= minExpandLevel) {\n            //   return; // Do not collapse until minExpandLevel\n            // }\n            const level_1 = level == null ? null : level - 1;\n            const promises = [];\n            (_a = n.children) === null || _a === void 0 ? void 0 : _a.forEach((cn) => {\n                if (flag) {\n                    if (!cn.expanded && (cn.children || (loadLazy && cn.lazy))) {\n                        // Node is collapsed and may be expanded (i.e. has children or is lazy)\n                        // Expanding may be async, so we store the promise.\n                        // Also the recursion is delayed until expansion finished.\n                        const p = cn.setExpanded(true, expand_opts);\n                        promises.push(p);\n                        p.then(async () => {\n                            await _iter(cn, level_1);\n                        });\n                    }\n                    else {\n                        // We don't expand the node, but still visit descendants.\n                        // There we may find lazy nodes, so we\n                        promises.push(_iter(cn, level_1));\n                    }\n                }\n                else {\n                    // Collapsing is always synchronous, so no promises required\n                    if (!minExpandLevel || force || cn.getLevel() > minExpandLevel) {\n                        // Do not collapse until minExpandLevel\n                        cn.setExpanded(false, expand_opts);\n                    }\n                    _iter(cn, level_1); // recursion, even if cn was already collapsed\n                }\n            });\n            return new Promise((resolve) => {\n                Promise.all(promises).then(() => {\n                    resolve(true);\n                });\n            });\n        }\n        const tag = tree.logTime(`${this}.expandAll(${flag})`);\n        try {\n            tree.enableUpdate(false);\n            await _iter(this, depth);\n        }\n        finally {\n            tree.enableUpdate(true);\n            tree.logTimeEnd(tag);\n        }\n    }\n    /**\n     * Find all descendant nodes that match condition (excluding self).\n     *\n     * If `match` is a string, search for exact node title.\n     * If `match` is a RegExp expression, apply it to node.title, using\n     * [RegExp.test()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test).\n     * If `match` is a callback, match all nodes for that the callback(node) returns true.\n     *\n     * Returns an empty array if no nodes were found.\n     *\n     * Examples:\n     * ```js\n     * // Match all node titles that match exactly 'Joe':\n     * nodeList = node.findAll(\"Joe\")\n     * // Match all node titles that start with 'Joe' case sensitive:\n     * nodeList = node.findAll(/^Joe/)\n     * // Match all node titles that contain 'oe', case insensitive:\n     * nodeList = node.findAll(/oe/i)\n     * // Match all nodes with `data.price` >= 99:\n     * nodeList = node.findAll((n) => {\n     *   return n.data.price >= 99;\n     * })\n     * ```\n     */\n    findAll(match) {\n        const matcher = typeof match === \"function\" ? match : makeNodeTitleMatcher(match);\n        const res = [];\n        this.visit((n) => {\n            if (matcher(n)) {\n                res.push(n);\n            }\n        });\n        return res;\n    }\n    /** Return the direct child with a given key, index or null. */\n    findDirectChild(ptr) {\n        let cl = this.children;\n        if (!cl)\n            return null;\n        if (typeof ptr === \"string\") {\n            for (let i = 0, l = cl.length; i < l; i++) {\n                if (cl[i].key === ptr) {\n                    return cl[i];\n                }\n            }\n        }\n        else if (typeof ptr === \"number\") {\n            return cl[ptr];\n        }\n        else if (ptr.parent === this) {\n            // Return null if `ptr` is not a direct child\n            return ptr;\n        }\n        return null;\n    }\n    /**\n     * Find first descendant node that matches condition (excluding self) or null.\n     *\n     * @see {@link WunderbaumNode.findAll} for examples.\n     */\n    findFirst(match) {\n        const matcher = typeof match === \"function\" ? match : makeNodeTitleMatcher(match);\n        let res = null;\n        this.visit((n) => {\n            if (matcher(n)) {\n                res = n;\n                return false;\n            }\n        });\n        return res;\n    }\n    /** Find a node relative to self.\n     *\n     * @see {@link Wunderbaum.findRelatedNode|tree.findRelatedNode()}\n     */\n    findRelatedNode(where, includeHidden = false) {\n        return this.tree.findRelatedNode(this, where, includeHidden);\n    }\n    /**\n     * Iterator version of {@link WunderbaumNode.format}.\n     */\n    *format_iter(name_cb, connectors) {\n        connectors !== null && connectors !== void 0 ? connectors : (connectors = [\"    \", \" |  \", \" ╰─ \", \" ├─ \"]);\n        name_cb !== null && name_cb !== void 0 ? name_cb : (name_cb = (node) => \"\" + node);\n        function _is_last(node) {\n            const ca = node.parent.children;\n            return node === ca[ca.length - 1];\n        }\n        const _format_line = (node) => {\n            // https://www.measurethat.net/Benchmarks/Show/12196/0/arr-unshift-vs-push-reverse-small-array\n            const parts = [name_cb(node)];\n            parts.unshift(connectors[_is_last(node) ? 2 : 3]);\n            let p = node.parent;\n            while (p && p !== this) {\n                // `this` is the top node\n                parts.unshift(connectors[_is_last(p) ? 0 : 1]);\n                p = p.parent;\n            }\n            return parts.join(\"\");\n        };\n        yield name_cb(this);\n        for (let node of this) {\n            yield _format_line(node);\n        }\n    }\n    /**\n     * Return a multiline string representation of a node/subnode hierarchy.\n     * Mostly useful for debugging.\n     *\n     * Example:\n     * ```js\n     * console.info(tree.getActiveNode().format((n)=>n.title));\n     * ```\n     * logs\n     * ```\n     * Books\n     *  ├─ Art of War\n     *  ╰─ Don Quixote\n     * ```\n     * @see {@link WunderbaumNode.format_iter}\n     */\n    format(name_cb, connectors) {\n        const a = [];\n        for (let line of this.format_iter(name_cb, connectors)) {\n            a.push(line);\n        }\n        return a.join(\"\\n\");\n    }\n    /** Return the `<span class='wb-col'>` element with a given index or id.\n     * @returns {WunderbaumNode | null}\n     */\n    getColElem(colIdx) {\n        var _a;\n        if (typeof colIdx === \"string\") {\n            colIdx = this.tree.columns.findIndex((value) => value.id === colIdx);\n        }\n        const colElems = (_a = this._rowElem) === null || _a === void 0 ? void 0 : _a.querySelectorAll(\"span.wb-col\");\n        return colElems ? colElems[colIdx] : null;\n    }\n    /** Return the first child node or null.\n     * @returns {WunderbaumNode | null}\n     */\n    getFirstChild() {\n        return this.children ? this.children[0] : null;\n    }\n    /** Return the last child node or null.\n     * @returns {WunderbaumNode | null}\n     */\n    getLastChild() {\n        return this.children ? this.children[this.children.length - 1] : null;\n    }\n    /** Return node depth (starting with 1 for top level nodes). */\n    getLevel() {\n        let i = 0, p = this.parent;\n        while (p) {\n            i++;\n            p = p.parent;\n        }\n        return i;\n    }\n    /** Return the successive node (under the same parent) or null. */\n    getNextSibling() {\n        let ac = this.parent.children;\n        let idx = ac.indexOf(this);\n        return ac[idx + 1] || null;\n    }\n    /** Return the parent node (null for the system root node). */\n    getParent() {\n        // TODO: return null for top-level nodes?\n        return this.parent;\n    }\n    /** Return an array of all parent nodes (top-down).\n     * @param includeRoot Include the invisible system root node.\n     * @param includeSelf Include the node itself.\n     */\n    getParentList(includeRoot = false, includeSelf = false) {\n        let l = [], dtn = includeSelf ? this : this.parent;\n        while (dtn) {\n            if (includeRoot || dtn.parent) {\n                l.unshift(dtn);\n            }\n            dtn = dtn.parent;\n        }\n        return l;\n    }\n    /** Return a string representing the hierachical node path, e.g. \"a/b/c\".\n     * @param includeSelf\n     * @param node property name or callback\n     * @param separator\n     */\n    getPath(includeSelf = true, part = \"title\", separator = \"/\") {\n        // includeSelf = includeSelf !== false;\n        // part = part || \"title\";\n        // separator = separator || \"/\";\n        let val, path = [], isFunc = typeof part === \"function\";\n        this.visitParents((n) => {\n            if (n.parent) {\n                val = isFunc\n                    ? part(n)\n                    : n[part];\n                path.unshift(val);\n            }\n            return undefined; // TODO remove this line\n        }, includeSelf);\n        return path.join(separator);\n    }\n    /** Return the preceeding node (under the same parent) or null. */\n    getPrevSibling() {\n        let ac = this.parent.children;\n        let idx = ac.indexOf(this);\n        return ac[idx - 1] || null;\n    }\n    /** Return true if node has children.\n     * Return undefined if not sure, i.e. the node is lazy and not yet loaded.\n     */\n    hasChildren() {\n        if (this.lazy) {\n            if (this.children == null) {\n                return undefined; // null or undefined: Not yet loaded\n            }\n            else if (this.children.length === 0) {\n                return false; // Loaded, but response was empty\n            }\n            else if (this.children.length === 1 &&\n                this.children[0].isStatusNode()) {\n                return undefined; // Currently loading or load error\n            }\n            return true; // One or more child nodes\n        }\n        return !!(this.children && this.children.length);\n    }\n    /** Return true if node has className set. */\n    hasClass(className) {\n        return this.classes ? this.classes.has(className) : false;\n    }\n    /** Return true if this node is the currently active tree node. */\n    isActive() {\n        return this.tree.activeNode === this;\n    }\n    /** Return true if this node is a direct or indirect parent of `other`.\n     * (See also [[isParentOf]].)\n     */\n    isAncestorOf(other) {\n        return other && other.isDescendantOf(this);\n    }\n    /** Return true if this node is a **direct** subnode of `other`.\n     * (See also [[isDescendantOf]].)\n     */\n    isChildOf(other) {\n        return other && this.parent === other;\n    }\n    /** Return true if this node's title spans all columns, i.e. the node has no\n     * grid cells.\n     */\n    isColspan() {\n        return !!this.getOption(\"colspan\");\n    }\n    /** Return true if this node is a direct or indirect subnode of `other`.\n     * (See also [[isChildOf]].)\n     */\n    isDescendantOf(other) {\n        if (!other || other.tree !== this.tree) {\n            return false;\n        }\n        var p = this.parent;\n        while (p) {\n            if (p === other) {\n                return true;\n            }\n            if (p === p.parent) {\n                error(`Recursive parent link: ${p}`);\n            }\n            p = p.parent;\n        }\n        return false;\n    }\n    /** Return true if this node has children, i.e. the node is generally expandable.\n     * If `andCollapsed` is set, we also check if this node is collapsed, i.e.\n     * an expand operation is currently possible.\n     */\n    isExpandable(andCollapsed = false) {\n        // `false` is never expandable (unoffical)\n        if ((andCollapsed && this.expanded) || this.children === false) {\n            return false;\n        }\n        if (this.children == null) {\n            return this.lazy; // null or undefined can trigger lazy load\n        }\n        if (this.children.length === 0) {\n            return !!this.tree.options.emptyChildListExpandable;\n        }\n        return true;\n    }\n    /** Return true if this node is currently in edit-title mode. */\n    isEditing() {\n        return this.tree._callMethod(\"edit.isEditingTitle\", this);\n    }\n    /** Return true if this node is currently expanded. */\n    isExpanded() {\n        return !!this.expanded;\n    }\n    /** Return true if this node is the first node of its parent's children. */\n    isFirstSibling() {\n        var p = this.parent;\n        return !p || p.children[0] === this;\n    }\n    /** Return true if this node is the last node of its parent's children. */\n    isLastSibling() {\n        var p = this.parent;\n        return !p || p.children[p.children.length - 1] === this;\n    }\n    /** Return true if this node is lazy (even if data was already loaded) */\n    isLazy() {\n        return !!this.lazy;\n    }\n    /** Return true if node is lazy and loaded. For non-lazy nodes always return true. */\n    isLoaded() {\n        return !this.lazy || this.hasChildren() !== undefined; // Also checks if the only child is a status node\n    }\n    /** Return true if node is currently loading, i.e. a GET request is pending. */\n    isLoading() {\n        return this._isLoading;\n    }\n    /** Return true if this node is a temporarily generated status node of type 'paging'. */\n    isPagingNode() {\n        return this.statusNodeType === \"paging\";\n    }\n    /** Return true if this node is a **direct** parent of `other`.\n     * (See also [[isAncestorOf]].)\n     */\n    isParentOf(other) {\n        return other && other.parent === this;\n    }\n    /** (experimental) Return true if this node is partially loaded. */\n    isPartload() {\n        return !!this._partload;\n    }\n    /** Return true if this node is partially selected (tri-state). */\n    isPartsel() {\n        return !this.selected && !!this._partsel;\n    }\n    /** Return true if this node has DOM representaion, i.e. is displayed in the viewport. */\n    isRendered() {\n        return !!this._rowElem;\n    }\n    /** Return true if this node is the (invisible) system root node.\n     * (See also [[isTopLevel()]].)\n     */\n    isRootNode() {\n        return this.tree.root === this;\n    }\n    /** Return true if this node is selected, i.e. the checkbox is set. */\n    isSelected() {\n        return !!this.selected;\n    }\n    /** Return true if this node is a temporarily generated system node like\n     * 'loading', 'paging', or 'error' (node.statusNodeType contains the type).\n     */\n    isStatusNode() {\n        return !!this.statusNodeType;\n    }\n    /** Return true if this a top level node, i.e. a direct child of the (invisible) system root node. */\n    isTopLevel() {\n        return this.tree.root === this.parent;\n    }\n    /** Return true if node is marked lazy but not yet loaded.\n     * For non-lazy nodes always return false.\n     */\n    isUnloaded() {\n        // Also checks if the only child is a status node:\n        return this.hasChildren() === undefined;\n    }\n    /** Return true if all parent nodes are expanded. Note: this does not check\n     * whether the node is scrolled into the visible part of the screen or viewport.\n     */\n    isVisible() {\n        let i, l, n, hasFilter = this.tree.filterMode === \"hide\", parents = this.getParentList(false, false);\n        // TODO: check $(n.span).is(\":visible\")\n        // i.e. return false for nodes (but not parents) that are hidden\n        // by a filter\n        if (hasFilter && !this.match && !this.subMatchCount) {\n            // this.debug( \"isVisible: HIDDEN (\" + hasFilter + \", \" + this.match + \", \" + this.match + \")\" );\n            return false;\n        }\n        for (i = 0, l = parents.length; i < l; i++) {\n            n = parents[i];\n            if (!n.expanded) {\n                // this.debug(\"isVisible: HIDDEN (parent collapsed)\");\n                return false;\n            }\n            // if (hasFilter && !n.match && !n.subMatchCount) {\n            // \tthis.debug(\"isVisible: HIDDEN (\" + hasFilter + \", \" + this.match + \", \" + this.match + \")\");\n            // \treturn false;\n            // }\n        }\n        // this.debug(\"isVisible: VISIBLE\");\n        return true;\n    }\n    _loadSourceObject(source, level) {\n        var _a;\n        const tree = this.tree;\n        level !== null && level !== void 0 ? level : (level = this.getLevel());\n        // Let caller modify the parsed JSON response:\n        const res = this._callEvent(\"receive\", { response: source });\n        if (res != null) {\n            source = res;\n        }\n        if (isArray(source)) {\n            source = { children: source };\n        }\n        assert(isPlainObject(source));\n        const format = (_a = source.format) !== null && _a !== void 0 ? _a : \"nested\";\n        assert(format === \"nested\" || format === \"flat\");\n        // Pre-rocess for 'nested' or 'flat' format\n        inflateSourceData(source);\n        assert(source.children, \"If `source` is an object, it must have a `children` property\");\n        if (source.types) {\n            tree.logInfo(\"Redefine types\", source.columns);\n            tree.setTypes(source.types, false);\n            delete source.types;\n        }\n        if (source.columns) {\n            tree.logInfo(\"Redefine columns\", source.columns);\n            tree.columns = source.columns;\n            delete source.columns;\n            tree.setModified(ChangeType.colStructure);\n        }\n        this.addChildren(source.children);\n        // Add extra data to `tree.data`\n        for (const [key, value] of Object.entries(source)) {\n            if (!RESERVED_TREE_SOURCE_KEYS.has(key)) {\n                tree.data[key] = value;\n                tree.logDebug(`Add source.${key} to tree.data.${key}`);\n            }\n        }\n        this._callEvent(\"load\");\n    }\n    async _fetchWithOptions(source) {\n        var _a, _b;\n        // Either a URL string or an object with a `.url` property.\n        let url, params, body, options, rest;\n        let fetchOpts = {};\n        if (typeof source === \"string\") {\n            // source is a plain URL string: assume GET request\n            url = source;\n            fetchOpts.method = \"GET\";\n        }\n        else if (isPlainObject(source)) {\n            // source is a plain object with `.url` property.\n            ({ url, params, body, options, ...rest } = source);\n            assert(typeof url === \"string\", `expected source.url as string`);\n            if (isPlainObject(options)) {\n                fetchOpts = options;\n            }\n            if (isPlainObject(body)) {\n                // we also accept 'body' as object...\n                assert(!fetchOpts.body, \"options.body should be passed as source.body\");\n                fetchOpts.body = JSON.stringify(fetchOpts.body);\n                (_a = fetchOpts.method) !== null && _a !== void 0 ? _a : (fetchOpts.method = \"POST\"); // set default\n            }\n            if (isPlainObject(params)) {\n                url += \"?\" + new URLSearchParams(params);\n                (_b = fetchOpts.method) !== null && _b !== void 0 ? _b : (fetchOpts.method = \"GET\"); // set default\n            }\n        }\n        else {\n            url = \"\"; // keep linter happy\n            error(`Unsupported source format: ${source}`);\n        }\n        this.setStatus(NodeStatusType.loading);\n        const response = await fetch(url, fetchOpts);\n        if (!response.ok) {\n            error(`GET ${url} returned ${response.status}, ${response}`);\n        }\n        return await response.json();\n    }\n    /** Download  data from the cloud, then call `.update()`. */\n    async load(source) {\n        const tree = this.tree;\n        const requestId = Date.now();\n        const prevParent = this.parent;\n        const start = Date.now();\n        let elap = 0, elapLoad = 0, elapProcess = 0;\n        // Check for overlapping requests\n        if (this._requestId) {\n            this.logWarn(`Recursive load request #${requestId} while #${this._requestId} is pending.`);\n            // \tnode.debug(\"Send load request #\" + requestId);\n        }\n        this._requestId = requestId;\n        // const timerLabel = tree.logTime(this + \".load()\");\n        try {\n            let url = typeof source === \"string\" ? source : source.url;\n            if (!url) {\n                // An array or a plain object (that does NOT contain a `.url` property)\n                // will be treated as native Wunderbaum data\n                this._loadSourceObject(source);\n                elapProcess = Date.now() - start;\n            }\n            else {\n                // Either a URL string or an object with a `.url` property.\n                const data = await this._fetchWithOptions(source);\n                elapLoad = Date.now() - start;\n                if (this._requestId && this._requestId > requestId) {\n                    this.logWarn(`Ignored load response #${requestId} because #${this._requestId} is pending.`);\n                    return;\n                }\n                else {\n                    this.logDebug(`Received response for load request #${requestId}`);\n                }\n                if (this.parent === null && prevParent !== null) {\n                    this.logWarn(\"Lazy parent node was removed while loading: discarding response.\");\n                    return;\n                }\n                this.setStatus(NodeStatusType.ok);\n                // if (data.columns) {\n                //   tree.logInfo(\"Re-define columns\", data.columns);\n                //   util.assert(!this.parent);\n                //   tree.columns = data.columns;\n                //   delete data.columns;\n                //   tree.updateColumns({ calculateCols: false });\n                // }\n                const startProcess = Date.now();\n                this._loadSourceObject(data);\n                elapProcess = Date.now() - startProcess;\n            }\n        }\n        catch (error) {\n            this.logError(\"Error during load()\", source, error);\n            this._callEvent(\"error\", { error: error });\n            this.setStatus(NodeStatusType.error, { message: \"\" + error });\n            throw error;\n        }\n        finally {\n            this._requestId = 0;\n            elap = Date.now() - start;\n            if (tree.options.debugLevel >= 3) {\n                tree.logInfo(`Load source took ${elap / 1000} seconds (transfer: ${elapLoad / 1000}s, processing: ${elapProcess / 1000}s)`);\n            }\n        }\n    }\n    /**Load content of a lazy node. */\n    async loadLazy(forceReload = false) {\n        const wasExpanded = this.expanded;\n        assert(this.lazy, \"load() requires a lazy node\");\n        // _assert( forceReload || this.isUndefined(), \"Pass forceReload=true to re-load a lazy node\" );\n        if (!forceReload && !this.isUnloaded()) {\n            return;\n        }\n        if (this.isLoaded()) {\n            this.resetLazy(); // Also collapses if currently expanded\n        }\n        // `lazyLoad` may be long-running, so mark node as loading now. `this.load()`\n        // will reset the status later.\n        this.setStatus(NodeStatusType.loading);\n        try {\n            const source = await this._callEvent(\"lazyLoad\");\n            if (source === false) {\n                this.setStatus(NodeStatusType.ok);\n                return;\n            }\n            assert(isArray(source) || (source && source.url), \"The lazyLoad event must return a node list, `{url: ...}`, or false.\");\n            await this.load(source); // also calls setStatus('ok')\n            if (wasExpanded) {\n                this.expanded = true;\n                this.tree.setModified(ChangeType.structure);\n            }\n            else {\n                this.setModified(); // Fix expander icon to 'loaded'\n            }\n        }\n        catch (e) {\n            this.logError(\"Error during loadLazy()\", e);\n            this._callEvent(\"error\", { error: e });\n            this.setStatus(NodeStatusType.error, { message: \"\" + e });\n        }\n        return;\n    }\n    /** Alias for `logDebug` */\n    log(...args) {\n        this.logDebug.apply(this, args);\n    }\n    /* Log to console if opts.debugLevel >= 4 */\n    logDebug(...args) {\n        if (this.tree.options.debugLevel >= 4) {\n            Array.prototype.unshift.call(args, this.toString());\n            console.log.apply(console, args);\n        }\n    }\n    /* Log error to console. */\n    logError(...args) {\n        if (this.tree.options.debugLevel >= 1) {\n            Array.prototype.unshift.call(args, this.toString());\n            console.error.apply(console, args);\n        }\n    }\n    /* Log to console if opts.debugLevel >= 3 */\n    logInfo(...args) {\n        if (this.tree.options.debugLevel >= 3) {\n            Array.prototype.unshift.call(args, this.toString());\n            console.info.apply(console, args);\n        }\n    }\n    /* Log warning to console if opts.debugLevel >= 2 */\n    logWarn(...args) {\n        if (this.tree.options.debugLevel >= 2) {\n            Array.prototype.unshift.call(args, this.toString());\n            console.warn.apply(console, args);\n        }\n    }\n    /** Expand all parents and optionally scroll into visible area as neccessary.\n     * Promise is resolved, when lazy loading and animations are done.\n     * @param {object} [options] passed to `setExpanded()`.\n     *     Defaults to {noAnimation: false, noEvents: false, scrollIntoView: true}\n     */\n    async makeVisible(options) {\n        let i, dfd = new Deferred(), deferreds = [], parents = this.getParentList(false, false), len = parents.length, noAnimation = getOption(options, \"noAnimation\", false), scroll = getOption(options, \"scrollIntoView\", true);\n        // scroll = !(options && options.scrollIntoView === false);\n        // Expand bottom-up, so only the top node is animated\n        for (i = len - 1; i >= 0; i--) {\n            // self.debug(\"pushexpand\" + parents[i]);\n            const seOpts = { noAnimation: noAnimation };\n            deferreds.push(parents[i].setExpanded(true, seOpts));\n        }\n        Promise.all(deferreds).then(() => {\n            // All expands have finished\n            // self.debug(\"expand DONE\", scroll);\n            // Note: this.tree may be none when switching demo trees\n            if (scroll && this.tree) {\n                // Make sure markup and _rowIdx is updated before we do the scroll calculations\n                this.tree.updatePendingModifications();\n                this.scrollIntoView().then(() => {\n                    // self.debug(\"scroll DONE\");\n                    dfd.resolve();\n                });\n            }\n            else {\n                dfd.resolve();\n            }\n        });\n        return dfd.promise();\n    }\n    /** Move this node to targetNode. */\n    moveTo(targetNode, mode = \"appendChild\", map) {\n        if (mode === \"over\") {\n            mode = \"appendChild\"; // compatible with drop region\n        }\n        if (mode === \"prependChild\") {\n            if (targetNode.children && targetNode.children.length) {\n                mode = \"before\";\n                targetNode = targetNode.children[0];\n            }\n            else {\n                mode = \"appendChild\";\n            }\n        }\n        let pos, tree = this.tree, prevParent = this.parent, targetParent = mode === \"appendChild\" ? targetNode : targetNode.parent;\n        if (this === targetNode) {\n            return;\n        }\n        else if (!this.parent) {\n            error(\"Cannot move system root\");\n        }\n        else if (targetParent.isDescendantOf(this)) {\n            error(\"Cannot move a node to its own descendant\");\n        }\n        if (targetParent !== prevParent) {\n            prevParent.triggerModifyChild(\"remove\", this);\n        }\n        // Unlink this node from current parent\n        if (this.parent.children.length === 1) {\n            if (this.parent === targetParent) {\n                return; // #258\n            }\n            this.parent.children = this.parent.lazy ? [] : null;\n            this.parent.expanded = false;\n        }\n        else {\n            pos = this.parent.children.indexOf(this);\n            assert(pos >= 0, \"invalid source parent\");\n            this.parent.children.splice(pos, 1);\n        }\n        // Insert this node to target parent's child list\n        this.parent = targetParent;\n        if (targetParent.hasChildren()) {\n            switch (mode) {\n                case \"appendChild\":\n                    // Append to existing target children\n                    targetParent.children.push(this);\n                    break;\n                case \"before\":\n                    // Insert this node before target node\n                    pos = targetParent.children.indexOf(targetNode);\n                    assert(pos >= 0, \"invalid target parent\");\n                    targetParent.children.splice(pos, 0, this);\n                    break;\n                case \"after\":\n                    // Insert this node after target node\n                    pos = targetParent.children.indexOf(targetNode);\n                    assert(pos >= 0, \"invalid target parent\");\n                    targetParent.children.splice(pos + 1, 0, this);\n                    break;\n                default:\n                    error(`Invalid mode '${mode}'.`);\n            }\n        }\n        else {\n            targetParent.children = [this];\n        }\n        // Let caller modify the nodes\n        if (map) {\n            targetNode.visit(map, true);\n        }\n        if (targetParent === prevParent) {\n            targetParent.triggerModifyChild(\"move\", this);\n        }\n        else {\n            // prevParent.triggerModifyChild(\"remove\", this);\n            targetParent.triggerModifyChild(\"add\", this);\n        }\n        // Handle cross-tree moves\n        if (tree !== targetNode.tree) {\n            // Fix node.tree for all source nodes\n            // \tutil.assert(false, \"Cross-tree move is not yet implemented.\");\n            this.logWarn(\"Cross-tree moveTo is experimental!\");\n            this.visit(function (n) {\n                // TODO: fix selection state and activation, ...\n                n.tree = targetNode.tree;\n            }, true);\n        }\n        // Make sure we update async, because discarding the markup would prevent\n        // DragAndDrop to generate a dragend event on the source node\n        setTimeout(() => {\n            // Even indentation may have changed:\n            tree.setModified(ChangeType.any);\n        }, 0);\n        // TODO: fix selection state\n        // TODO: fix active state\n    }\n    /** Set focus relative to this node and optionally activate.\n     *\n     * 'left' collapses the node if it is expanded, or move to the parent\n     * otherwise.\n     * 'right' expands the node if it is collapsed, or move to the first\n     * child otherwise.\n     *\n     * @param where 'down', 'first', 'last', 'left', 'parent', 'right', or 'up'.\n     *   (Alternatively the `event.key` that would normally trigger this move,\n     *   e.g. `ArrowLeft` = 'left'.\n     * @param options\n     */\n    async navigate(where, options) {\n        // Allow to pass 'ArrowLeft' instead of 'left'\n        where = KEY_TO_ACTION_DICT[where] || where;\n        // Otherwise activate or focus the related node\n        const node = this.findRelatedNode(where);\n        if (!node) {\n            this.logWarn(`Could not find related node '${where}'.`);\n            return Promise.resolve(this);\n        }\n        // setFocus/setActive will scroll later (if autoScroll is specified)\n        try {\n            node.makeVisible({ scrollIntoView: false });\n        }\n        catch (e) { } // #272\n        node.setFocus();\n        if ((options === null || options === void 0 ? void 0 : options.activate) === false) {\n            return Promise.resolve(this);\n        }\n        return node.setActive(true, { event: options === null || options === void 0 ? void 0 : options.event });\n    }\n    /** Delete this node and all descendants. */\n    remove() {\n        const tree = this.tree;\n        const pos = this.parent.children.indexOf(this);\n        this.triggerModify(\"remove\");\n        this.parent.children.splice(pos, 1);\n        this.visit((n) => {\n            n.removeMarkup();\n            tree._unregisterNode(n);\n        }, true);\n        tree.setModified(ChangeType.structure);\n    }\n    /** Remove all descendants of this node. */\n    removeChildren() {\n        const tree = this.tree;\n        if (!this.children) {\n            return;\n        }\n        if (tree.activeNode && tree.activeNode.isDescendantOf(this)) {\n            tree.activeNode.setActive(false); // TODO: don't fire events\n        }\n        if (tree.focusNode && tree.focusNode.isDescendantOf(this)) {\n            tree.focusNode = null;\n        }\n        // TODO: persist must take care to clear select and expand cookies\n        // Unlink children to support GC\n        // TODO: also delete this.children (not possible using visit())\n        this.triggerModifyChild(\"remove\", null);\n        this.visit((n) => {\n            tree._unregisterNode(n);\n        });\n        if (this.lazy) {\n            // 'undefined' would be interpreted as 'not yet loaded' for lazy nodes\n            this.children = [];\n        }\n        else {\n            this.children = null;\n        }\n        // util.assert(this.parent); // don't call this for root node\n        if (!this.isRootNode()) {\n            this.expanded = false;\n        }\n        this.tree.setModified(ChangeType.structure);\n    }\n    /** Remove all HTML markup from the DOM. */\n    removeMarkup() {\n        if (this._rowElem) {\n            delete this._rowElem._wb_node;\n            this._rowElem.remove();\n            this._rowElem = undefined;\n        }\n    }\n    _getRenderInfo() {\n        const allColInfosById = {};\n        const renderColInfosById = {};\n        const isColspan = this.isColspan();\n        const colElems = this._rowElem\n            ? (this._rowElem.querySelectorAll(\"span.wb-col\"))\n            : null;\n        let idx = 0;\n        for (let col of this.tree.columns) {\n            allColInfosById[col.id] = {\n                id: col.id,\n                idx: idx,\n                elem: colElems ? colElems[idx] : null,\n                info: col,\n            };\n            // renderColInfosById only contains columns that need rendering:\n            if (!isColspan && col.id !== \"*\") {\n                renderColInfosById[col.id] = allColInfosById[col.id];\n            }\n            idx++;\n        }\n        return {\n            allColInfosById: allColInfosById,\n            renderColInfosById: renderColInfosById,\n        };\n    }\n    _createIcon(parentElem, replaceChild, showLoading) {\n        let iconSpan;\n        let icon = this.getOption(\"icon\");\n        if (this._errorInfo) {\n            icon = iconMap.error;\n        }\n        else if (this._isLoading && showLoading) {\n            // Status nodes, or nodes without expander (< minExpandLevel) should\n            // display the 'loading' status with the i.wb-icon span\n            icon = iconMap.loading;\n        }\n        if (icon === false) {\n            return null; // explicitly disabled: don't try default icons\n        }\n        if (typeof icon === \"string\") ;\n        else if (this.statusNodeType) {\n            icon = iconMap[this.statusNodeType];\n        }\n        else if (this.expanded) {\n            icon = iconMap.folderOpen;\n        }\n        else if (this.children) {\n            icon = iconMap.folder;\n        }\n        else if (this.lazy) {\n            icon = iconMap.folderLazy;\n        }\n        else {\n            icon = iconMap.doc;\n        }\n        // this.log(\"_createIcon: \" + icon);\n        if (!icon) {\n            iconSpan = document.createElement(\"i\");\n            iconSpan.className = \"wb-icon\";\n        }\n        else if (icon.indexOf(\"<\") >= 0) {\n            // HTML\n            iconSpan = elemFromHtml(icon);\n        }\n        else if (TEST_IMG.test(icon)) {\n            // Image URL\n            iconSpan = elemFromHtml(`<img src=\"${icon}\" class=\"wb-icon\">`);\n        }\n        else {\n            // Class name\n            iconSpan = document.createElement(\"i\");\n            iconSpan.className = \"wb-icon \" + icon;\n        }\n        if (replaceChild) {\n            parentElem.replaceChild(iconSpan, replaceChild);\n        }\n        else {\n            parentElem.appendChild(iconSpan);\n        }\n        // this.log(\"_createIcon: \", iconSpan);\n        return iconSpan;\n    }\n    /**\n     * Create a whole new `<div class=\"wb-row\">` element.\n     * @see {@link WunderbaumNode.render}\n     */\n    _render_markup(opts) {\n        const tree = this.tree;\n        const treeOptions = tree.options;\n        const checkbox = this.getOption(\"checkbox\") !== false;\n        const columns = tree.columns;\n        const level = this.getLevel();\n        let elem;\n        let nodeElem;\n        let rowDiv = this._rowElem;\n        let titleSpan;\n        let checkboxSpan = null;\n        let iconSpan;\n        let expanderSpan = null;\n        const activeColIdx = tree.isRowNav() ? null : tree.activeColIdx;\n        const isNew = !rowDiv;\n        assert(isNew);\n        assert(!isNew || (opts && opts.after), \"opts.after expected, unless updating\");\n        assert(!this.isRootNode());\n        rowDiv = document.createElement(\"div\");\n        rowDiv.classList.add(\"wb-row\");\n        rowDiv.style.top = this._rowIdx * ROW_HEIGHT + \"px\";\n        this._rowElem = rowDiv;\n        // Attach a node reference to the DOM Element:\n        rowDiv._wb_node = this;\n        nodeElem = document.createElement(\"span\");\n        nodeElem.classList.add(\"wb-node\", \"wb-col\");\n        rowDiv.appendChild(nodeElem);\n        let ofsTitlePx = 0;\n        if (checkbox) {\n            checkboxSpan = document.createElement(\"i\");\n            checkboxSpan.classList.add(\"wb-checkbox\");\n            nodeElem.appendChild(checkboxSpan);\n            ofsTitlePx += ICON_WIDTH;\n        }\n        for (let i = level - 1; i > 0; i--) {\n            elem = document.createElement(\"i\");\n            elem.classList.add(\"wb-indent\");\n            nodeElem.appendChild(elem);\n            ofsTitlePx += ICON_WIDTH;\n        }\n        if (!treeOptions.minExpandLevel || level > treeOptions.minExpandLevel) {\n            expanderSpan = document.createElement(\"i\");\n            expanderSpan.classList.add(\"wb-expander\");\n            nodeElem.appendChild(expanderSpan);\n            ofsTitlePx += ICON_WIDTH;\n        }\n        // Render the icon (show a 'loading' icon if we do not have an expander that\n        // we would prefer).\n        iconSpan = this._createIcon(nodeElem, null, !expanderSpan);\n        if (iconSpan) {\n            ofsTitlePx += ICON_WIDTH;\n        }\n        titleSpan = document.createElement(\"span\");\n        titleSpan.classList.add(\"wb-title\");\n        nodeElem.appendChild(titleSpan);\n        this._callEvent(\"enhanceTitle\", { titleSpan: titleSpan });\n        // Store the width of leading icons with the node, so we can calculate\n        // the width of the embedded title span later\n        nodeElem._ofsTitlePx = ofsTitlePx;\n        // Support HTML5 drag-n-drop\n        if (tree.options.dnd.dragStart) {\n            nodeElem.draggable = true;\n        }\n        // Render columns\n        const isColspan = this.isColspan();\n        if (!isColspan && columns.length > 1) {\n            let colIdx = 0;\n            for (let col of columns) {\n                colIdx++;\n                let colElem;\n                if (col.id === \"*\") {\n                    colElem = nodeElem;\n                }\n                else {\n                    colElem = document.createElement(\"span\");\n                    colElem.classList.add(\"wb-col\");\n                    rowDiv.appendChild(colElem);\n                }\n                if (colIdx === activeColIdx) {\n                    colElem.classList.add(\"wb-active\");\n                }\n                // Add classes from `columns` definition to `<div.wb-col>` cells\n                col.classes ? colElem.classList.add(...col.classes.split(\" \")) : 0;\n                colElem.style.left = col._ofsPx + \"px\";\n                colElem.style.width = col._widthPx + \"px\";\n                if (isNew && col.html) {\n                    if (typeof col.html === \"string\") {\n                        colElem.innerHTML = col.html;\n                    }\n                }\n            }\n        }\n        // Attach to DOM as late as possible\n        const after = opts ? opts.after : \"last\";\n        switch (after) {\n            case \"first\":\n                tree.nodeListElement.prepend(rowDiv);\n                break;\n            case \"last\":\n                tree.nodeListElement.appendChild(rowDiv);\n                break;\n            default:\n                opts.after.after(rowDiv);\n        }\n        // Now go on and fill in data and update classes\n        opts.isNew = true;\n        this._render_data(opts);\n    }\n    /**\n     * Render `node.title`, `.icon` into an existing row.\n     *\n     * @see {@link WunderbaumNode.render}\n     */\n    _render_data(opts) {\n        assert(this._rowElem);\n        const tree = this.tree;\n        const treeOptions = tree.options;\n        const rowDiv = this._rowElem;\n        const isNew = !!opts.isNew; // Called by _render_markup()?\n        const preventScroll = !!opts.preventScroll;\n        const columns = tree.columns;\n        const isColspan = this.isColspan();\n        // Row markup already exists\n        const nodeElem = rowDiv.querySelector(\"span.wb-node\");\n        const titleSpan = nodeElem.querySelector(\"span.wb-title\");\n        const scrollTop = tree.element.scrollTop;\n        if (this.titleWithHighlight) {\n            titleSpan.innerHTML = this.titleWithHighlight;\n        }\n        else {\n            titleSpan.textContent = this.title; // TODO: this triggers scroll events\n        }\n        // NOTE: At least on Safari, this render call triggers a scroll event\n        // probably when a focused input is replaced.\n        if (preventScroll) {\n            tree.element.scrollTop = scrollTop;\n        }\n        // Set the width of the title span, so overflow ellipsis work\n        if (!treeOptions.skeleton) {\n            if (isColspan) {\n                let vpWidth = tree.element.clientWidth;\n                titleSpan.style.width =\n                    vpWidth - nodeElem._ofsTitlePx - TITLE_SPAN_PAD_Y + \"px\";\n            }\n            else {\n                titleSpan.style.width =\n                    columns[0]._widthPx -\n                        nodeElem._ofsTitlePx -\n                        TITLE_SPAN_PAD_Y +\n                        \"px\";\n            }\n        }\n        // Update row classes\n        opts.isDataChange = true;\n        this._render_status(opts);\n        // Let user modify the result\n        if (this.statusNodeType) {\n            this._callEvent(\"renderStatusNode\", {\n                isNew: isNew,\n                nodeElem: nodeElem,\n                isColspan: isColspan,\n            });\n        }\n        else if (this.parent) {\n            // Skip root node\n            const renderInfo = this._getRenderInfo();\n            this._callEvent(\"render\", {\n                isNew: isNew,\n                nodeElem: nodeElem,\n                isColspan: isColspan,\n                allColInfosById: renderInfo.allColInfosById,\n                renderColInfosById: renderInfo.renderColInfosById,\n            });\n        }\n    }\n    /**\n     * Update row classes to reflect active, focuses, etc.\n     * @see {@link WunderbaumNode.render}\n     */\n    _render_status(opts) {\n        // this.log(\"_render_status\", opts);\n        const tree = this.tree;\n        const treeOptions = tree.options;\n        const typeInfo = this.type ? tree.types[this.type] : null;\n        const rowDiv = this._rowElem;\n        // Row markup already exists\n        const nodeElem = rowDiv.querySelector(\"span.wb-node\");\n        const expanderSpan = nodeElem.querySelector(\"i.wb-expander\");\n        const checkboxSpan = nodeElem.querySelector(\"i.wb-checkbox\");\n        let rowClasses = [\"wb-row\"];\n        this.expanded ? rowClasses.push(\"wb-expanded\") : 0;\n        this.lazy ? rowClasses.push(\"wb-lazy\") : 0;\n        this.selected ? rowClasses.push(\"wb-selected\") : 0;\n        this === tree.activeNode ? rowClasses.push(\"wb-active\") : 0;\n        this === tree.focusNode ? rowClasses.push(\"wb-focus\") : 0;\n        this._errorInfo ? rowClasses.push(\"wb-error\") : 0;\n        this._isLoading ? rowClasses.push(\"wb-loading\") : 0;\n        this.isColspan() ? rowClasses.push(\"wb-colspan\") : 0;\n        this.statusNodeType\n            ? rowClasses.push(\"wb-status-\" + this.statusNodeType)\n            : 0;\n        this.match ? rowClasses.push(\"wb-match\") : 0;\n        this.subMatchCount ? rowClasses.push(\"wb-submatch\") : 0;\n        treeOptions.skeleton ? rowClasses.push(\"wb-skeleton\") : 0;\n        // Replace previous classes:\n        rowDiv.className = rowClasses.join(\" \");\n        // Add classes from `node.classes`\n        this.classes ? rowDiv.classList.add(...this.classes) : 0;\n        // Add classes from `tree.types[node.type]`\n        if (typeInfo && typeInfo.classes) {\n            rowDiv.classList.add(...typeInfo.classes);\n        }\n        if (expanderSpan) {\n            if (this._isLoading) {\n                expanderSpan.className = \"wb-expander \" + iconMap.loading;\n            }\n            else if (this.isExpandable(false)) {\n                if (this.expanded) {\n                    expanderSpan.className = \"wb-expander \" + iconMap.expanderExpanded;\n                }\n                else {\n                    expanderSpan.className = \"wb-expander \" + iconMap.expanderCollapsed;\n                }\n            }\n            else if (this.lazy && this.children == null) {\n                expanderSpan.className = \"wb-expander \" + iconMap.expanderLazy;\n            }\n            else {\n                expanderSpan.classList.add(\"wb-indent\");\n            }\n        }\n        if (checkboxSpan) {\n            if (this.selected) {\n                checkboxSpan.className = \"wb-checkbox \" + iconMap.checkChecked;\n            }\n            else {\n                checkboxSpan.className = \"wb-checkbox \" + iconMap.checkUnchecked;\n            }\n        }\n        // Fix active cell in cell-nav mode\n        if (!opts.isNew) {\n            let i = 0;\n            for (let colSpan of rowDiv.children) {\n                colSpan.classList.toggle(\"wb-active\", i++ === tree.activeColIdx);\n            }\n            // Update icon (if not opts.isNew, which would rebuild markup anyway)\n            const iconSpan = nodeElem.querySelector(\"i.wb-icon\");\n            if (iconSpan) {\n                this._createIcon(nodeElem, iconSpan, !expanderSpan);\n            }\n        }\n        // Adjust column width\n        if (opts.resizeCols !== false && !this.isColspan()) {\n            const colElems = rowDiv.querySelectorAll(\"span.wb-col\");\n            let idx = 0;\n            let ofs = 0;\n            for (let colDef of this.tree.columns) {\n                const colElem = colElems[idx];\n                colElem.style.left = `${ofs}px`;\n                colElem.style.width = `${colDef._widthPx}px`;\n                idx++;\n                ofs += colDef._widthPx;\n            }\n        }\n    }\n    /**\n     * Create or update node's markup.\n     *\n     * `options.change` defaults to ChangeType.data, which updates the title,\n     * icon, and status. It also triggers the `render` event, that lets the user\n     * create or update the content of embeded cell elements.\n     *\n     * If only the status or other class-only modifications have changed,\n     * `options.change` should be set to ChangeType.status instead for best\n     * efficiency.\n     *\n     * Calling `setModified` instead may be a better alternative.\n     * @see {@link WunderbaumNode.setModified}\n     */\n    render(options) {\n        // this.log(\"render\", options);\n        const opts = Object.assign({ change: ChangeType.data }, options);\n        if (!this._rowElem) {\n            opts.change = ChangeType.row;\n        }\n        switch (opts.change) {\n            case \"status\":\n                this._render_status(opts);\n                break;\n            case \"data\":\n                this._render_data(opts);\n                break;\n            case \"row\":\n                // _rowElem is not yet created (asserted in _render_markup)\n                this._render_markup(opts);\n                break;\n            default:\n                error(`Invalid change type '${opts.change}'.`);\n        }\n    }\n    /**\n     * Remove all children, collapse, and set the lazy-flag, so that the lazyLoad\n     * event is triggered on next expand.\n     */\n    resetLazy() {\n        this.removeChildren();\n        this.expanded = false;\n        this.lazy = true;\n        this.children = null;\n        this.tree.setModified(ChangeType.structure);\n    }\n    /** Convert node (or whole branch) into a plain object.\n     *\n     * The result is compatible with node.addChildren().\n     *\n     * @param include child nodes\n     * @param callback(dict, node) is called for every node, in order to allow\n     *     modifications.\n     *     Return `false` to ignore this node or `\"skip\"` to include this node\n     *     without its children.\n     * @see {@link Wunderbaum.toDictArray}.\n     */\n    toDict(recursive = false, callback) {\n        const dict = {};\n        NODE_ATTRS.forEach((propName) => {\n            const val = this[propName];\n            if (val instanceof Set) {\n                // Convert Set to string (or skip if set is empty)\n                val.size\n                    ? (dict[propName] = Array.prototype.join.call(val.keys(), \" \"))\n                    : 0;\n            }\n            else if (val || val === false || val === 0) {\n                dict[propName] = val;\n            }\n        });\n        if (!isEmptyObject(this.data)) {\n            dict.data = extend({}, this.data);\n            if (isEmptyObject(dict.data)) {\n                delete dict.data;\n            }\n        }\n        if (callback) {\n            const res = callback(dict, this);\n            if (res === false) {\n                // Note: a return value of `false` is only used internally\n                return false; // Don't include this node nor its children\n            }\n            if (res === \"skip\") {\n                recursive = false; // Include this node, but not the children\n            }\n        }\n        if (recursive) {\n            if (isArray(this.children)) {\n                dict.children = [];\n                for (let i = 0, l = this.children.length; i < l; i++) {\n                    const node = this.children[i];\n                    if (!node.isStatusNode()) {\n                        // Note: a return value of `false` is only used internally\n                        const res = node.toDict(true, callback);\n                        if (res !== false) {\n                            dict.children.push(res);\n                        }\n                    }\n                }\n            }\n        }\n        return dict;\n    }\n    /** Return an option value that has a default, but may be overridden by a\n     * callback or a node instance attribute.\n     *\n     * Evaluation sequence:\n     *\n     * - If `tree.options.<name>` is a callback that returns something, use that.\n     * - Else if `node.<name>` is defined, use that.\n     * - Else if `tree.types[<node.type>]` is a value, use that.\n     * - Else if `tree.options.<name>` is a value, use that.\n     * - Else use `defaultValue`.\n     *\n     * @param name name of the option property (on node and tree)\n     * @param defaultValue return this if nothing else matched\n     * {@link Wunderbaum.getOption|Wunderbaum.getOption()}\n     */\n    getOption(name, defaultValue) {\n        let tree = this.tree;\n        let opts = tree.options;\n        // Lookup `name` in options dict\n        if (name.indexOf(\".\") >= 0) {\n            [opts, name] = name.split(\".\");\n        }\n        let value = opts[name]; // ?? defaultValue;\n        // A callback resolver always takes precedence\n        if (typeof value === \"function\") {\n            let res = value.call(tree, {\n                type: \"resolve\",\n                tree: tree,\n                node: this,\n                // typeInfo: this.type ? tree.types[this.type] : {},\n            });\n            if (res !== undefined) {\n                return res;\n            }\n        }\n        // If this node has an explicit local setting, use it:\n        if (this[name] !== undefined) {\n            return this[name];\n        }\n        // Use value from type definition if defined\n        let typeInfo = this.type ? tree.types[this.type] : undefined;\n        let res = typeInfo ? typeInfo[name] : undefined;\n        if (res !== undefined) {\n            return res;\n        }\n        // Use value from value options dict, fallback do default\n        return value !== null && value !== void 0 ? value : defaultValue;\n    }\n    /** Make sure that this node is visible in the viewport.\n     * @see {@link Wunderbaum.scrollTo|Wunderbaum.scrollTo()}\n     */\n    async scrollIntoView(options) {\n        const opts = Object.assign({ node: this }, options);\n        return this.tree.scrollTo(opts);\n    }\n    /**\n     * Activate this node, deactivate previous, send events, activate column and scroll int viewport.\n     */\n    async setActive(flag = true, options) {\n        const tree = this.tree;\n        const prev = tree.activeNode;\n        const retrigger = options === null || options === void 0 ? void 0 : options.retrigger; // Default: false\n        const focusTree = options === null || options === void 0 ? void 0 : options.focusTree; // Default: false\n        const focusNode = (options === null || options === void 0 ? void 0 : options.focusNode) !== false; // Default: true\n        const noEvents = options === null || options === void 0 ? void 0 : options.noEvents; // Default: false\n        const orgEvent = options === null || options === void 0 ? void 0 : options.event; // Default: false\n        if (!noEvents) {\n            if (flag) {\n                if (prev !== this || retrigger) {\n                    if ((prev === null || prev === void 0 ? void 0 : prev._callEvent(\"deactivate\", {\n                        nextNode: this,\n                        event: orgEvent,\n                    })) === false ||\n                        this._callEvent(\"beforeActivate\", {\n                            prevNode: prev,\n                            event: orgEvent,\n                        }) === false) {\n                        return;\n                    }\n                    tree.activeNode = null;\n                    prev === null || prev === void 0 ? void 0 : prev.setModified(ChangeType.status);\n                }\n            }\n            else if (prev === this || retrigger) {\n                this._callEvent(\"deactivate\", { nextNode: null, event: orgEvent });\n            }\n        }\n        if (prev !== this) {\n            if (flag) {\n                tree.activeNode = this;\n                if (focusNode || focusTree)\n                    tree.focusNode = this;\n                if (focusTree)\n                    tree.setFocus();\n            }\n            prev === null || prev === void 0 ? void 0 : prev.setModified(ChangeType.status);\n            this.setModified(ChangeType.status);\n        }\n        if (options &&\n            options.colIdx != null &&\n            options.colIdx !== tree.activeColIdx &&\n            tree.isCellNav()) {\n            tree.setColumn(options.colIdx);\n        }\n        if (flag && !noEvents) {\n            this._callEvent(\"activate\", { prevNode: prev, event: orgEvent });\n        }\n        return this.makeVisible();\n    }\n    /**\n     * Expand or collapse this node.\n     */\n    async setExpanded(flag = true, options) {\n        const { force, scrollIntoView, immediate } = options !== null && options !== void 0 ? options : {};\n        if (!flag &&\n            this.isExpanded() &&\n            this.getLevel() <= this.tree.getOption(\"minExpandLevel\") &&\n            !force) {\n            this.logDebug(\"Ignored collapse request below expandLevel.\");\n            return;\n        }\n        if (!flag === !this.expanded) {\n            return; // Nothing to do\n        }\n        // this.log(\"setExpanded()\");\n        if (flag && this.lazy && this.children == null) {\n            await this.loadLazy();\n        }\n        this.expanded = flag;\n        const updateOpts = { immediate: immediate };\n        // const updateOpts = { immediate: !!util.getOption(options, \"immediate\") };\n        this.tree.setModified(ChangeType.structure, updateOpts);\n        if (flag && scrollIntoView !== false) {\n            const lastChild = this.getLastChild();\n            if (lastChild) {\n                this.tree.updatePendingModifications();\n                lastChild.scrollIntoView({ topNode: this });\n            }\n        }\n    }\n    /**\n     * Set keyboard focus here.\n     * @see {@link setActive}\n     */\n    setFocus(flag = true) {\n        assert(!!flag, \"blur is not yet implemented\");\n        const prev = this.tree.focusNode;\n        this.tree.focusNode = this;\n        prev === null || prev === void 0 ? void 0 : prev.setModified();\n        this.setModified();\n    }\n    /** Set a new icon path or class. */\n    setIcon(icon) {\n        this.icon = icon;\n        this.setModified();\n    }\n    /** Change node's {@link key} and/or {@link refKey}.  */\n    setKey(key, refKey) {\n        throw new Error(\"Not yet implemented\");\n    }\n    /**\n     * Trigger a repaint, typically after a status or data change.\n     *\n     * `change` defaults to 'data', which handles modifcations of title, icon,\n     * and column content. It can be reduced to 'ChangeType.status' if only\n     * active/focus/selected state has changed.\n     *\n     * This method will eventually call  {@link WunderbaumNode.render()} with\n     * default options, but may be more consistent with the tree's\n     * {@link Wunderbaum.setModified()} API.\n     */\n    setModified(change = ChangeType.data) {\n        assert(change === ChangeType.status || change === ChangeType.data);\n        this.tree.setModified(change, this);\n    }\n    /** Modify the check/uncheck state. */\n    setSelected(flag = true, options) {\n        const prev = this.selected;\n        if (!!flag !== prev) {\n            this._callEvent(\"select\", { flag: flag });\n        }\n        this.selected = !!flag;\n        this.setModified();\n    }\n    /** Display node status (ok, loading, error, noData) using styles and a dummy child node. */\n    setStatus(status, options) {\n        const tree = this.tree;\n        const message = options === null || options === void 0 ? void 0 : options.message;\n        const details = options === null || options === void 0 ? void 0 : options.details;\n        let statusNode = null;\n        const _clearStatusNode = () => {\n            // Remove dedicated dummy node, if any\n            let children = this.children;\n            if (children && children.length && children[0].isStatusNode()) {\n                children[0].remove();\n            }\n        };\n        const _setStatusNode = (data) => {\n            // Create/modify the dedicated dummy node for 'loading...' or\n            // 'error!' status. (only called for direct child of the invisible\n            // system root)\n            let children = this.children;\n            let firstChild = children ? children[0] : null;\n            assert(data.statusNodeType);\n            assert(!firstChild || !firstChild.isStatusNode());\n            statusNode = this.addNode(data, \"prependChild\");\n            statusNode.match = true;\n            tree.setModified(ChangeType.structure);\n            return statusNode;\n        };\n        _clearStatusNode();\n        switch (status) {\n            case \"ok\":\n                this._isLoading = false;\n                this._errorInfo = null;\n                break;\n            case \"loading\":\n                this._isLoading = true;\n                this._errorInfo = null;\n                if (this.parent) {\n                    this.setModified(ChangeType.status);\n                }\n                else {\n                    // If this is the invisible root, add a visible top-level node\n                    _setStatusNode({\n                        statusNodeType: status,\n                        title: tree.options.strings.loading +\n                            (message ? \" (\" + message + \")\" : \"\"),\n                        checkbox: false,\n                        colspan: true,\n                        tooltip: details,\n                    });\n                }\n                // this.render();\n                break;\n            case \"error\":\n                _setStatusNode({\n                    statusNodeType: status,\n                    title: tree.options.strings.loadError +\n                        (message ? \" (\" + message + \")\" : \"\"),\n                    checkbox: false,\n                    colspan: true,\n                    // classes: \"wb-center\",\n                    tooltip: details,\n                });\n                this._isLoading = false;\n                this._errorInfo = { message: message, details: details };\n                break;\n            case \"noData\":\n                _setStatusNode({\n                    statusNodeType: status,\n                    title: message || tree.options.strings.noData,\n                    checkbox: false,\n                    colspan: true,\n                    tooltip: details,\n                });\n                this._isLoading = false;\n                this._errorInfo = null;\n                break;\n            default:\n                error(\"invalid node status \" + status);\n        }\n        tree.setModified(ChangeType.structure);\n        return statusNode;\n    }\n    /** Rename this node. */\n    setTitle(title) {\n        this.title = title;\n        this.setModified();\n        // this.triggerModify(\"rename\"); // TODO\n    }\n    _sortChildren(cmp, deep) {\n        const cl = this.children;\n        if (!cl) {\n            return;\n        }\n        cl.sort(cmp);\n        if (deep) {\n            for (let i = 0, l = cl.length; i < l; i++) {\n                if (cl[i].children) {\n                    cl[i]._sortChildren(cmp, deep);\n                }\n            }\n        }\n    }\n    /**\n     * Sort child list by title or custom criteria.\n     * @param {function} cmp custom compare function(a, b) that returns -1, 0, or 1\n     *    (defaults to sorting by title).\n     * @param {boolean} deep pass true to sort all descendant nodes recursively\n     */\n    sortChildren(cmp = nodeTitleSorter, deep = false) {\n        this._sortChildren(cmp || nodeTitleSorter, deep);\n        this.tree.setModified(ChangeType.structure);\n        // this.triggerModify(\"sort\"); // TODO\n    }\n    /**\n     * Trigger `modifyChild` event on a parent to signal that a child was modified.\n     * @param {string} operation Type of change: 'add', 'remove', 'rename', 'move', 'data', ...\n     */\n    triggerModifyChild(operation, child, extra) {\n        this.logDebug(`modifyChild(${operation})`, extra, child);\n        if (!this.tree.options.modifyChild)\n            return;\n        if (child && child.parent !== this) {\n            error(\"child \" + child + \" is not a child of \" + this);\n        }\n        this._callEvent(\"modifyChild\", extend({ operation: operation, child: child }, extra));\n    }\n    /**\n     * Trigger `modifyChild` event on node.parent(!).\n     * @param {string} operation Type of change: 'add', 'remove', 'rename', 'move', 'data', ...\n     * @param {object} [extra]\n     */\n    triggerModify(operation, extra) {\n        // if (!this.parent) {\n        //   return;\n        // }\n        this.parent.triggerModifyChild(operation, this, extra);\n    }\n    /**\n     * Call `callback(node)` for all child nodes in hierarchical order (depth-first, pre-order).\n     *\n     * Stop iteration, if fn() returns false. Skip current branch, if fn()\n     * returns \"skip\".<br>\n     * Return false if iteration was stopped.\n     *\n     * @param {function} callback the callback function.\n     *     Return false to stop iteration, return \"skip\" to skip this node and\n     *     its children only.\n     * @see {@link IterableIterator<WunderbaumNode>}, {@link Wunderbaum.visit}.\n     */\n    visit(callback, includeSelf = false) {\n        let i, l, res = true, children = this.children;\n        if (includeSelf === true) {\n            res = callback(this);\n            if (res === false || res === \"skip\") {\n                return res;\n            }\n        }\n        if (children) {\n            for (i = 0, l = children.length; i < l; i++) {\n                res = children[i].visit(callback, true);\n                if (res === false) {\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n    /** Call fn(node) for all parent nodes, bottom-up, including invisible system root.<br>\n     * Stop iteration, if callback() returns false.<br>\n     * Return false if iteration was stopped.\n     *\n     * @param callback the callback function. Return false to stop iteration\n     */\n    visitParents(callback, includeSelf = false) {\n        if (includeSelf && callback(this) === false) {\n            return false;\n        }\n        let p = this.parent;\n        while (p) {\n            if (callback(p) === false) {\n                return false;\n            }\n            p = p.parent;\n        }\n        return true;\n    }\n    /**\n     * Call fn(node) for all sibling nodes.<br>\n     * Stop iteration, if fn() returns false.<br>\n     * Return false if iteration was stopped.\n     *\n     * @param {function} fn the callback function.\n     *     Return false to stop iteration.\n     */\n    visitSiblings(callback, includeSelf = false) {\n        let i, l, n, ac = this.parent.children;\n        for (i = 0, l = ac.length; i < l; i++) {\n            n = ac[i];\n            if (includeSelf || n !== this) {\n                if (callback(n) === false) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * [ext-filter] Return true if this node is matched by current filter (or no filter is active).\n     */\n    isMatched() {\n        return !(this.tree.filterMode && !this.match);\n    }\n}\nWunderbaumNode.sequence = 0;\n\n/*!\n * Wunderbaum - ext-edit\n * Copyright (c) 2021-2023, Martin Wendt. Released under the MIT license.\n * v0.3.5, Mon, 19 Jun 2023 06:20:59 GMT (https://github.com/mar10/wunderbaum)\n */\n// const START_MARKER = \"\\uFFF7\";\nclass EditExtension extends WunderbaumExtension {\n    constructor(tree) {\n        super(tree, \"edit\", {\n            debounce: 100,\n            minlength: 1,\n            maxlength: null,\n            trigger: [],\n            trim: true,\n            select: true,\n            slowClickDelay: 1000,\n            validity: true,\n            // --- Events ---\n            // (note: there is also the `tree.change` event.)\n            beforeEdit: null,\n            edit: null,\n            apply: null,\n        });\n        this.curEditNode = null;\n        this.relatedNode = null;\n        this.debouncedOnChange = debounce(this._onChange.bind(this), this.getPluginOption(\"debounce\"));\n    }\n    /*\n     * Call an event handler, while marking the current node cell 'dirty'.\n     */\n    _applyChange(eventName, node, colElem, extra) {\n        let res;\n        node.log(`_applyChange(${eventName})`, extra);\n        colElem.classList.add(\"wb-busy\");\n        colElem.classList.remove(\"wb-error\");\n        try {\n            res = node._callEvent(eventName, extra);\n        }\n        catch (err) {\n            node.logError(`Error in ${eventName} event handler`, err);\n            colElem.classList.add(\"wb-error\");\n            colElem.classList.remove(\"wb-busy\");\n        }\n        // Convert scalar return value to a resolved promise\n        if (!(res instanceof Promise)) {\n            res = Promise.resolve(res);\n        }\n        res\n            .catch((err) => {\n            node.logError(`Error in ${eventName} event promise`, err);\n            colElem.classList.add(\"wb-error\");\n        })\n            .finally(() => {\n            colElem.classList.remove(\"wb-busy\");\n        });\n        return res;\n    }\n    /*\n     * Called for when a control that is embedded in a cell fires a `change` event.\n     */\n    _onChange(e) {\n        // let res;\n        const info = Wunderbaum.getEventInfo(e);\n        const node = info.node;\n        const colElem = info.colElem;\n        if (!node || info.colIdx === 0) {\n            this.tree.log(\"Ignored change event for removed element or node title\");\n            return;\n        }\n        this._applyChange(\"change\", node, colElem, {\n            info: info,\n            event: e,\n            inputElem: e.target,\n            inputValue: Wunderbaum.util.getValueFromElem(e.target),\n        });\n    }\n    // handleKey(e:KeyboardEvent):boolean {\n    //   if(this.tree.cellNavMode )\n    // }\n    init() {\n        super.init();\n        onEvent(this.tree.element, \"change\", //\"change input\",\n        \".contenteditable,input,textarea,select\", (e) => {\n            this.debouncedOnChange(e);\n        });\n    }\n    /* Called by ext_keynav to pre-process input. */\n    _preprocessKeyEvent(data) {\n        const event = data.event;\n        const eventName = eventToString(event);\n        const tree = this.tree;\n        const trigger = this.getPluginOption(\"trigger\");\n        // const inputElem =\n        //   event.target && event.target.closest(\"input,[contenteditable]\");\n        // tree.logDebug(`_preprocessKeyEvent: ${eventName}, editing:${this.isEditingTitle()}`);\n        // --- Title editing: apply/discard ---\n        // if (inputElem) {\n        if (this.isEditingTitle()) {\n            switch (eventName) {\n                case \"Enter\":\n                    this._stopEditTitle(true, { event: event });\n                    return false;\n                case \"Escape\":\n                    this._stopEditTitle(false, { event: event });\n                    return false;\n            }\n            // If the event target is an input element or `contenteditable=\"true\"`,\n            // we ignore it as navigation command\n            return false;\n        }\n        // --- Trigger title editing\n        if (tree.isRowNav() || tree.activeColIdx === 0) {\n            switch (eventName) {\n                case \"Enter\":\n                    if (trigger.indexOf(\"macEnter\") >= 0 && isMac) {\n                        this.startEditTitle();\n                        return false;\n                    }\n                    break;\n                case \"F2\":\n                    if (trigger.indexOf(\"F2\") >= 0) {\n                        // tree.setNavigationMode(NavigationMode.cellEdit);\n                        this.startEditTitle();\n                        return false;\n                    }\n                    break;\n            }\n            return true;\n        }\n        return true;\n    }\n    /** Return true if a title is currently being edited. */\n    isEditingTitle(node) {\n        return node ? this.curEditNode === node : !!this.curEditNode;\n    }\n    /** Start renaming, i.e. replace the title with an embedded `<input>`. */\n    startEditTitle(node) {\n        node = node !== null && node !== void 0 ? node : this.tree.getActiveNode();\n        const validity = this.getPluginOption(\"validity\");\n        const select = this.getPluginOption(\"select\");\n        if (!node) {\n            return;\n        }\n        this.tree.logDebug(`startEditTitle(node=${node})`);\n        let inputHtml = node._callEvent(\"edit.beforeEdit\");\n        if (inputHtml === false) {\n            node.logInfo(\"beforeEdit canceled operation.\");\n            return;\n        }\n        // `beforeEdit(e)` may return an input HTML string. Otherwise use a default.\n        // (we also treat a `true` return value as 'use default'):\n        if (inputHtml === true || !inputHtml) {\n            const title = escapeHtml(node.title);\n            inputHtml = `<input type=text class=\"wb-input-edit\" tabindex=-1 value=\"${title}\" required autocorrect=off>`;\n        }\n        const titleSpan = node\n            .getColElem(0)\n            .querySelector(\".wb-title\");\n        titleSpan.innerHTML = inputHtml;\n        const inputElem = titleSpan.firstElementChild;\n        if (validity) {\n            // Permanently apply input validations (CSS and tooltip)\n            inputElem.addEventListener(\"keydown\", (e) => {\n                inputElem.setCustomValidity(\"\");\n                if (!inputElem.reportValidity()) ;\n            });\n        }\n        inputElem.focus();\n        if (select) {\n            inputElem.select();\n        }\n        this.curEditNode = node;\n        node._callEvent(\"edit.edit\", {\n            inputElem: inputElem,\n        });\n    }\n    /**\n     *\n     * @param apply\n     * @returns\n     */\n    stopEditTitle(apply) {\n        return this._stopEditTitle(apply, {});\n    }\n    /*\n     *\n     * @param apply\n     * @param opts.canKeepOpen\n     */\n    _stopEditTitle(apply, options) {\n        options !== null && options !== void 0 ? options : (options = {});\n        const focusElem = document.activeElement;\n        let newValue = focusElem ? getValueFromElem(focusElem) : null;\n        const node = this.curEditNode;\n        const forceClose = !!options.forceClose;\n        const validity = this.getPluginOption(\"validity\");\n        if (newValue && this.getPluginOption(\"trim\")) {\n            newValue = newValue.trim();\n        }\n        if (!node) {\n            this.tree.logDebug(\"stopEditTitle: not in edit mode.\");\n            return;\n        }\n        node.logDebug(`stopEditTitle(${apply})`, options, focusElem, newValue);\n        if (apply && newValue !== null && newValue !== node.title) {\n            const errMsg = focusElem.validationMessage;\n            if (errMsg) {\n                // input element's native validation failed\n                throw new Error(`Input validation failed for \"${newValue}\": ${errMsg}.`);\n            }\n            const colElem = node.getColElem(0);\n            this._applyChange(\"edit.apply\", node, colElem, {\n                oldValue: node.title,\n                newValue: newValue,\n                inputElem: focusElem,\n            })\n                .then((value) => {\n                const errMsg = focusElem.validationMessage;\n                if (validity && errMsg && value !== false) {\n                    // Handler called 'inputElem.setCustomValidity()' to signal error\n                    throw new Error(`Edit apply validation failed for \"${newValue}\": ${errMsg}.`);\n                }\n                // Discard the embedded `<input>`\n                // node.logDebug(\"applyChange:\", value, forceClose)\n                if (!forceClose && value === false) {\n                    // Keep open\n                    return;\n                }\n                node === null || node === void 0 ? void 0 : node.setTitle(newValue);\n                // NOTE: At least on Safari, this render call triggers a scroll event\n                // probably because the focused input is replaced.\n                if (this.curEditNode){\n                    this.curEditNode.render({ preventScroll: true });\n                    this.curEditNode = null;\n                }\n                this.relatedNode = null;\n                this.tree.setFocus(); // restore focus that was in the input element\n            })\n                .catch((err) => {\n                node.logError(err);\n            });\n            // Trigger 'change' event for embedded `<input>`\n            // focusElem.blur();\n        }\n        else {\n            // Discard the embedded `<input>`\n            // NOTE: At least on Safari, this render call triggers a scroll event\n            // probably because the focused input is replaced.\n            this.curEditNode.render({ preventScroll: true });\n            this.curEditNode = null;\n            this.relatedNode = null;\n            // We discarded the <input>, so we have to acquire keyboard focus again\n            this.tree.setFocus();\n        }\n    }\n    /**\n     * Create a new child or sibling node and start edit mode.\n     */\n    createNode(mode = \"after\", node, init) {\n        const tree = this.tree;\n        node = node !== null && node !== void 0 ? node : tree.getActiveNode();\n        assert(node, \"No node was passed, or no node is currently active.\");\n        // const validity = this.getPluginOption(\"validity\");\n        mode = mode || \"prependChild\";\n        if (init == null) {\n            init = { title: \"\" };\n        }\n        else if (typeof init === \"string\") {\n            init = { title: init };\n        }\n        else {\n            assert(isPlainObject(init));\n        }\n        // Make sure node is expanded (and loaded) in 'child' mode\n        if ((mode === \"prependChild\" || mode === \"appendChild\") &&\n            (node === null || node === void 0 ? void 0 : node.isExpandable(true))) {\n            node.setExpanded().then(() => {\n                this.createNode(mode, node, init);\n            });\n            return;\n        }\n        const newNode = node.addNode(init, mode);\n        newNode.setClass(\"wb-edit-new\");\n        this.relatedNode = node;\n        // Don't filter new nodes:\n        newNode.match = true;\n        newNode.makeVisible({ noAnimation: true }).then(() => {\n            this.startEditTitle(newNode);\n        });\n    }\n}\n\n/*!\n * wunderbaum.ts\n *\n * A treegrid control.\n *\n * Copyright (c) 2021-2023, Martin Wendt (https://wwWendt.de).\n * https://github.com/mar10/wunderbaum\n *\n * Released under the MIT license.\n * @version v0.3.5\n * @date Mon, 19 Jun 2023 06:20:59 GMT\n */\nclass WbSystemRoot extends WunderbaumNode {\n    constructor(tree) {\n        super(tree, null, {\n            key: \"__root__\",\n            title: tree.id,\n        });\n    }\n    toString() {\n        return `WbSystemRoot@${this.key}<'${this.tree.id}'>`;\n    }\n}\n/**\n * A persistent plain object or array.\n *\n * See also [[WunderbaumOptions]].\n */\nclass Wunderbaum {\n    constructor(options) {\n        this.enabled = true;\n        /** Contains additional data that was sent as response to an Ajax source load request. */\n        this.data = {};\n        this.extensionList = [];\n        this.extensions = {};\n        this.keyMap = new Map();\n        this.refKeyMap = new Map();\n        this.treeRowCount = 0;\n        this._disableUpdateCount = 0;\n        this._disableUpdateIgnoreCount = 0;\n        /** Currently active node if any. */\n        this.activeNode = null;\n        /** Current node hat has keyboard focus if any. */\n        this.focusNode = null;\n        /** Shared properties, referenced by `node.type`. */\n        this.types = {};\n        /** List of column definitions. */\n        this.columns = []; // any[] = [];\n        this._columnsById = {};\n        // Modification Status\n        this.pendingChangeTypes = new Set();\n        /** Expose some useful methods of the util.ts module as `tree._util`. */\n        this._util = util;\n        // --- FILTER ---\n        this.filterMode = null;\n        // --- KEYNAV ---\n        /** @internal Use `setColumn()`/`getActiveColElem()`*/\n        this.activeColIdx = 0;\n        /** @internal */\n        this._cellNavMode = false;\n        /** @internal */\n        this.lastQuicksearchTime = 0;\n        /** @internal */\n        this.lastQuicksearchTerm = \"\";\n        // --- EDIT ---\n        this.lastClickTime = 0;\n        /** Alias for {@link Wunderbaum.logDebug}.\n         * @alias Wunderbaum.logDebug\n         */\n        this.log = this.logDebug;\n        let opts = (this.options = extend({\n            id: null,\n            source: null,\n            element: null,\n            debugLevel: DEFAULT_DEBUGLEVEL,\n            header: null,\n            // headerHeightPx: ROW_HEIGHT,\n            rowHeightPx: ROW_HEIGHT,\n            columns: null,\n            types: null,\n            // escapeTitles: true,\n            enabled: true,\n            fixedCol: false,\n            showSpinner: false,\n            checkbox: false,\n            minExpandLevel: 0,\n            emptyChildListExpandable: false,\n            updateThrottleWait: 200,\n            skeleton: false,\n            connectTopBreadcrumb: null,\n            // --- KeyNav ---\n            navigationModeOption: null,\n            quicksearch: true,\n            // --- Events ---\n            change: noop,\n            enhanceTitle: noop,\n            error: noop,\n            receive: noop,\n            // --- Strings ---\n            strings: {\n                loadError: \"Error\",\n                loading: \"Loading...\",\n                // loading: \"Loading&hellip;\",\n                noData: \"No data\",\n            },\n        }, options));\n        const readyDeferred = new Deferred();\n        this.ready = readyDeferred.promise();\n        let readyOk = false;\n        this.ready\n            .then(() => {\n            readyOk = true;\n            try {\n                this._callEvent(\"init\");\n            }\n            catch (error) {\n                // We re-raise in the reject handler, but Chrome resets the stack\n                // frame then, so we log it here:\n                console.error(\"Exception inside `init(e)` event:\", error);\n            }\n        })\n            .catch((err) => {\n            if (readyOk) {\n                // Error occurred in `init` handler. We can re-raise, but Chrome\n                // resets the stack frame.\n                throw err;\n            }\n            else {\n                // Error in load process\n                this._callEvent(\"init\", { error: err });\n            }\n        });\n        this.id = opts.id || \"wb_\" + ++Wunderbaum.sequence;\n        this.root = new WbSystemRoot(this);\n        this._registerExtension(new KeynavExtension(this));\n        this._registerExtension(new EditExtension(this));\n        this._registerExtension(new FilterExtension(this));\n        this._registerExtension(new DndExtension(this));\n        this._registerExtension(new GridExtension(this));\n        this._registerExtension(new LoggerExtension(this));\n        this._updateViewportThrottled = adaptiveThrottle(this._updateViewportImmediately.bind(this), {});\n        // --- Evaluate options\n        this.columns = opts.columns;\n        delete opts.columns;\n        if (!this.columns || !this.columns.length) {\n            const title = typeof opts.header === \"string\" ? opts.header : this.id;\n            this.columns = [{ id: \"*\", title: title, width: \"*\" }];\n        }\n        if (opts.types) {\n            this.setTypes(opts.types, true);\n        }\n        delete opts.types;\n        // --- Create Markup\n        this.element = elemFromSelector(opts.element);\n        assert(!!this.element, `Invalid 'element' option: ${opts.element}`);\n        this.element.classList.add(\"wunderbaum\");\n        if (!this.element.getAttribute(\"tabindex\")) {\n            this.element.tabIndex = 0;\n        }\n        // Attach tree instance to <div>\n        this.element._wb_tree = this;\n        // Create header markup, or take it from the existing html\n        this.headerElement = this.element.querySelector(\"div.wb-header\");\n        const wantHeader = opts.header == null ? this.columns.length > 1 : !!opts.header;\n        if (this.headerElement) {\n            // User existing header markup to define `this.columns`\n            assert(!this.columns, \"`opts.columns` must not be set if markup already contains a header\");\n            this.columns = [];\n            const rowElement = this.headerElement.querySelector(\"div.wb-row\");\n            for (const colDiv of rowElement.querySelectorAll(\"div\")) {\n                this.columns.push({\n                    id: colDiv.dataset.id || `col_${this.columns.length}`,\n                    // id: colDiv.dataset.id || null,\n                    title: \"\" + colDiv.textContent,\n                    // text: \"\" + colDiv.textContent,\n                    width: \"*\", // TODO: read from header span\n                });\n            }\n        }\n        else {\n            // We need a row div, the rest will be computed from `this.columns`\n            const coldivs = \"<span class='wb-col'></span>\".repeat(this.columns.length);\n            this.element.innerHTML = `\n        <div class='wb-header'>\n          <div class='wb-row'>\n            ${coldivs}\n          </div>\n        </div>`;\n            if (!wantHeader) {\n                const he = this.element.querySelector(\"div.wb-header\");\n                he.style.display = \"none\";\n            }\n        }\n        //\n        this.element.innerHTML += `\n      <div class=\"wb-list-container\">\n        <div class=\"wb-node-list\"></div>\n      </div>`;\n        this.listContainerElement = this.element.querySelector(\"div.wb-list-container\");\n        this.nodeListElement = this.listContainerElement.querySelector(\"div.wb-node-list\");\n        this.headerElement = this.element.querySelector(\"div.wb-header\");\n        this.element.classList.toggle(\"wb-grid\", this.columns.length > 1);\n        this._initExtensions();\n        // --- apply initial options\n        [\"enabled\", \"fixedCol\"].forEach((optName) => {\n            if (opts[optName] != null) {\n                this.setOption(optName, opts[optName]);\n            }\n        });\n        // --- Load initial data\n        if (opts.source) {\n            if (opts.showSpinner) {\n                this.nodeListElement.innerHTML =\n                    \"<progress class='spinner'>loading...</progress>\";\n            }\n            this.load(opts.source)\n                .then(() => {\n                // The source may have defined columns, so we may adjust the nav mode\n                if (opts.navigationModeOption == null) {\n                    if (this.isGrid()) {\n                        this.setNavigationOption(NavModeEnum.cell);\n                    }\n                    else {\n                        this.setNavigationOption(NavModeEnum.row);\n                    }\n                }\n                else {\n                    this.setNavigationOption(opts.navigationModeOption);\n                }\n                readyDeferred.resolve();\n            })\n                .catch((error) => {\n                readyDeferred.reject(error);\n            })\n                .finally(() => {\n                var _a;\n                (_a = this.element.querySelector(\"progress.spinner\")) === null || _a === void 0 ? void 0 : _a.remove();\n                this.element.classList.remove(\"wb-initializing\");\n            });\n        }\n        else {\n            readyDeferred.resolve();\n        }\n        // Async mode is sometimes required, because this.element.clientWidth\n        // has a wrong value at start???\n        this.setModified(ChangeType.any);\n        // --- Bind listeners\n        this.element.addEventListener(\"scroll\", (e) => {\n            // this.log(`scroll, scrollTop:${e.target.scrollTop}`, e);\n            this.setModified(ChangeType.scroll);\n        });\n        this.resizeObserver = new ResizeObserver((entries) => {\n            // this.log(\"ResizeObserver: Size changed\", entries);\n            this.setModified(ChangeType.resize);\n        });\n        this.resizeObserver.observe(this.element);\n        onEvent(this.nodeListElement, \"click\", \"div.wb-row\", (e) => {\n            const info = Wunderbaum.getEventInfo(e);\n            const node = info.node;\n            // this.log(\"click\", info, e);\n            if (this._callEvent(\"click\", { event: e, node: node, info: info }) === false) {\n                this.lastClickTime = Date.now();\n                return false;\n            }\n            if (node) {\n                // Edit title if 'clickActive' is triggered:\n                const trigger = this.getOption(\"edit.trigger\");\n                const slowClickDelay = this.getOption(\"edit.slowClickDelay\");\n                if (trigger.indexOf(\"clickActive\") >= 0 &&\n                    info.region === \"title\" &&\n                    node.isActive() &&\n                    (!slowClickDelay || Date.now() - this.lastClickTime < slowClickDelay)) {\n                    this._callMethod(\"edit.startEditTitle\", node);\n                }\n                if (info.colIdx >= 0) {\n                    node.setActive(true, { colIdx: info.colIdx, event: e });\n                }\n                else {\n                    node.setActive(true, { event: e });\n                }\n                if (info.region === NodeRegion.expander) {\n                    node.setExpanded(!node.isExpanded());\n                }\n                else if (info.region === NodeRegion.checkbox) {\n                    node.setSelected(!node.isSelected());\n                }\n            }\n            this.lastClickTime = Date.now();\n        });\n        onEvent(this.nodeListElement, \"dblclick\", \"div.wb-row\", (e) => {\n            const info = Wunderbaum.getEventInfo(e);\n            const node = info.node;\n            // this.log(\"dblclick\", info, e);\n            if (this._callEvent(\"dblclick\", { event: e, node: node, info: info }) ===\n                false) {\n                return false;\n            }\n            if (node && info.colIdx === 0 && node.isExpandable()) {\n                this._callMethod(\"edit._stopEditTitle\");\n                node.setExpanded(!node.isExpanded());\n            }\n        });\n        onEvent(this.element, \"keydown\", (e) => {\n            const info = Wunderbaum.getEventInfo(e);\n            const eventName = eventToString(e);\n            const node = info.node || this.getFocusNode();\n            this._callHook(\"onKeyEvent\", {\n                event: e,\n                node: node,\n                info: info,\n                eventName: eventName,\n            });\n        });\n        onEvent(this.element, \"focusin focusout\", (e) => {\n            const flag = e.type === \"focusin\";\n            const targetNode = Wunderbaum.getNode(e);\n            this._callEvent(\"focus\", { flag: flag, event: e });\n            if (flag && this.isRowNav() && !this.isEditing()) {\n                if (opts.navigationModeOption === NavModeEnum.row) {\n                    targetNode === null || targetNode === void 0 ? void 0 : targetNode.setActive();\n                }\n                else {\n                    this.setCellNav();\n                }\n            }\n            if (!flag) {\n                this._callMethod(\"edit._stopEditTitle\", true, {\n                    event: e,\n                    forceClose: true,\n                });\n            }\n        });\n    }\n    /**\n     * Return a Wunderbaum instance, from element, id, index, or event.\n     *\n     * ```js\n     * getTree();         // Get first Wunderbaum instance on page\n     * getTree(1);        // Get second Wunderbaum instance on page\n     * getTree(event);    // Get tree for this mouse- or keyboard event\n     * getTree(\"foo\");    // Get tree for this `tree.options.id`\n     * getTree(\"#tree\");  // Get tree for this matching element\n     * ```\n     */\n    static getTree(el) {\n        if (el instanceof Wunderbaum) {\n            return el;\n        }\n        else if (el instanceof WunderbaumNode) {\n            return el.tree;\n        }\n        if (el === undefined) {\n            el = 0; // get first tree\n        }\n        if (typeof el === \"number\") {\n            el = document.querySelectorAll(\".wunderbaum\")[el]; // el was an integer: return nth element\n        }\n        else if (typeof el === \"string\") {\n            // Search all trees for matching ID\n            for (let treeElem of document.querySelectorAll(\".wunderbaum\")) {\n                const tree = treeElem._wb_tree;\n                if (tree && tree.id === el) {\n                    return tree;\n                }\n            }\n            // Search by selector\n            el = document.querySelector(el);\n            if (!el) {\n                return null;\n            }\n        }\n        else if (el.target) {\n            el = el.target;\n        }\n        assert(el instanceof Element);\n        if (!el.matches(\".wunderbaum\")) {\n            el = el.closest(\".wunderbaum\");\n        }\n        if (el && el._wb_tree) {\n            return el._wb_tree;\n        }\n        return null;\n    }\n    /**\n     * Return a WunderbaumNode instance from element or event.\n     */\n    static getNode(el) {\n        if (!el) {\n            return null;\n        }\n        else if (el instanceof WunderbaumNode) {\n            return el;\n        }\n        else if (el.target !== undefined) {\n            el = el.target; // el was an Event\n        }\n        // `el` is a DOM element\n        // let nodeElem = obj.closest(\"div.wb-row\");\n        while (el) {\n            if (el._wb_node) {\n                return el._wb_node;\n            }\n            el = el.parentElement; //.parentNode;\n        }\n        return null;\n    }\n    /**\n     * Iterate all descendant nodes depth-first, pre-order using `for ... of ...` syntax.\n     * More concise, but slightly slower than {@link Wunderbaum.visit}.\n     *\n     * Example:\n     * ```js\n     * for(const node of tree) {\n     *   ...\n     * }\n     * ```\n     */\n    *[Symbol.iterator]() {\n        yield* this.root;\n    }\n    /** @internal */\n    _registerExtension(extension) {\n        this.extensionList.push(extension);\n        this.extensions[extension.id] = extension;\n        // this.extensionMap.set(extension.id, extension);\n    }\n    /** Called on tree (re)init after markup is created, before loading. */\n    _initExtensions() {\n        for (let ext of this.extensionList) {\n            ext.init();\n        }\n    }\n    /** Add node to tree's bookkeeping data structures. */\n    _registerNode(node) {\n        const key = node.key;\n        assert(key != null && !this.keyMap.has(key), `Missing or duplicate key: '${key}'.`);\n        this.keyMap.set(key, node);\n        let rk = node.refKey;\n        if (rk) {\n            let rks = this.refKeyMap.get(rk); // Set of nodes with this refKey\n            if (rks) {\n                rks.add(node);\n            }\n            else {\n                this.refKeyMap.set(rk, new Set());\n            }\n        }\n    }\n    /** Remove node from tree's bookkeeping data structures. */\n    _unregisterNode(node) {\n        const rk = node.refKey;\n        if (rk) {\n            const rks = this.refKeyMap.get(rk);\n            if (rks && rks.delete(node) && !rks.size) {\n                // We just removed the last element\n                this.refKeyMap.delete(rk);\n            }\n        }\n        // mark as disposed\n        node.tree = null;\n        node.parent = null;\n        // node.title = \"DISPOSED: \" + node.title\n        // this.viewNodes.delete(node);\n        node.removeMarkup();\n    }\n    /** Call all hook methods of all registered extensions.*/\n    _callHook(hook, data = {}) {\n        let res;\n        let d = extend({}, { tree: this, options: this.options, result: undefined }, data);\n        for (let ext of this.extensionList) {\n            res = ext[hook].call(ext, d);\n            if (res === false) {\n                break;\n            }\n            if (d.result !== undefined) {\n                res = d.result;\n            }\n        }\n        return res;\n    }\n    /**\n     * Call tree method or extension method if defined.\n     *\n     * Example:\n     * ```js\n     * tree._callMethod(\"edit.startEdit\", \"arg1\", \"arg2\")\n     * ```\n     */\n    _callMethod(name, ...args) {\n        const [p, n] = name.split(\".\");\n        const obj = n ? this.extensions[p] : this;\n        const func = obj[n];\n        if (func) {\n            return func.apply(obj, args);\n        }\n        else {\n            this.logError(`Calling undefined method '${name}()'.`);\n        }\n    }\n    /**\n     * Call event handler if defined in tree or tree.EXTENSION options.\n     *\n     * Example:\n     * ```js\n     * tree._callEvent(\"edit.beforeEdit\", {foo: 42})\n     * ```\n     */\n    _callEvent(type, extra) {\n        const [p, n] = type.split(\".\");\n        const opts = this.options;\n        const func = n ? opts[p][n] : opts[p];\n        if (func) {\n            return func.call(this, extend({ type: type, tree: this, util: this._util }, extra));\n            // } else {\n            //   this.logError(`Triggering undefined event '${type}'.`)\n        }\n    }\n    /** Return the node for  given row index. */\n    _getNodeByRowIdx(idx) {\n        // TODO: start searching from active node (reverse)\n        let node = null;\n        this.visitRows((n) => {\n            if (n._rowIdx === idx) {\n                node = n;\n                return false;\n            }\n        });\n        return node;\n    }\n    /** Return the topmost visible node in the viewport. */\n    getTopmostVpNode(complete = true) {\n        const gracePx = 1; // ignore subpixel scrolling\n        const scrollParent = this.element;\n        // const headerHeight = this.headerElement.clientHeight;  // May be 0\n        const scrollTop = scrollParent.scrollTop; // + headerHeight;\n        let topIdx;\n        if (complete) {\n            topIdx = Math.ceil((scrollTop - gracePx) / ROW_HEIGHT);\n        }\n        else {\n            topIdx = Math.floor(scrollTop / ROW_HEIGHT);\n        }\n        return this._getNodeByRowIdx(topIdx);\n    }\n    /** Return the lowest visible node in the viewport. */\n    getLowestVpNode(complete = true) {\n        const scrollParent = this.element;\n        const headerHeight = this.headerElement.clientHeight; // May be 0\n        const scrollTop = scrollParent.scrollTop;\n        const clientHeight = scrollParent.clientHeight - headerHeight;\n        let bottomIdx;\n        if (complete) {\n            bottomIdx = Math.floor((scrollTop + clientHeight) / ROW_HEIGHT) - 1;\n        }\n        else {\n            bottomIdx = Math.ceil((scrollTop + clientHeight) / ROW_HEIGHT) - 1;\n        }\n        bottomIdx = Math.min(bottomIdx, this.count(true) - 1);\n        return this._getNodeByRowIdx(bottomIdx);\n    }\n    /** Return preceeding visible node in the viewport. */\n    _getPrevNodeInView(node, ofs = 1) {\n        this.visitRows((n) => {\n            node = n;\n            if (ofs-- <= 0) {\n                return false;\n            }\n        }, { reverse: true, start: node || this.getActiveNode() });\n        return node;\n    }\n    /** Return following visible node in the viewport. */\n    _getNextNodeInView(node, ofs = 1) {\n        this.visitRows((n) => {\n            node = n;\n            if (ofs-- <= 0) {\n                return false;\n            }\n        }, { reverse: false, start: node || this.getActiveNode() });\n        return node;\n    }\n    /**\n     * Append (or insert) a list of toplevel nodes.\n     *\n     * @see {@link WunderbaumNode.addChildren}\n     */\n    addChildren(nodeData, options) {\n        return this.root.addChildren(nodeData, options);\n    }\n    /**\n     * Apply a modification or navigation operation.\n     *\n     * Most of these commands simply map to a node or tree method.\n     * This method is especially useful when implementing keyboard mapping,\n     * context menus, or external buttons.\n     *\n     * Valid commands:\n     *   - 'moveUp', 'moveDown'\n     *   - 'indent', 'outdent'\n     *   - 'remove'\n     *   - 'edit', 'addChild', 'addSibling': (reqires ext-edit extension)\n     *   - 'cut', 'copy', 'paste': (use an internal singleton 'clipboard')\n     *   - 'down', 'first', 'last', 'left', 'parent', 'right', 'up': navigate\n     *\n     */\n    applyCommand(cmd, nodeOrOpts, options) {\n        let // clipboard,\n        node, refNode;\n        // options = $.extend(\n        // \t{ setActive: true, clipboard: CLIPBOARD },\n        // \toptions_\n        // );\n        if (nodeOrOpts instanceof WunderbaumNode) {\n            node = nodeOrOpts;\n        }\n        else {\n            node = this.getActiveNode();\n            assert(options === undefined);\n            options = nodeOrOpts;\n        }\n        // clipboard = options.clipboard;\n        switch (cmd) {\n            // Sorting and indentation:\n            case \"moveUp\":\n                refNode = node.getPrevSibling();\n                if (refNode) {\n                    node.moveTo(refNode, \"before\");\n                    node.setActive();\n                }\n                break;\n            case \"moveDown\":\n                refNode = node.getNextSibling();\n                if (refNode) {\n                    node.moveTo(refNode, \"after\");\n                    node.setActive();\n                }\n                break;\n            case \"indent\":\n                refNode = node.getPrevSibling();\n                if (refNode) {\n                    node.moveTo(refNode, \"appendChild\");\n                    refNode.setExpanded();\n                    node.setActive();\n                }\n                break;\n            case \"outdent\":\n                if (!node.isTopLevel()) {\n                    node.moveTo(node.getParent(), \"after\");\n                    node.setActive();\n                }\n                break;\n            // Remove:\n            case \"remove\":\n                refNode = node.getPrevSibling() || node.getParent();\n                node.remove();\n                if (refNode) {\n                    refNode.setActive();\n                }\n                break;\n            // Add, edit (requires ext-edit):\n            case \"addChild\":\n                this._callMethod(\"edit.createNode\", \"prependChild\");\n                break;\n            case \"addSibling\":\n                this._callMethod(\"edit.createNode\", \"after\");\n                break;\n            case \"rename\":\n                this._callMethod(\"edit.startEditTitle\");\n                break;\n            // Simple clipboard simulation:\n            // case \"cut\":\n            // \tclipboard = { mode: cmd, data: node };\n            // \tbreak;\n            // case \"copy\":\n            // \tclipboard = {\n            // \t\tmode: cmd,\n            // \t\tdata: node.toDict(function(d, n) {\n            // \t\t\tdelete d.key;\n            // \t\t}),\n            // \t};\n            // \tbreak;\n            // case \"clear\":\n            // \tclipboard = null;\n            // \tbreak;\n            // case \"paste\":\n            // \tif (clipboard.mode === \"cut\") {\n            // \t\t// refNode = node.getPrevSibling();\n            // \t\tclipboard.data.moveTo(node, \"child\");\n            // \t\tclipboard.data.setActive();\n            // \t} else if (clipboard.mode === \"copy\") {\n            // \t\tnode.addChildren(clipboard.data).setActive();\n            // \t}\n            // \tbreak;\n            // Navigation commands:\n            case \"down\":\n            case \"first\":\n            case \"last\":\n            case \"left\":\n            case \"pageDown\":\n            case \"pageUp\":\n            case \"parent\":\n            case \"right\":\n            case \"up\":\n                return node.navigate(cmd);\n            default:\n                error(`Unhandled command: '${cmd}'`);\n        }\n    }\n    /** Delete all nodes. */\n    clear() {\n        this.root.removeChildren();\n        this.root.children = null;\n        this.keyMap.clear();\n        this.refKeyMap.clear();\n        // this.viewNodes.clear();\n        this.treeRowCount = 0;\n        this.activeNode = null;\n        this.focusNode = null;\n        // this.types = {};\n        // this. columns =[];\n        // this._columnsById = {};\n        // Modification Status\n        // this.changedSince = 0;\n        // this.changes.clear();\n        // this.changedNodes.clear();\n        // // --- FILTER ---\n        // public filterMode: FilterModeType = null;\n        // // --- KEYNAV ---\n        // public activeColIdx = 0;\n        // public cellNavMode = false;\n        // public lastQuicksearchTime = 0;\n        // public lastQuicksearchTerm = \"\";\n        this.setModified(ChangeType.structure);\n    }\n    /**\n     * Clear nodes and markup and detach events and observers.\n     *\n     * This method may be useful to free up resources before re-creating a tree\n     * on an existing div, for example in unittest suites.\n     * Note that this Wunderbaum instance becomes unusable afterwards.\n     */\n    destroy() {\n        this.logInfo(\"destroy()...\");\n        this.clear();\n        this.resizeObserver.disconnect();\n        this.element.innerHTML = \"\";\n        // Remove all event handlers\n        this.element.outerHTML = this.element.outerHTML;\n    }\n    /**\n     * Return `tree.option.NAME` (also resolving if this is a callback).\n     *\n     * See also {@link WunderbaumNode.getOption|WunderbaumNode.getOption()}\n     * to evaluate `node.NAME` setting and `tree.types[node.type].NAME`.\n     *\n     * @param name option name (use dot notation to access extension option, e.g.\n     * `filter.mode`)\n     */\n    getOption(name, defaultValue) {\n        let ext;\n        let opts = this.options;\n        // Lookup `name` in options dict\n        if (name.indexOf(\".\") >= 0) {\n            [ext, name] = name.split(\".\");\n            opts = opts[ext];\n        }\n        let value = opts[name];\n        // A callback resolver always takes precedence\n        if (typeof value === \"function\") {\n            value = value({ type: \"resolve\", tree: this });\n        }\n        // Use value from value options dict, fallback do default\n        // console.info(name, value, opts)\n        return value !== null && value !== void 0 ? value : defaultValue;\n    }\n    /**\n     * Set tree option.\n     * Use dot notation to set plugin option, e.g. \"filter.mode\".\n     */\n    setOption(name, value) {\n        // this.log(`setOption(${name}, ${value})`);\n        if (name.indexOf(\".\") >= 0) {\n            const parts = name.split(\".\");\n            const ext = this.extensions[parts[0]];\n            ext.setPluginOption(parts[1], value);\n            return;\n        }\n        this.options[name] = value;\n        switch (name) {\n            case \"checkbox\":\n                this.setModified(ChangeType.any);\n                break;\n            case \"enabled\":\n                this.setEnabled(!!value);\n                break;\n            case \"fixedCol\":\n                this.element.classList.toggle(\"wb-fixed-col\", !!value);\n                break;\n        }\n    }\n    /** Return true if the tree (or one of its nodes) has the input focus. */\n    hasFocus() {\n        return this.element.contains(document.activeElement);\n    }\n    /**\n     * Return true if the tree displays a header. Grids have a header unless the\n     * `header` option is set to `false`. Plain trees have a header if the `header`\n     * option is a string or `true`.\n     */\n    hasHeader() {\n        const header = this.options.header;\n        return this.isGrid() ? header !== false : !!header;\n    }\n    /** Run code, but defer rendering of viewport until done. */\n    runWithoutUpdate(func, hint = null) {\n        try {\n            this.enableUpdate(false);\n            const res = func();\n            assert(!(res instanceof Promise));\n            return res;\n        }\n        finally {\n            this.enableUpdate(true);\n        }\n    }\n    /** Recursively expand all expandable nodes (triggers lazy load id needed). */\n    async expandAll(flag = true, options) {\n        await this.root.expandAll(flag, options);\n    }\n    /** Recursively select all nodes. */\n    selectAll(flag = true) {\n        try {\n            this.enableUpdate(false);\n            this.visit((node) => {\n                node.setSelected(flag);\n            });\n        }\n        finally {\n            this.enableUpdate(true);\n        }\n    }\n    /** Return the number of nodes in the data model.*/\n    count(visible = false) {\n        if (visible) {\n            return this.treeRowCount;\n            // return this.viewNodes.size;\n        }\n        return this.keyMap.size;\n    }\n    /** @internal sanity check. */\n    _check() {\n        let i = 0;\n        this.visit((n) => {\n            i++;\n        });\n        if (this.keyMap.size !== i) {\n            this.logWarn(`_check failed: ${this.keyMap.size} !== ${i}`);\n        }\n        // util.assert(this.keyMap.size === i);\n    }\n    /**\n     * Find all nodes that match condition.\n     *\n     * @see {@link WunderbaumNode.findAll}\n     */\n    findAll(match) {\n        return this.root.findAll(match);\n    }\n    /**\n     * Find first node that matches condition.\n     *\n     * @see {@link WunderbaumNode.findFirst}\n     */\n    findFirst(match) {\n        return this.root.findFirst(match);\n    }\n    /**\n     * Find first node that matches condition.\n     *\n     * @param match title string to search for, or a\n     *     callback function that returns `true` if a node is matched.\n     * @see {@link WunderbaumNode.findFirst}\n     *\n     */\n    findKey(key) {\n        return this.keyMap.get(key) || null;\n    }\n    /**\n     * Find the next visible node that starts with `match`, starting at `startNode`\n     * and wrap-around at the end.\n     */\n    findNextNode(match, startNode) {\n        //, visibleOnly) {\n        let res = null, firstNode = this.getFirstChild();\n        let matcher = typeof match === \"string\" ? makeNodeTitleStartMatcher(match) : match;\n        startNode = startNode || firstNode;\n        function _checkNode(n) {\n            // console.log(\"_check \" + n)\n            if (matcher(n)) {\n                res = n;\n            }\n            if (res || n === startNode) {\n                return false;\n            }\n        }\n        this.visitRows(_checkNode, {\n            start: startNode,\n            includeSelf: false,\n        });\n        // Wrap around search\n        if (!res && startNode !== firstNode) {\n            this.visitRows(_checkNode, {\n                start: firstNode,\n                includeSelf: true,\n            });\n        }\n        return res;\n    }\n    /**\n     * Find a node relative to another node.\n     *\n     * @param node\n     * @param where 'down', 'first', 'last', 'left', 'parent', 'right', or 'up'.\n     *   (Alternatively the keyCode that would normally trigger this move,\n     *   e.g. `$.ui.keyCode.LEFT` = 'left'.\n     * @param includeHidden Not yet implemented\n     */\n    findRelatedNode(node, where, includeHidden = false) {\n        let res = null;\n        const pageSize = Math.floor(this.listContainerElement.clientHeight / ROW_HEIGHT);\n        switch (where) {\n            case \"parent\":\n                if (node.parent && node.parent.parent) {\n                    res = node.parent;\n                }\n                break;\n            case \"first\":\n                // First visible node\n                this.visit(function (n) {\n                    if (n.isVisible()) {\n                        res = n;\n                        return false;\n                    }\n                });\n                break;\n            case \"last\":\n                this.visit(function (n) {\n                    // last visible node\n                    if (n.isVisible()) {\n                        res = n;\n                    }\n                });\n                break;\n            case \"left\":\n                if (node.parent && node.parent.parent) {\n                    res = node.parent;\n                }\n                // if (node.expanded) {\n                //   node.setExpanded(false);\n                // } else if (node.parent && node.parent.parent) {\n                //   res = node.parent;\n                // }\n                break;\n            case \"right\":\n                if (node.children && node.children.length) {\n                    res = node.children[0];\n                }\n                // if (this.cellNavMode) {\n                //   throw new Error(\"Not implemented\");\n                // } else {\n                //   if (!node.expanded && (node.children || node.lazy)) {\n                //     node.setExpanded();\n                //     res = node;\n                //   } else if (node.children && node.children.length) {\n                //     res = node.children[0];\n                //   }\n                // }\n                break;\n            case \"up\":\n                res = this._getPrevNodeInView(node);\n                break;\n            case \"down\":\n                res = this._getNextNodeInView(node);\n                break;\n            case \"pageDown\":\n                const bottomNode = this.getLowestVpNode();\n                // this.logDebug(`${where}(${node}) -> ${bottomNode}`);\n                if (node._rowIdx < bottomNode._rowIdx) {\n                    res = bottomNode;\n                }\n                else {\n                    res = this._getNextNodeInView(node, pageSize);\n                }\n                break;\n            case \"pageUp\":\n                if (node._rowIdx === 0) {\n                    res = node;\n                }\n                else {\n                    const topNode = this.getTopmostVpNode();\n                    // this.logDebug(`${where}(${node}) -> ${topNode}`);\n                    if (node._rowIdx > topNode._rowIdx) {\n                        res = topNode;\n                    }\n                    else {\n                        res = this._getPrevNodeInView(node, pageSize);\n                    }\n                }\n                break;\n            default:\n                this.logWarn(\"Unknown relation '\" + where + \"'.\");\n        }\n        return res;\n    }\n    /**\n     * Iterator version of {@link Wunderbaum.format}.\n     */\n    *format_iter(name_cb, connectors) {\n        return this.root.format_iter(name_cb, connectors);\n    }\n    /**\n     * Return multiline string representation of the node hierarchy.\n     * Mostly useful for debugging.\n     *\n     * Example:\n     * ```js\n     * console.info(tree.format((n)=>n.title));\n     * ```\n     * logs\n     * ```\n     * Playground\n     * ├─ Books\n     * |   ├─ Art of War\n     * |   ╰─ Don Quixote\n     * ├─ Music\n     * ...\n     * ```\n     *\n     * @see {@link Wunderbaum.format_iter} and {@link WunderbaumNode.format}.\n     */\n    format(name_cb, connectors) {\n        return this.root.format(name_cb, connectors);\n    }\n    /**\n     * Return the active cell (`span.wb-col`) of the currently active node or null.\n     */\n    getActiveColElem() {\n        if (this.activeNode && this.activeColIdx >= 0) {\n            return this.activeNode.getColElem(this.activeColIdx);\n        }\n        return null;\n    }\n    /**\n     * Return the currently active node or null.\n     */\n    getActiveNode() {\n        return this.activeNode;\n    }\n    /**\n     * Return the first top level node if any (not the invisible root node).\n     */\n    getFirstChild() {\n        return this.root.getFirstChild();\n    }\n    /**\n     * Return the currently active node or null.\n     */\n    getFocusNode() {\n        return this.focusNode;\n    }\n    /** Return a {node: WunderbaumNode, region: TYPE} object for a mouse event.\n     *\n     * @param {Event} event Mouse event, e.g. click, ...\n     * @returns {object} Return a {node: WunderbaumNode, region: TYPE} object\n     *     TYPE: 'title' | 'prefix' | 'expander' | 'checkbox' | 'icon' | undefined\n     */\n    static getEventInfo(event) {\n        let target = event.target, cl = target.classList, parentCol = target.closest(\"span.wb-col\"), node = Wunderbaum.getNode(target), tree = node ? node.tree : Wunderbaum.getTree(event), res = {\n            tree: tree,\n            node: node,\n            region: NodeRegion.unknown,\n            colDef: undefined,\n            colIdx: -1,\n            colId: undefined,\n            colElem: parentCol,\n        };\n        if (cl.contains(\"wb-title\")) {\n            res.region = NodeRegion.title;\n        }\n        else if (cl.contains(\"wb-expander\")) {\n            res.region = node.isExpandable()\n                ? NodeRegion.expander\n                : NodeRegion.prefix;\n        }\n        else if (cl.contains(\"wb-checkbox\")) {\n            res.region = NodeRegion.checkbox;\n        }\n        else if (cl.contains(\"wb-icon\")) {\n            //|| cl.contains(\"wb-custom-icon\")) {\n            res.region = NodeRegion.icon;\n        }\n        else if (cl.contains(\"wb-node\")) {\n            res.region = NodeRegion.title;\n        }\n        else if (parentCol) {\n            res.region = NodeRegion.column;\n            const idx = Array.prototype.indexOf.call(parentCol.parentNode.children, parentCol);\n            res.colIdx = idx;\n        }\n        else if (cl.contains(\"wb-row\")) {\n            // Plain tree\n            res.region = NodeRegion.title;\n        }\n        else {\n            // Somewhere near the title\n            if (event.type !== \"mousemove\" && !(event instanceof KeyboardEvent)) {\n                console.warn(\"getEventInfo(): not found\", event, res);\n            }\n            return res;\n        }\n        if (res.colIdx === -1) {\n            res.colIdx = 0;\n        }\n        res.colDef = tree === null || tree === void 0 ? void 0 : tree.columns[res.colIdx];\n        res.colDef != null ? (res.colId = res.colDef.id) : 0;\n        // this.log(\"Event\", event, res);\n        return res;\n    }\n    /**\n     * Return readable string representation for this instance.\n     * @internal\n     */\n    toString() {\n        return `Wunderbaum<'${this.id}'>`;\n    }\n    /** Return true if any node is currently in edit-title mode. */\n    isEditing() {\n        return this._callMethod(\"edit.isEditingTitle\");\n    }\n    /**\n     * Return true if any node is currently beeing loaded, i.e. a Ajax request is pending.\n     */\n    isLoading() {\n        var res = false;\n        this.root.visit((n) => {\n            // also visit rootNode\n            if (n._isLoading || n._requestId) {\n                res = true;\n                return false;\n            }\n        }, true);\n        return res;\n    }\n    /** Log to console if opts.debugLevel >= 4 */\n    logDebug(...args) {\n        if (this.options.debugLevel >= 4) {\n            Array.prototype.unshift.call(args, this.toString());\n            console.log.apply(console, args);\n        }\n    }\n    /** Log error to console. */\n    logError(...args) {\n        if (this.options.debugLevel >= 1) {\n            Array.prototype.unshift.call(args, this.toString());\n            console.error.apply(console, args);\n        }\n    }\n    /** Log to console if opts.debugLevel >= 3 */\n    logInfo(...args) {\n        if (this.options.debugLevel >= 3) {\n            Array.prototype.unshift.call(args, this.toString());\n            console.info.apply(console, args);\n        }\n    }\n    /** @internal */\n    logTime(label) {\n        if (this.options.debugLevel >= 4) {\n            console.time(this + \": \" + label);\n        }\n        return label;\n    }\n    /** @internal */\n    logTimeEnd(label) {\n        if (this.options.debugLevel >= 4) {\n            console.timeEnd(this + \": \" + label);\n        }\n    }\n    /** Log to console if opts.debugLevel >= 2 */\n    logWarn(...args) {\n        if (this.options.debugLevel >= 2) {\n            Array.prototype.unshift.call(args, this.toString());\n            console.warn.apply(console, args);\n        }\n    }\n    /**\n     * Make sure that this node is vertically scrolled into the viewport.\n     *\n     * Nodes that are above the visible area become the top row, nodes that are\n     * below the viewport become the bottom row.\n     */\n    scrollTo(nodeOrOpts) {\n        const PADDING = 2; // leave some pixels between viewport bounds\n        let node;\n        let options;\n        if (nodeOrOpts instanceof WunderbaumNode) {\n            node = nodeOrOpts;\n        }\n        else {\n            options = nodeOrOpts;\n            node = options.node;\n        }\n        assert(node && node._rowIdx != null);\n        const scrollParent = this.element;\n        const headerHeight = this.headerElement.clientHeight; // May be 0\n        const scrollTop = scrollParent.scrollTop;\n        const vpHeight = scrollParent.clientHeight;\n        const rowTop = node._rowIdx * ROW_HEIGHT + headerHeight;\n        const vpTop = headerHeight;\n        const vpRowTop = rowTop - scrollTop;\n        const vpRowBottom = vpRowTop + ROW_HEIGHT;\n        const topNode = options === null || options === void 0 ? void 0 : options.topNode;\n        // this.log( `scrollTo(${node.title}), vpTop:${vpTop}px, scrollTop:${scrollTop}, vpHeight:${vpHeight}, rowTop:${rowTop}, vpRowTop:${vpRowTop}`, nodeOrOpts , options);\n        let newScrollTop = null;\n        if (vpRowTop >= vpTop) {\n            if (vpRowBottom <= vpHeight) ;\n            else {\n                // Node is below viewport\n                // this.log(\"Below viewport\");\n                newScrollTop = rowTop + ROW_HEIGHT - vpHeight + PADDING; // leave some pixels between viewport bounds\n            }\n        }\n        else {\n            // Node is above viewport\n            // this.log(\"Above viewport\");\n            newScrollTop = rowTop - vpTop - PADDING; // leave some pixels between viewport bounds\n        }\n        if (newScrollTop != null) {\n            this.log(`scrollTo(${rowTop}): ${scrollTop} => ${newScrollTop}`);\n            scrollParent.scrollTop = newScrollTop;\n            if (topNode) {\n                // Make sure the topNode is always visible\n                this.scrollTo(topNode);\n            }\n            // this.setModified(ChangeType.scroll);\n        }\n    }\n    /**\n     * Make sure that this node is horizontally scrolled into the viewport.\n     * Called by {@link setColumn}.\n     */\n    scrollToHorz() {\n        // const PADDING = 1;\n        const fixedWidth = this.columns[0]._widthPx;\n        const vpWidth = this.element.clientWidth;\n        const scrollLeft = this.element.scrollLeft;\n        const colElem = this.getActiveColElem();\n        const colLeft = Number.parseInt(colElem === null || colElem === void 0 ? void 0 : colElem.style.left, 10);\n        const colRight = colLeft + Number.parseInt(colElem === null || colElem === void 0 ? void 0 : colElem.style.width, 10);\n        let newLeft = scrollLeft;\n        if (colLeft - scrollLeft < fixedWidth) {\n            // The current column is scrolled behind the left fixed column\n            newLeft = colLeft - fixedWidth;\n        }\n        else if (colRight - scrollLeft > vpWidth) {\n            // The current column is scrolled outside the right side\n            newLeft = colRight - vpWidth;\n        }\n        newLeft = Math.max(0, newLeft);\n        // util.assert(node._rowIdx != null);\n        this.log(`scrollToHorz(${this.activeColIdx}): ${colLeft}..${colRight}, fixedOfs=${fixedWidth}, vpWidth=${vpWidth}, curLeft=${scrollLeft} -> ${newLeft}`);\n        this.element.scrollLeft = newLeft;\n        // this.setModified(ChangeType.scroll);\n    }\n    /**\n     * Set column #colIdx to 'active'.\n     *\n     * This higlights the column header and -cells by adding the `wb-active` class.\n     * Available in cell-nav mode only.\n     */\n    setColumn(colIdx) {\n        var _a;\n        assert(this.isCellNav());\n        assert(0 <= colIdx && colIdx < this.columns.length);\n        this.activeColIdx = colIdx;\n        // Update `wb-active` class for all headers\n        if (this.hasHeader()) {\n            for (let rowDiv of this.headerElement.children) {\n                let i = 0;\n                for (let colDiv of rowDiv.children) {\n                    colDiv.classList.toggle(\"wb-active\", i++ === colIdx);\n                }\n            }\n        }\n        (_a = this.activeNode) === null || _a === void 0 ? void 0 : _a.setModified(ChangeType.status);\n        // Update `wb-active` class for all cell spans\n        for (let rowDiv of this.nodeListElement.children) {\n            let i = 0;\n            for (let colDiv of rowDiv.children) {\n                colDiv.classList.toggle(\"wb-active\", i++ === colIdx);\n            }\n        }\n        // Vertical scroll into view\n        // if (this.options.fixedCol) {\n        this.scrollToHorz();\n        // }\n    }\n    /** Set or remove keybaord focus to the tree container. */\n    setActiveNode(key, flag = true, options) {\n        var _a;\n        (_a = this.findKey(key)) === null || _a === void 0 ? void 0 : _a.setActive(flag, options);\n    }\n    /** Set or remove keybaord focus to the tree container. */\n    setFocus(flag = true) {\n        if (flag) {\n            this.element.focus();\n        }\n        else {\n            this.element.blur();\n        }\n    }\n    setModified(change, node, options) {\n        if (this._disableUpdateCount) {\n            // Assuming that we redraw all when enableUpdate() is re-enabled.\n            // this.log(\n            //   `IGNORED setModified(${change}) node=${node} (disable level ${this._disableUpdateCount})`\n            // );\n            this._disableUpdateIgnoreCount++;\n            return;\n        }\n        // this.log(`setModified(${change}) node=${node}`);\n        if (!(node instanceof WunderbaumNode)) {\n            options = node;\n            node = null;\n        }\n        const immediate = !!getOption(options, \"immediate\");\n        const RF = RenderFlag;\n        const pending = this.pendingChangeTypes;\n        switch (change) {\n            case ChangeType.any:\n            case ChangeType.colStructure:\n                pending.add(RF.header);\n                pending.add(RF.clearMarkup);\n                pending.add(RF.redraw);\n                pending.add(RF.scroll);\n                break;\n            case ChangeType.resize:\n                // case ChangeType.colWidth:\n                pending.add(RF.header);\n                pending.add(RF.redraw);\n                break;\n            case ChangeType.structure:\n                pending.add(RF.redraw);\n                break;\n            case ChangeType.scroll:\n                pending.add(RF.scroll);\n                break;\n            case ChangeType.row:\n            case ChangeType.data:\n            case ChangeType.status:\n                assert(node, `Option '${change}' requires a node.`);\n                // Single nodes are immediately updated if already inside the viewport\n                // (otherwise we can ignore)\n                if (node._rowElem) {\n                    node.render({ change: change });\n                }\n                break;\n            default:\n                error(`Invalid change type '${change}'.`);\n        }\n        if (change === ChangeType.colStructure) {\n            const isGrid = this.isGrid();\n            this.element.classList.toggle(\"wb-grid\", isGrid);\n            if (!isGrid && this.isCellNav()) {\n                this.setCellNav(false);\n            }\n        }\n        if (pending.size > 0) {\n            if (immediate) {\n                this._updateViewportImmediately();\n            }\n            else {\n                this._updateViewportThrottled();\n            }\n        }\n    }\n    /** Disable mouse and keyboard interaction (return prev. state). */\n    setEnabled(flag = true) {\n        const prev = this.enabled;\n        this.enabled = !!flag;\n        this.element.classList.toggle(\"wb-disabled\", !flag);\n        return prev;\n    }\n    /** Return false if tree is disabled. */\n    isEnabled() {\n        return this.enabled;\n    }\n    /** Return true if tree has more than one column, i.e. has additional data columns. */\n    isGrid() {\n        return this.columns && this.columns.length > 1;\n    }\n    /** Return true if cell-navigation mode is acive. */\n    isCellNav() {\n        return !!this._cellNavMode;\n    }\n    /** Return true if row-navigation mode is acive. */\n    isRowNav() {\n        return !this._cellNavMode;\n    }\n    /** Set the tree's navigation mode. */\n    setCellNav(flag = true) {\n        var _a;\n        const prev = this._cellNavMode;\n        // if (flag === prev) {\n        //   return;\n        // }\n        this._cellNavMode = !!flag;\n        if (flag && !prev) {\n            // switch from row to cell mode\n            this.setColumn(0);\n        }\n        this.element.classList.toggle(\"wb-cell-mode\", flag);\n        (_a = this.activeNode) === null || _a === void 0 ? void 0 : _a.setModified(ChangeType.status);\n    }\n    /** Set the tree's navigation mode option. */\n    setNavigationOption(mode, reset = false) {\n        if (!this.isGrid() && mode !== NavModeEnum.row) {\n            this.logWarn(\"Plain trees only support row navigation mode.\");\n            return;\n        }\n        this.options.navigationModeOption = mode;\n        switch (mode) {\n            case NavModeEnum.cell:\n                this.setCellNav(true);\n                break;\n            case NavModeEnum.row:\n                this.setCellNav(false);\n                break;\n            case NavModeEnum.startCell:\n                if (reset) {\n                    this.setCellNav(true);\n                }\n                break;\n            case NavModeEnum.startRow:\n                if (reset) {\n                    this.setCellNav(false);\n                }\n                break;\n            default:\n                error(`Invalid mode '${mode}'.`);\n        }\n    }\n    /** Display tree status (ok, loading, error, noData) using styles and a dummy root node. */\n    setStatus(status, options) {\n        return this.root.setStatus(status, options);\n    }\n    /** Add or redefine node type definitions. */\n    setTypes(types, replace = true) {\n        assert(isPlainObject(types));\n        if (replace) {\n            this.types = types;\n        }\n        else {\n            extend(this.types, types);\n        }\n        // Convert `TYPE.classes` to a Set\n        for (let t of Object.values(this.types)) {\n            if (t.classes) {\n                t.classes = toSet(t.classes);\n            }\n        }\n    }\n    /**\n     * Sort nodes list by title or custom criteria.\n     * @param {function} cmp custom compare function(a, b) that returns -1, 0, or 1\n     *    (defaults to sorting by title).\n     * @param {boolean} deep pass true to sort all descendant nodes recursively\n     */\n    sortChildren(cmp = nodeTitleSorter, deep = false) {\n        this.root.sortChildren(cmp, deep);\n    }\n    /** Convert tree to an array of plain objects.\n     *\n     * @param callback(dict, node) is called for every node, in order to allow\n     *     modifications.\n     *     Return `false` to ignore this node or `\"skip\"` to include this node\n     *     without its children.\n     * @see {@link WunderbaumNode.toDict}.\n     */\n    toDictArray(callback) {\n        var _a;\n        const res = this.root.toDict(true, callback);\n        return (_a = res.children) !== null && _a !== void 0 ? _a : [];\n    }\n    /**\n     * Update column headers and column width.\n     * Return true if at least one column width changed.\n     */\n    // _updateColumnWidths(options?: UpdateColumnsOptions): boolean {\n    _updateColumnWidths() {\n        // options = Object.assign({ updateRows: true, renderMarkup: false }, options);\n        const defaultMinWidth = 4;\n        const vpWidth = this.element.clientWidth;\n        // Shorten last column width to avoid h-scrollbar\n        const FIX_ADJUST_LAST_COL = 2;\n        const columns = this.columns;\n        const col0 = columns[0];\n        let totalWidth = 0;\n        let totalWeight = 0;\n        let fixedWidth = 0;\n        let modified = false;\n        // this.element.classList.toggle(\"wb-grid\", isGrid);\n        // if (!isGrid && this.isCellNav()) {\n        //   this.setCellNav(false);\n        // }\n        // if (options.calculateCols) {\n        if (col0.id !== \"*\") {\n            throw new Error(`First column must have  id '*': got '${col0.id}'.`);\n        }\n        // Gather width definitions\n        this._columnsById = {};\n        for (let col of columns) {\n            this._columnsById[col.id] = col;\n            let cw = col.width;\n            if (col.id === \"*\" && col !== col0) {\n                throw new Error(`Column id '*' must be defined only once: '${col.title}'.`);\n            }\n            if (!cw || cw === \"*\") {\n                col._weight = 1.0;\n                totalWeight += 1.0;\n            }\n            else if (typeof cw === \"number\") {\n                col._weight = cw;\n                totalWeight += cw;\n            }\n            else if (typeof cw === \"string\" && cw.endsWith(\"px\")) {\n                col._weight = 0;\n                let px = parseFloat(cw.slice(0, -2));\n                if (col._widthPx != px) {\n                    modified = true;\n                    col._widthPx = px;\n                }\n                fixedWidth += px;\n            }\n            else {\n                error(`Invalid column width: ${cw} (expected string ending with 'px' or number, e.g. \"<num>px\" or <int>).`);\n            }\n        }\n        // Share remaining space between non-fixed columns\n        const restPx = Math.max(0, vpWidth - fixedWidth);\n        let ofsPx = 0;\n        for (let col of columns) {\n            let minWidth;\n            if (col._weight) {\n                const cmw = col.minWidth;\n                if (typeof cmw === \"number\") {\n                    minWidth = cmw;\n                }\n                else if (typeof cmw === \"string\" && cmw.endsWith(\"px\")) {\n                    minWidth = parseFloat(cmw.slice(0, -2));\n                }\n                else {\n                    minWidth = defaultMinWidth;\n                }\n                const px = Math.max(minWidth, (restPx * col._weight) / totalWeight);\n                if (col._widthPx != px) {\n                    modified = true;\n                    col._widthPx = px;\n                }\n            }\n            col._ofsPx = ofsPx;\n            ofsPx += col._widthPx;\n        }\n        columns[columns.length - 1]._widthPx -= FIX_ADJUST_LAST_COL;\n        totalWidth = ofsPx - FIX_ADJUST_LAST_COL;\n        const tw = `${totalWidth}px`;\n        this.headerElement.style.width = tw;\n        this.listContainerElement.style.width = tw;\n        // }\n        // Every column has now a calculated `_ofsPx` and `_widthPx`\n        // this.logInfo(\"UC\", this.columns, vpWidth, this.element.clientWidth, this.element);\n        // console.trace();\n        // util.error(\"BREAK\");\n        // if (modified) {\n        //   this._renderHeaderMarkup();\n        //   if (options.renderMarkup) {\n        //     this.setModified(ChangeType.header, { removeMarkup: true });\n        //   } else if (options.updateRows) {\n        //     this._updateRows();\n        //   }\n        // }\n        return modified;\n    }\n    /** Create/update header markup from `this.columns` definition.\n     * @internal\n     */\n    _renderHeaderMarkup() {\n        assert(this.headerElement);\n        const wantHeader = this.hasHeader();\n        setElemDisplay(this.headerElement, wantHeader);\n        if (!wantHeader) {\n            return;\n        }\n        const colCount = this.columns.length;\n        const headerRow = this.headerElement.querySelector(\".wb-row\");\n        assert(headerRow);\n        headerRow.innerHTML = \"<span class='wb-col'></span>\".repeat(colCount);\n        for (let i = 0; i < colCount; i++) {\n            const col = this.columns[i];\n            const colElem = headerRow.children[i];\n            colElem.style.left = col._ofsPx + \"px\";\n            colElem.style.width = col._widthPx + \"px\";\n            // Add classes from `columns` definition to `<div.wb-col>` cells\n            if (typeof col.headerClasses === \"string\") {\n                col.headerClasses\n                    ? colElem.classList.add(...col.headerClasses.split(\" \"))\n                    : 0;\n            }\n            else {\n                col.classes ? colElem.classList.add(...col.classes.split(\" \")) : 0;\n            }\n            const title = escapeHtml(col.title || col.id);\n            let tooltip = \"\";\n            if (col.tooltip) {\n                tooltip = escapeTooltip(col.tooltip);\n                tooltip = ` title=\"${tooltip}\"`;\n            }\n            let resizer = \"\";\n            if (i < colCount - 1) {\n                resizer = '<span class=\"wb-col-resizer\"></span>';\n            }\n            colElem.innerHTML = `<span class=\"wb-col-title\"${tooltip}>${title}</span>${resizer}`;\n            if (this.isCellNav()) {\n                colElem.classList.toggle(\"wb-active\", i === this.activeColIdx);\n            }\n        }\n    }\n    /**\n     * Render pending changes that were scheduled using {@link WunderbaumNode.setModified} if any.\n     *\n     * This is hardly ever neccessary, since we normally either\n     * - call `setModified(ChangeType.TYPE)` (async, throttled), or\n     * - call `setModified(ChangeType.TYPE, {immediate: true})` (synchronous)\n     *\n     * `updatePendingModifications()` will only force immediate execution of\n     * pending async changes if any.\n     */\n    updatePendingModifications() {\n        if (this.pendingChangeTypes.size > 0) {\n            this._updateViewportImmediately();\n        }\n    }\n    /**\n     * This is the actual update method, which is wrapped inside a throttle method.\n     * It calls `updateColumns()` and `_updateRows()`.\n     *\n     * This protected method should not be called directly but via\n     * {@link WunderbaumNode.setModified}`, {@link Wunderbaum.setModified},\n     * or {@link Wunderbaum.updatePendingModifications}.\n     * @internal\n     */\n    _updateViewportImmediately() {\n        var _a;\n        if (this._disableUpdateCount) {\n            this.log(`_updateViewportImmediately() IGNORED (disable level: ${this._disableUpdateCount})`);\n            this._disableUpdateIgnoreCount++;\n            return;\n        }\n        // Shorten container height to avoid v-scrollbar\n        const FIX_ADJUST_HEIGHT = 1;\n        const RF = RenderFlag;\n        const pending = new Set(this.pendingChangeTypes);\n        this.pendingChangeTypes.clear();\n        const scrollOnly = pending.has(RF.scroll) && pending.size === 1;\n        if (scrollOnly) {\n            this._updateRows({ newNodesOnly: true });\n            // this.log(\"_updateViewportImmediately(): scroll only.\");\n        }\n        else {\n            this.log(\"_updateViewportImmediately():\", pending);\n            let height = this.listContainerElement.clientHeight;\n            // We cannot get the height for absolute positioned parent, so look at first col\n            // let headerHeight = this.headerElement.clientHeight\n            // let headerHeight = this.headerElement.children[0].children[0].clientHeight;\n            // const headerHeight = this.options.headerHeightPx;\n            const headerHeight = this.headerElement.clientHeight; // May be 0\n            const wantHeight = this.element.clientHeight - headerHeight - FIX_ADJUST_HEIGHT;\n            if (Math.abs(height - wantHeight) > 1.0) {\n                // this.log(\"resize\", height, wantHeight);\n                this.listContainerElement.style.height = wantHeight + \"px\";\n                height = wantHeight;\n            }\n            // console.profile(`_updateViewportImmediately()`)\n            if (pending.has(RF.clearMarkup)) {\n                this.visit((n) => {\n                    n.removeMarkup();\n                });\n            }\n            // let widthModified = false;\n            if (pending.has(RF.header)) {\n                // widthModified = this._updateColumnWidths();\n                this._updateColumnWidths();\n                this._renderHeaderMarkup();\n            }\n            this._updateRows();\n            // console.profileEnd(`_updateViewportImmediately()`)\n        }\n        if (this.options.connectTopBreadcrumb) {\n            let path = (_a = this.getTopmostVpNode(true)) === null || _a === void 0 ? void 0 : _a.getPath(false, \"title\", \" > \");\n            path = path ? path + \" >\" : \"\";\n            this.options.connectTopBreadcrumb.textContent = path;\n        }\n        this._callEvent(\"update\");\n    }\n    // /**\n    //  * Assert that TR order matches the natural node order\n    //  * @internal\n    //  */\n    // protected _validateRows(): boolean {\n    //   let trs = this.nodeListElement.childNodes;\n    //   let i = 0;\n    //   let prev = -1;\n    //   let ok = true;\n    //   trs.forEach((element) => {\n    //     const tr = element as HTMLTableRowElement;\n    //     const top = Number.parseInt(tr.style.top);\n    //     const n = (<any>tr)._wb_node;\n    //     // if (i < 4) {\n    //     //   console.info(\n    //     //     `TR#${i}, rowIdx=${n._rowIdx} , top=${top}px: '${n.title}'`\n    //     //   );\n    //     // }\n    //     if (prev >= 0 && top !== prev + ROW_HEIGHT) {\n    //       n.logWarn(\n    //         `TR order mismatch at index ${i}: top=${top}px != ${\n    //           prev + ROW_HEIGHT\n    //         }`\n    //       );\n    //       // throw new Error(\"fault\");\n    //       ok = false;\n    //     }\n    //     prev = top;\n    //     i++;\n    //   });\n    //   return ok;\n    // }\n    /*\n     * - Traverse all *visible* nodes of the whole tree, i.e. skip collapsed nodes.\n     * - Store count of rows to `tree.treeRowCount`.\n     * - Renumber `node._rowIdx` for all visible nodes.\n     * - Calculate the index range that must be rendered to fill the viewport\n     *   (including upper and lower prefetch)\n     * -\n     */\n    _updateRows(options) {\n        // const label = this.logTime(\"_updateRows\");\n        // this.log(\"_updateRows\", opts)\n        options = Object.assign({ newNodesOnly: false }, options);\n        const newNodesOnly = !!options.newNodesOnly;\n        const row_height = ROW_HEIGHT;\n        const vp_height = this.element.clientHeight;\n        const prefetch = RENDER_MAX_PREFETCH;\n        // const grace_prefetch = RENDER_MAX_PREFETCH - RENDER_MIN_PREFETCH;\n        const ofs = this.element.scrollTop;\n        let startIdx = Math.max(0, ofs / row_height - prefetch);\n        startIdx = Math.floor(startIdx);\n        // Make sure start is always even, so the alternating row colors don't\n        // change when scrolling:\n        if (startIdx % 2) {\n            startIdx--;\n        }\n        let endIdx = Math.max(0, (ofs + vp_height) / row_height + prefetch);\n        endIdx = Math.ceil(endIdx);\n        // const obsoleteViewNodes = this.viewNodes;\n        // this.viewNodes = new Set();\n        // const viewNodes = this.viewNodes;\n        // this.debug(\"render\", opts);\n        const obsoleteNodes = new Set();\n        this.nodeListElement.childNodes.forEach((elem) => {\n            const tr = elem;\n            obsoleteNodes.add(tr._wb_node);\n        });\n        let idx = 0;\n        let top = 0;\n        let modified = false;\n        let prevElem = \"first\";\n        this.visitRows(function (node) {\n            // node.log(\"visit\")\n            const rowDiv = node._rowElem;\n            // Renumber all expanded nodes\n            if (node._rowIdx !== idx) {\n                node._rowIdx = idx;\n                modified = true;\n            }\n            if (idx < startIdx || idx > endIdx) {\n                // row is outside viewport bounds\n                if (rowDiv) {\n                    prevElem = rowDiv;\n                }\n            }\n            else if (rowDiv && newNodesOnly) {\n                obsoleteNodes.delete(node);\n                // no need to update existing node markup\n                rowDiv.style.top = idx * ROW_HEIGHT + \"px\";\n                prevElem = rowDiv;\n            }\n            else {\n                obsoleteNodes.delete(node);\n                // Create new markup\n                if (rowDiv) {\n                    rowDiv.style.top = idx * ROW_HEIGHT + \"px\";\n                }\n                node.render({ top: top, after: prevElem });\n                // node.log(\"render\", top, prevElem, \"=>\", node._rowElem);\n                prevElem = node._rowElem;\n            }\n            idx++;\n            top += row_height;\n        });\n        this.treeRowCount = idx;\n        for (const n of obsoleteNodes) {\n            n._callEvent(\"discard\");\n            n.removeMarkup();\n        }\n        // Resize tree container\n        this.nodeListElement.style.height = `${top}px`;\n        // this.log(\n        //   `_updateRows(scrollOfs:${ofs}, ${startIdx}..${endIdx})`,\n        //   this.nodeListElement.style.height\n        // );\n        // this.logTimeEnd(label);\n        // this._validateRows();\n        return modified;\n    }\n    /**\n     * Call `callback(node)` for all nodes in hierarchical order (depth-first, pre-order).\n     * @see {@link IterableIterator<WunderbaumNode>}, {@link WunderbaumNode.visit}.\n     *\n     * @param {function} callback the callback function.\n     *     Return false to stop iteration, return \"skip\" to skip this node and\n     *     children only.\n     * @returns {boolean} false, if the iterator was stopped.\n     */\n    visit(callback) {\n        return this.root.visit(callback, false);\n    }\n    /**\n     * Call callback(node) for all nodes in vertical order, top down (or bottom up).\n     *\n     * Note that this considers expansion state, i.e. filtered nodes and children\n     * of collapsed nodes are skipped, unless `includeHidden` is set.\n     *\n     * Stop iteration if callback() returns false.<br>\n     * Return false if iteration was stopped.\n     *\n     * @returns {boolean} false if iteration was canceled\n     */\n    visitRows(callback, options) {\n        if (!this.root.hasChildren()) {\n            return false;\n        }\n        if (options && options.reverse) {\n            delete options.reverse;\n            return this._visitRowsUp(callback, options);\n        }\n        options = options || {};\n        let i, nextIdx, parent, res, siblings, stopNode, siblingOfs = 0, skipFirstNode = options.includeSelf === false, includeHidden = !!options.includeHidden, checkFilter = !includeHidden && this.filterMode === \"hide\", node = options.start || this.root.children[0];\n        parent = node.parent;\n        while (parent) {\n            // visit siblings\n            siblings = parent.children;\n            nextIdx = siblings.indexOf(node) + siblingOfs;\n            assert(nextIdx >= 0, `Could not find ${node} in parent's children: ${parent}`);\n            for (i = nextIdx; i < siblings.length; i++) {\n                node = siblings[i];\n                if (node === stopNode) {\n                    return false;\n                }\n                if (checkFilter &&\n                    !node.statusNodeType &&\n                    !node.match &&\n                    !node.subMatchCount) {\n                    continue;\n                }\n                if (!skipFirstNode && callback(node) === false) {\n                    return false;\n                }\n                skipFirstNode = false;\n                // Dive into node's child nodes\n                if (node.children &&\n                    node.children.length &&\n                    (includeHidden || node.expanded)) {\n                    res = node.visit(function (n) {\n                        if (n === stopNode) {\n                            return false;\n                        }\n                        if (checkFilter && !n.match && !n.subMatchCount) {\n                            return \"skip\";\n                        }\n                        if (callback(n) === false) {\n                            return false;\n                        }\n                        if (!includeHidden && n.children && !n.expanded) {\n                            return \"skip\";\n                        }\n                    }, false);\n                    if (res === false) {\n                        return false;\n                    }\n                }\n            }\n            // Visit parent nodes (bottom up)\n            node = parent;\n            parent = parent.parent;\n            siblingOfs = 1; //\n            if (!parent && options.wrap) {\n                this.logDebug(\"visitRows(): wrap around\");\n                assert(options.start, \"`wrap` option requires `start`\");\n                stopNode = options.start;\n                options.wrap = false;\n                parent = this.root;\n                siblingOfs = 0;\n            }\n        }\n        return true;\n    }\n    /**\n     * Call fn(node) for all nodes in vertical order, bottom up.\n     * @internal\n     */\n    _visitRowsUp(callback, options) {\n        let children, idx, parent, includeHidden = !!options.includeHidden, node = options.start || this.root.children[0];\n        if (options.includeSelf !== false) {\n            if (callback(node) === false) {\n                return false;\n            }\n        }\n        while (true) {\n            parent = node.parent;\n            children = parent.children;\n            if (children[0] === node) {\n                // If this is already the first sibling, goto parent\n                node = parent;\n                if (!node.parent) {\n                    break; // first node of the tree\n                }\n                children = parent.children;\n            }\n            else {\n                // Otherwise, goto prev. sibling\n                idx = children.indexOf(node);\n                node = children[idx - 1];\n                // If the prev. sibling has children, follow down to last descendant\n                while ((includeHidden || node.expanded) &&\n                    node.children &&\n                    node.children.length) {\n                    children = node.children;\n                    parent = node;\n                    node = children[children.length - 1];\n                }\n            }\n            // Skip invisible\n            if (!includeHidden && !node.isVisible()) {\n                continue;\n            }\n            if (callback(node) === false) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Reload the tree with a new source.\n     *\n     * Previous data is cleared. Note that also column- and type defintions may\n     * be passed with the `source` object.\n     */\n    load(source) {\n        this.clear();\n        return this.root.load(source);\n    }\n    /**\n     * Disable render requests during operations that would trigger many updates.\n     *\n     * ```js\n     * try {\n     *   tree.enableUpdate(false);\n     *   // ... (long running operation that would trigger many updates)\n     *   foo();\n     *   // ... NOTE: make sure that async operations have finished, e.g.\n     *   await foo();\n     * } finally {\n     *   tree.enableUpdate(true);\n     * }\n     * ```\n     */\n    enableUpdate(flag) {\n        /*\n            5  7  9                20       25   30\n        1   >-------------------------------------<\n        2      >--------------------<\n        3         >--------------------------<\n        */\n        if (flag) {\n            assert(this._disableUpdateCount > 0, \"enableUpdate(true) was called too often\");\n            this._disableUpdateCount--;\n            // this.logDebug(\n            //   `enableUpdate(${flag}): count -> ${this._disableUpdateCount}...`\n            // );\n            if (this._disableUpdateCount === 0) {\n                this.logDebug(`enableUpdate(): active again. Re-painting to catch up with ${this._disableUpdateIgnoreCount} ignored update requests...`);\n                this._disableUpdateIgnoreCount = 0;\n                this.setModified(ChangeType.any, { immediate: true });\n            }\n        }\n        else {\n            this._disableUpdateCount++;\n            // this.logDebug(\n            //   `enableUpdate(${flag}): count -> ${this._disableUpdateCount}...`\n            // );\n            // this._disableUpdate = Date.now();\n        }\n        // return !flag; // return previous value\n    }\n    /* ---------------------------------------------------------------------------\n     * FILTER\n     * -------------------------------------------------------------------------*/\n    /**\n     * [ext-filter] Dim or hide nodes.\n     */\n    filterNodes(filter, options) {\n        return this.extensions.filter.filterNodes(filter, options);\n    }\n    /**\n     * [ext-filter] Dim or hide whole branches.\n     */\n    filterBranches(filter, options) {\n        return this.extensions.filter.filterBranches(filter, options);\n    }\n    /**\n     * [ext-filter] Reset the filter.\n     *\n     * @requires [[FilterExtension]]\n     */\n    clearFilter() {\n        return this.extensions.filter.clearFilter();\n    }\n    /**\n     * [ext-filter] Return true if a filter is currently applied.\n     *\n     * @requires [[FilterExtension]]\n     */\n    isFilterActive() {\n        return !!this.filterMode;\n    }\n    /**\n     * [ext-filter] Re-apply current filter.\n     *\n     * @requires [[FilterExtension]]\n     */\n    updateFilter() {\n        return this.extensions.filter.updateFilter();\n    }\n}\nWunderbaum.sequence = 0;\n/** Wunderbaum release version number \"MAJOR.MINOR.PATCH\". */\nWunderbaum.version = \"v0.3.5\"; // Set to semver by 'grunt release'\n/** Expose some useful methods of the util.ts module as `Wunderbaum.util`. */\nWunderbaum.util = util;\n\nexport { Wunderbaum };\n","/* eslint-env browser */\n\nconst bufferToHex = buffer => {\n\tconst view = new DataView(buffer);\n\n\tlet hexCodes = '';\n\tfor (let index = 0; index < view.byteLength; index += 4) {\n\t\thexCodes += view.getUint32(index).toString(16).padStart(8, '0');\n\t}\n\n\treturn hexCodes;\n};\n\nconst create = algorithm => async (buffer, {outputFormat = 'hex'} = {}) => {\n\tif (typeof buffer === 'string') {\n\t\tbuffer = new globalThis.TextEncoder().encode(buffer);\n\t}\n\n\tconst hash = await globalThis.crypto.subtle.digest(algorithm, buffer);\n\n\treturn outputFormat === 'hex' ? bufferToHex(hash) : hash;\n};\n\nexport const sha1 = create('SHA-1');\nexport const sha256 = create('SHA-256');\nexport const sha384 = create('SHA-384');\nexport const sha512 = create('SHA-512');\n","export { SvelteComponentDev as SvelteComponent, SvelteComponentTyped, afterUpdate, beforeUpdate, createEventDispatcher, getAllContexts, getContext, hasContext, onDestroy, onMount, setContext, tick } from './internal/index.mjs';\n","function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element.sheet;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n    return style.sheet;\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentNode !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes, is_svg) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration(undefined, is_svg);\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes, is_svg);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    if (value === null) {\n        node.style.removeProperty(key);\n    }\n    else {\n        node.style.setProperty(key, value, important ? 'important' : '');\n    }\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    select.selectedIndex = -1; // no option should be selected\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, cancelable, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor(is_svg = false) {\n        this.is_svg = false;\n        this.is_svg = is_svg;\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            if (this.is_svg)\n                this.e = svg_element(target.nodeName);\n            else\n                this.e = element(target.nodeName);\n            this.t = target;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes, is_svg = false) {\n        super(is_svg);\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\n// https://github.com/sveltejs/svelte/issues/3624\nconst managed_styles = new Map();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_style_information(doc, node) {\n    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };\n    managed_styles.set(doc, info);\n    return info;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);\n    if (!rules[name]) {\n        rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        managed_styles.forEach(info => {\n            const { ownerNode } = info.stylesheet;\n            // there is no ownerNode if it runs on jsdom.\n            if (ownerNode)\n                detach(ownerNode);\n        });\n        managed_styles.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail, { cancelable = false } = {}) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail, { cancelable });\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n            return !event.defaultPrevented;\n        }\n        return true;\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n    return context;\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n    const saved_component = current_component;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        while (flushidx < dirty_components.length) {\n            const component = dirty_components[flushidx];\n            flushidx++;\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        flushidx = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n    else if (callback) {\n        callback();\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\n/** regex of all html void element names */\nconst void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;\nfunction is_void(name) {\n    return void_element_names.test(name) || name.toLowerCase() === '!doctype';\n}\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, attrs_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (attrs_to_add) {\n        const classes_to_add = attrs_to_add.classes;\n        const styles_to_add = attrs_to_add.styles;\n        if (classes_to_add) {\n            if (attributes.class == null) {\n                attributes.class = classes_to_add;\n            }\n            else {\n                attributes.class += ' ' + classes_to_add;\n            }\n        }\n        if (styles_to_add) {\n            if (attributes.style == null) {\n                attributes.style = style_object_to_string(styles_to_add);\n            }\n            else {\n                attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\n            }\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nfunction merge_ssr_styles(style_attribute, style_directive) {\n    const style_object = {};\n    for (const individual_style of style_attribute.split(';')) {\n        const colon_index = individual_style.indexOf(':');\n        const name = individual_style.slice(0, colon_index).trim();\n        const value = individual_style.slice(colon_index + 1).trim();\n        if (!name)\n            continue;\n        style_object[name] = value;\n    }\n    for (const name in style_directive) {\n        const value = style_directive[name];\n        if (value) {\n            style_object[name] = value;\n        }\n        else {\n            delete style_object[name];\n        }\n    }\n    return style_object;\n}\nconst ATTR_REGEX = /[&\"]/g;\nconst CONTENT_REGEX = /[&<]/g;\n/**\n * Note: this method is performance sensitive and has been optimized\n * https://github.com/sveltejs/svelte/pull/5701\n */\nfunction escape(value, is_attr = false) {\n    const str = String(value);\n    const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\n    pattern.lastIndex = 0;\n    let escaped = '';\n    let last = 0;\n    while (pattern.test(str)) {\n        const i = pattern.lastIndex - 1;\n        const ch = str[i];\n        escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : (ch === '\"' ? '&quot;' : '&lt;'));\n        last = i + 1;\n    }\n    return escaped + str.substring(last);\n}\nfunction escape_attribute_value(value) {\n    // keep booleans, null, and undefined for the sake of `spread`\n    const should_escape = typeof value === 'string' || (value && typeof value === 'object');\n    return should_escape ? escape(value, true) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    const assignment = (boolean && value === true) ? '' : `=\"${escape(value, true)}\"`;\n    return ` ${name}${assignment}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\nfunction style_object_to_string(style_object) {\n    return Object.keys(style_object)\n        .filter(key => style_object[key])\n        .map(key => `${key}: ${style_object[key]};`)\n        .join(' ');\n}\nfunction add_styles(style_object) {\n    const styles = style_object_to_string(style_object);\n    return styles ? ` style=\"${styles}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.50.1' }, detail), { bubbles: true }));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nfunction validate_dynamic_element(tag) {\n    const is_string = typeof tag === 'string';\n    if (tag && !is_string) {\n        throw new Error('<svelte:element> expects \"this\" attribute to be a string.');\n    }\n}\nfunction validate_void_dynamic_element(tag) {\n    if (tag && is_void(tag)) {\n        throw new Error(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_styles, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, is_void, listen, listen_dev, loop, loop_guard, merge_ssr_styles, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, src_url_equal, start_hydrating, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_dynamic_element, validate_each_argument, validate_each_keys, validate_slots, validate_store, validate_void_dynamic_element, xlink_attr };\n","import { noop, safe_not_equal, subscribe, run_all, is_function } from '../internal/index.mjs';\nexport { get_store_value as get } from '../internal/index.mjs';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = new Set();\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (const subscriber of subscribers) {\n                    subscriber[1]();\n                    subscriber_queue.push(subscriber, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.add(subscriber);\n        if (subscribers.size === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            subscribers.delete(subscriber);\n            if (subscribers.size === 0) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let inited = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (inited) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        inited = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n        };\n    });\n}\n\nexport { derived, readable, writable };\n"],"names":[],"sourceRoot":""}